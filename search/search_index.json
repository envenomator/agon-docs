{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the community Agon Platform documentation","text":"<p>This is the community-driven documentation for the Agon Platform, covering the Agon Light, Olimex Agon Light 2, and the Agon Console8 hobbyist computers.  It is intended to be a comprehensive guide to the Agon Platform, including Agon MOS and VDP firmware, and the hardware and software that it supports.  It is intended to provide a guide to all of the features of the Agon platform with guidance on how to program for it, with information on the various features provided by different versions of the firmware.</p> <p>This site is intended to supercede the official documentation, and to provide a more comprehensive and up-to-date guide to the Agon Platform.  It is intended to be a living document, and to be updated as new features are added to the platform.</p> <p>The original documentation for Quark firmware can be found here. This community documentation was started because GitHub's wiki system does not allow easy contributions by users, and the original documentation contains some errors and omissions.  We don't use the wiki here, but just markdown files which are also automatically generated into a website.</p>"},{"location":"#want-to-contribute","title":"Want to contribute?","text":"<p>Great, please go to the github repository and create a Pull Request with your changes.</p>"},{"location":"#what-is-the-agon-light-and-what-is-the-agon-console8","title":"What is the Agon Light, and what is the Agon Console8","text":"<p>The Agon Light is a modern, fully open-source, 8-bit microcomputer and microcontroller in one small, low-cost board, designed by Bernado Kastrup aka The Byte Attic. As a computer, it is a standalone device that requires no host PC: it puts out its own video (VGA), audio (2 identical mono channels), accepts a PS/2 keyboard and has its own mass-storage in the form of a \u00b5SD card.  The Olimex Agon Light 2 and the Agon Light Origins edition are variations on the original Agon Light design.</p> <p>The Agon Console8 is a version of the Agon Light that also includes two Atari-compatible joystick ports, and a PS/2 mouse port, and a stylish case.  It was also designed by Bernado Kastrup aka The Byte Attic, and is manufactured by Heber Ltd.</p> <p>The Agon Light, Olimex Agon Light 2, and the Agon Console8 are all fully compatible with each other.  Software written for one will run on the other, and the same firmware can be used on both.  In this documentation, generally, the term \"Agon Light\" is used to refer to all variations.</p> <p>The main CPU is an eZ80F92, a modern Zilog Z80 microcontroller that is fully backwards compatible with the Z80. As well as running in a traditional 8-bit mode with a 64K address space, it can run in 24-bit mode with a 16MB address space, and is also capable of running in a hybrid mode with a mixture of 24-bit and 8-bit code.</p> <p>The eZ80F92 integrates a number of standard peripherals, including a UART, and hardware timers.</p> <p>There is a second CPU dedicated to handling video, sound, and keyboard, an ESP32-Pico-D4. This co-processor is linked to the eZ80F92 via a UART (a high speed serial communications link), and acts as a graphics terminal.</p>"},{"location":"#what-is-the-quark-firmware","title":"What is the Quark Firmware","text":"<p>The Quark firmware is the official operating system for the Agon Light. It consists of three main components:</p> <ul> <li>MOS: Machine Operating System</li> <li>VDP: Visual Display Processor</li> <li>BBC BASIC for Agon: A specially adapted port of R.T.Russell's excellent BASIC interpreter</li> </ul>"},{"location":"#how-can-i-find-out-more","title":"How can I find out more?","text":"<p>The following documents provide some more information</p> <ul> <li>Agon Platform theory of operation</li> <li>External documentation</li> <li>Using GPIO</li> <li>The Agon Projects github</li> <li>Third party projects</li> <li>FAQ</li> </ul>"},{"location":"#where-can-i-buy-one","title":"Where can I buy one?","text":"<ul> <li>Mouser</li> <li>The Pi Hut</li> <li>Olimex Ltd</li> <li>DigiKey</li> <li>PCBWay</li> <li>Agon Light Australia</li> <li>Agon Light Store (UK)</li> <li>Agon Console8 from Heber (UK)</li> </ul>"},{"location":"BBC-BASIC-for-Agon/","title":"What is BBC BASIC for Agon?","text":"<p>The original version of BBC Basic was written by Sophie Wilson at Acorn in 1981 for the BBC Micro range of computers, and was designed to support the UK Computer Literacy Project. R.T.Russell was involved in the specification of BBC Basic, and wrote his own Z80 version that was subsequently ported to a number of Z80 based machines. I highly recommend reading his account of this on his website for more details.</p> <p>As an aside, R.T.Russell still supports BBC Basic, and has ported it for a number of modern platforms, including Android, Windows, and SDL, which are available from his website here.</p> <p>BBC BASIC for Agon is a port of his BBC BASIC for Z80, which is now open source, with a number of modifications to make it run on Agon.</p>"},{"location":"BBC-BASIC-for-Agon/#implementation-on-the-agon-light","title":"Implementation on the Agon Light","text":"<p>BBC BASIC for Z80 runs in Z80 mode, that is within a 64K segment. The interpreter takes around 16K of RAM, leaving around 48K available for user programs and data.</p> <p>If you are not familiar with the BASIC programming language, or need a refresher on BBC BASIC, please refer to the official BBC BASIC for Agon documentation here.</p> <p>To run, load into memory and run as follows:</p> <pre><code>LOAD bbcbasic.bin\nRUN\n</code></pre> <p>It is possible to automatically CHAIN (load and run) a BBC BASIC program by passing the filename as a parameter: <pre><code>LOAD bbcbasic.bin\nRUN . /path/to/file.bas\n</code></pre></p> <p>Note that passing a . as the first parameter of RUN is informing MOS to use the default value there (&amp;40000)</p> <p>BBC BASIC needs a full 64K segment, so cannot be run from the MOS folder as a star command.</p>"},{"location":"BBC-BASIC-for-Agon/#summary-of-agon-light-specific-changes","title":"Summary of Agon Light Specific Changes","text":""},{"location":"BBC-BASIC-for-Agon/#star-commands","title":"Star Commands","text":"<p>The following * commands are supported</p>"},{"location":"BBC-BASIC-for-Agon/#bye","title":"BYE","text":"<p>Syntax: <code>*BYE</code></p> <p>Exit BASIC and return to MOS.</p>"},{"location":"BBC-BASIC-for-Agon/#edit","title":"EDIT","text":"<p>Syntax: <code>*EDIT linenum</code></p> <p>Pull a line into the editor for editing.</p>"},{"location":"BBC-BASIC-for-Agon/#fx","title":"FX","text":"<p>Syntax: <code>*FX osbyte, params</code></p> <p>Execute an OSBYTE command.</p> <p>The only OSBYTE commands supported at the moment are:</p> <ul> <li>19: Wait for vertical blank retrace</li> </ul> <p>And from MOS 1.03 or above</p> <ul> <li>11: Set keyboard repeat delay in ms (250, 500, 750 or 1000)</li> <li>12: Set keyboard repeat rate ins ms (between 33 and 500ms)</li> <li>118: Set keyboard LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock) - does not currently change status, just the LED</li> </ul>"},{"location":"BBC-BASIC-for-Agon/#version","title":"VERSION","text":"<p>Syntax: <code>*VERSION</code></p> <p>Display the current version of BBC BASIC</p>"},{"location":"BBC-BASIC-for-Agon/#mos-commands","title":"MOS commands","text":"<p>In addition, any of the MOS commands can be called by prefixing them with a *</p> <p>See the MOS documentation for more details</p>"},{"location":"BBC-BASIC-for-Agon/#basic","title":"BASIC","text":"<p>The following statements are not currently implemented:</p> <ul> <li>ENVELOPE</li> <li>ADVAL</li> </ul> <p>The following statements differ from the BBC Basic standard:</p>"},{"location":"BBC-BASIC-for-Agon/#rem","title":"REM","text":"<p>REM does not tokenise any statements within comments. This is to bring it inline with string literals for internationalisation.</p>"},{"location":"BBC-BASIC-for-Agon/#load","title":"LOAD","text":""},{"location":"BBC-BASIC-for-Agon/#save","title":"SAVE","text":"<p>The following file extensions are supported:</p> <ul> <li><code>.BBC</code>: LOAD and SAVE in BBC BASIC for Z80 tokenised format</li> <li><code>.BAS</code>: LOAD and SAVE in plain text format (also <code>.TXT</code> and <code>.ASC</code>)</li> </ul> <p>If a file extension is omitted, \".BBC\" is assumed.</p>"},{"location":"BBC-BASIC-for-Agon/#mode","title":"MODE","text":"<p>The modes differ from those on the BBC series of microcomputers. The full list can be found here in the VDP documentation.</p>"},{"location":"BBC-BASIC-for-Agon/#colour","title":"COLOUR","text":"<p>Syntax: <code>COLOUR c</code></p> <p>Change the the current text output colour</p> <ul> <li>If c is between 0 and 63, the foreground text colour will be set</li> <li>If c is between 128 and 191, the background text colour will be set</li> </ul> <p>The following two commands are only applicable to paletted modes with less than 64 colours.</p> <p>Syntax: <code>COLOUR l,p</code></p> <p>Set the logical colour l to the physical colour p</p> <p>Syntax: <code>COLOUR l,r,g,b</code></p>"},{"location":"BBC-BASIC-for-Agon/#gcol","title":"GCOL","text":"<p>Syntax: <code>GCOL mode,c</code></p> <p>Set the graphics colour <code>c</code>, and the \"mode\" of graphics paint operations.</p> <p>Colour values are interpreted as per the COLOUR command, i.e. values below 128 will set the foreground colour, and values above 128 set the background colour.</p> <p>Versions of the VDP earlier than 1.04 only supported mode 0, with all painting operations just setting on-screen pixels.</p> <p>VDP 1.04 introduced partial support for mode 4, which inverts the pixel.  Mode 4 would only apply to straight line drawing operations.  The mode would affect all applicable plot operations.</p> <p>As of Console8 VDP 2.6.0, all 8 of the basic modes are supported for all currently supported plot operations.  Separate plot modes are now tracked for foreground and background colours, and the mode is applied to the graphics operation.</p> <p>The full array of available modes is as follows:</p> Mode Effect 0 Set on-screen pixel to target colour value 1 OR value with the on-screen pixel 2 AND value with the on-screen pixel 3 EOR value with the on-screen pixel 4 Invert the on-screen pixel 5 No operation 6 AND the inverse of the specified colour with the on-screen pixel 7 OR the inverse of the specified colour with the on-screen pixel"},{"location":"BBC-BASIC-for-Agon/#point","title":"POINT","text":"<p>Syntax: <code>POINT(x,y)</code></p> <p>This returns the physical colour index of the colour at pixel position (x, y)</p>"},{"location":"BBC-BASIC-for-Agon/#plot","title":"PLOT","text":"<p>Syntax: <code>PLOT mode,x,y</code></p> <p>For information on the various PLOT modes, please see the VDP PLOT command documentation</p>"},{"location":"BBC-BASIC-for-Agon/#get","title":"GET$","text":"<p>Syntax: <code>GET$(x,y)</code></p> <p>Returns the ASCII character at position x,y</p>"},{"location":"BBC-BASIC-for-Agon/#get_1","title":"GET","text":"<p>Syntax: <code>GET(x,y)</code> (from BBC BASIC 1.05)</p> <p>As GET$, but returns the ASCII code of the character at position x, y</p> <p>Syntax: <code>GET(p)</code></p> <p>Read and return the value of Z80 port p</p>"},{"location":"BBC-BASIC-for-Agon/#sound","title":"SOUND","text":"<p>Syntax: <code>SOUND channel,volume,pitch,duration</code></p> <p>Play a sound through the Agon Light buzzer and audio output jack</p> <ul> <li><code>Channel</code>: 0 to 2</li> <li><code>Volume</code>: 0 (off) to -15 (full volume)</li> <li><code>Pitch</code>: 0 to 255</li> <li><code>Duration</code>: -1 to 254 (duration in 20ths of a second, -1 = play forever)</li> </ul>"},{"location":"BBC-BASIC-for-Agon/#time","title":"TIME$","text":"<p>Access the ESP32 RTC data</p> <p>Example:</p> <pre><code>  10 REM CLOCK\n  20 : \n  30 CLS\n  40 PRINT TAB(2,2); TIME$\n  50 GOTO 40\n</code></pre> <p>NB: This is a virtual string variable; at the moment only getting the time works. Setting is not yet implemented.</p>"},{"location":"BBC-BASIC-for-Agon/#vdu","title":"VDU","text":"<p>The VDU commands on the Agon Light will be familiar to those who have coded on Acorn machines. Please read the [[VDP]] documentation for details on what VDU commands are supported.</p>"},{"location":"BBC-BASIC-for-Agon/#inline-assembler","title":"Inline Assembler","text":"<p>BBC BASIC for Z80, like its 6502 counterpart, includes an inline assembler. For instructions on usage, please refer to the original documentation.</p> <p>In addition to the standard set of Z80 instructions, the following eZ80 instructions have been added</p> <ul> <li><code>MLT</code></li> </ul> <p>The assembler will only compile 8-bit Z80 code and there are currently no plans for extending the instruction set much further in this version.</p>"},{"location":"BBC-BASIC-for-Agon/#integration-with-mos","title":"Integration with MOS","text":"<p>For the most part, the MOS is transparent to BASIC; most of the operations via the MOS and VDP are accessed via normal BBC BASIC statements, with the following exceptions:</p>"},{"location":"BBC-BASIC-for-Agon/#accessing-the-mos-system-variables","title":"Accessing the MOS system variables","text":"<p>MOS has a small system variables area which is in an area of RAM outside of its 64K segment. To access these, you will need to do an OSBYTE call</p> <p>Example: Print the least significant byte of the internal clock counter <pre><code>10 L%=&amp;00 : REM The system variable to fetch\n20 A%=&amp;A0 : REM The OSBYTE number\n30 PRINT USR(&amp;FFF4)\n</code></pre></p> <p>Documentation for the full list of system variables can be found in the MOS API documentation.</p>"},{"location":"BBC-BASIC-for-Agon/#running-star-commands-with-variables","title":"Running star commands with variables","text":"<p>The star command parser does not use the same evaluator as BBC BASIC, so whilst commands can be run in BASIC, variable names are treated as literals.</p> <p>Example: This will not work <pre><code>10 INPUT \"Filename\";f$\n20 INPUT \"Load Address\";addr%\n30 *LOAD f$ addr%\n</code></pre></p> <p>To do this correctly, you must call the star command indirectly using the OSCLI command</p> <p>Example: This will work <pre><code>30 OSCLI(\"LOAD \" + f$ + \" \" + STR$(addr%)) \n</code></pre></p>"},{"location":"External-Documentation/","title":"Agon","text":"<ul> <li>Byte Attic: The Agon Light</li> <li>Break Into Program: Agon</li> </ul>"},{"location":"External-Documentation/#bbc-basic","title":"BBC BASIC","text":"<ul> <li>BBC BASIC for Agon Manual</li> </ul>"},{"location":"External-Documentation/#libraries","title":"Libraries","text":"<ul> <li>FabGL</li> <li>FatFS</li> </ul>"},{"location":"External-Documentation/#zilog","title":"Zilog","text":"<ul> <li>eZ80F92 Documentation</li> <li>eZ80 CPU</li> <li>Specification</li> <li>Calling C Functions from Assembly and Vice Versa</li> <li>ZDSII User Manual</li> </ul>"},{"location":"FAQ/","title":"Agon-FAQ","text":"<p>Most frequently asked questions (and answers) to using the Agon platform</p>"},{"location":"FAQ/#are-these-documents-available-offline-or-in-a-different-format","title":"Are these documents available offline or in a different format?","text":"<p>No, and there are no immediate plans on doing this to reduce the amount of time spent doing documentation.</p>"},{"location":"FAQ/#is-the-agon-open-source","title":"Is the Agon open source?","text":"<p>The official hardware and software components that are part of the Quark firmware are open source, including BBC BASIC for Agon. Please check the license of any third party applications.</p>"},{"location":"FAQ/#what-else-do-i-need-to-buy","title":"What else do I need to buy?","text":"<p>Okay, so you've ordered your Agon Light, and are wondering what else you will need to purchase.</p> <p>Minimum: - A PS/2 compatible keyboard - A micro USB card</p> <p>NB: - The orginal Agon Light requires a PS/2 keyboard, or a USB keyboard that supports the PS/2 protocol with a USB to PS/2 adaptor. - The Agon Light 2 requires a USB keyboard that supports the PS/2 protocol, or a PS/2 keyboard with a PS/2 to USB adaptor.</p>"},{"location":"FAQ/#does-agon-support-cpm","title":"Does AGON support CP/M?","text":"<p>Officially it is not designed to run CP/M out of the box. There are however third-party developers who are porting CP/M to the platform, and the official build will support this.</p>"},{"location":"FAQ/#is-there-a-template-available-for-the-sd-card-to-get-me-started-quickly","title":"Is there a template available for the SD card, to get me started quickly?","text":"<p>Check out the Popup MOS repository; click the green 'Code' icon and select 'Download ZIP' from the dropdown menu. Unzip the file and copy over everything from the 'popup-os-main' folder to an empty SD card. The card should have folders like demos/docs/games/mos/utils in the root of the card</p> <p>Another great distribution is Agon Mite which has a monthly release cycle.</p> <p>These repositories are a volunteer effort, periodically collecting the latest versions of software out there. If you need a more recent version of any package, because sometimes development goes pretty fast; please download it individually to your SD card.</p>"},{"location":"FAQ/#what-kind-of-sd-card-should-i-use","title":"What kind of SD card should I use?","text":"<p>Any class-10 micro SD card of a decent quality will do fine</p>"},{"location":"FAQ/#what-size-sd-card-should-i-buy","title":"What size SD card should I buy?","text":"<p>You should aim for a maximum card size of 32GB. Larger cards are supported (using FAT32), but you may run into issues partitioning and formatting them.</p>"},{"location":"FAQ/#how-should-i-format-the-sd-card-initially","title":"How should I format the SD card initially?","text":"<p>Format the card using a FAT32 layout</p>"},{"location":"FAQ/#will-my-agon-boot-directly-into-bbc-basic-or-will-i-have-to-download-the-language-onto-an-sd-card","title":"Will my Agon boot directly into BBC BASIC or will I have to download the language onto an SD card?","text":"<p>Most distributions contain both the BBC BASIC binary (bbcbasic.bin), and an autoexec.txt file at top level of SD card. The latter contains commands for auto loading BBC Basic. If you'd like to disable auto loading BBC BASIC; remove it, or change the content to suit your own requirements.</p>"},{"location":"FAQ/#how-should-i-power-the-agon","title":"How should I power the Agon?","text":"<p>All Agon platforms can be powered using a USB cable to your PC, or a USB wall-charger. The load is relatively light, usually below 200mA with a connected keyboard. Which USB cable you need, depends on the variant of Agon you buy. For example, the Olimex AgonLight2 is powered from a USB-C interface, while the Agon Console8 can be powered using a USB-B interface. The latter can also be powered with 5v DC jack connector.</p>"},{"location":"FAQ/#how-can-i-update-the-agon","title":"How can I update the Agon?","text":"<p>It really depends on the current firmware versions on your Agon. The Agon contains firmware for both the OS (MOS) and graphics unit (VDP).</p> <p>If both VDP and MOS are currently still at 1.03, as most Olimex AgonLight2 boards are, follow this detailed guide to upgrade it. This is only necessary once; from 1.04 onwards, all upgrades can be done with the flash tool.</p> <p>If you are running at least VDP and MOS 1.04, just install the flash tool, get the appropriate firmware files (see below for examples) and read the short documentation on the page to upgrade both VDP and MOS in one go. The latest version can be found under the releases tab. The page also has a link to help you upgrade, if you are running an even older version than 1.03.</p> <p>this flowchart provides an overview of the overall process, instructions for all version combinations of VDP and MOS and additional links to use, depending on your current version starting points.</p>"},{"location":"FAQ/#where-can-i-find-the-latest-agon-firmwares-to-download","title":"Where can I find the latest Agon firmware(s) to download?","text":"<p>I recommend using the Console8 firmware. - Console8 MOS firmware - Console8 VDP firmware</p>"},{"location":"FAQ/#which-firmware-do-you-currently-recommend-using-on-my-agon","title":"Which firmware do you currently recommend using on my Agon?","text":"<p>We recommend using the Console8 firmware, as most development currently takes place there while staying compatible with previously released software. It's important to mention that the latest, most interesting games, make use of features that are only available in the Console8 (VDP) firmware, so make sure to use that.</p>"},{"location":"FAQ/#can-i-switch-between-the-quark-firmware-and-console8-firmware","title":"Can I switch between the Quark firmware and Console8 firmware?","text":"<p>Yes, either way.</p>"},{"location":"FAQ/#what-is-the-function-of-agons-jumpers-and-what-is-their-recommended-position","title":"What is the function of Agon's jumpers and what is their recommended position?","text":""},{"location":"FAQ/#the-esp-jumper","title":"The ESP jumper","text":"<p>All Agon variants have a jumper location on the PCB marked 'ESP-PROG' or 'ESP-PROG1'. For programming the VDP over the USB interface, this needs to be CLOSED, i.e. both pins should be connected using the removable jumper. It is present on the PCB, to provide the option to prohibit the ESP32 to go into programming mode on reset, likely due to the way the USB serial driver behaves on your PC. If this happens to you occasionally and it looks like the Agon doesn't boot on a reset, it may be just waiting for an external programming session that never happens, spewing messages over the USB serial; in that case remove the jumper or leave it open, but remember to close it again before programming it externally over USB. The position of this jumper is ignored when programming the VDP using the flash tool from the MOS prompt. I recommend to leave this jumper in the CLOSED position, unless you experience problems resetting your Agon.</p>"},{"location":"FAQ/#the-uart-jumper","title":"The UART jumper","text":"<p>All Agon variants have a jumper to either enable, or prohibit the UART between the eZ80 and ESP32. During normal operation of the Agon, both ICs should be able to 'talk' to each other; this jumper was provided in case communication between them would somehow cause issues during programming either IC. AFAIK there haven't been cases to date where this proved necessary, but the option is at least there. If your Agon doesn't do anything after you have received it from your vendor, you may check this jumper's position. Cases have been reported of boards not working due to an incorrect factory jumper setting.</p> <ul> <li> <p>The AgonLight/AgonLight2/AgonLight Origins edition have this jumper labeled as 'UART-DIS' or 'UART-DIS1', which should be left OPEN to not disable communications and have a working Agon</p> </li> <li> <p>The Agon Console8 has this jumper labeled as 'UART-EN1', which should be CLOSED to enable communications and have a working Agon.</p> </li> </ul>"},{"location":"FAQ/#the-buzzer-jumper","title":"The Buzzer jumper","text":"<p>All Agon variants have a jumper to enable/disable the onboard buzzer, labeled 'BUZ-EN', 'BUZ_EN1' or 'BUZZER'. Leaving the jumper open disables the buzzer, while closing it enables it, whichever is your preference.</p>"},{"location":"FAQ/#do-i-need-to-buy-the-zilog-smart-cable-to-update-my-agon","title":"Do I need to buy the Zilog SMART cable to update my Agon?","text":"<p>No, not unless you will be developing your own Agon MOS firmware AND need to be comfortably sure you can recover it under ALL circumstances. And even then you may very well get by using one of the community-provided options. People in the community owning SMART cables are seldomly using them nowadays.</p> <p>Again, for regular update purposes, the Zilog SMART cable is unnecessary and a waste of money. If it's bricking you're worried about; there is a simple solution requiring just a few dupont cables and a clear step-by-step plan to recover your Agon. In any case, you can at least buy a new Agon for the price of the Zilog SMART cable. Ease your worries.</p>"},{"location":"FAQ/#i-still-would-like-to-buy-a-zilog-smart-cable-which-one-should-i-get","title":"I still would like to buy a Zilog SMART cable. Which one should I get?","text":"<p>The Agon-compatible Zilog product numbers are: - ZUSBSC00100ZACG (discontinued) - ZUSBASC0200ZACG (current; requires v5.3.5 or later of Zilog\u2019s ZDS -II IDE)</p> <p>ATTENTION: the cable with product number ZUSBESC0200ZACG is NOT suitable for Agon!</p>"},{"location":"FAQ/#can-i-go-back-to-an-earlier-firmware-version-downgrade","title":"Can I go back to an earlier firmware version / downgrade?","text":"<p>Absolutely (and this has been tested), but cecause literally ANY version can be flashed, please be mindful going back to older versions. The Pleistocene may not have a wall-outlet to charge your time travel device.</p> <p>Do yourselves a big favor, and stay away from anything below Quark 1.03, or that Zilog ZDS cable I mentioned you shouldn't buy, might suddenly start get interesting again.</p>"},{"location":"FAQ/#do-i-understand-correctly-that-the-console8-firmwares-can-be-used-with-any-agon-platform","title":"Do I understand correctly, that the Console8 firmware(s) can be used with any Agon platform?","text":"<p>Yes, it can be used with any Agon platform.</p>"},{"location":"FAQ/#how-should-i-connect-the-agon-to-my-pc-for-programming-the-vdp","title":"How should I connect the Agon to my PC for programming the VDP?","text":"<p>To program an older VDP (1.03 or earlier) to a newer version, you need to connect the Agon using a USB (data) cable. Some very cheap USB cables may only have wires for powering/charging a USB device, without any wired datalines. Fortunately these are becoming scarce nowadays, but if all else fails, you might be using the wrong cable (or have the incorrect jumper setting; see above)</p> <p>The Agon will present a virtual serial port (COM) on your PC, that communicates directly with the ESP32 graphics chip (VDP).</p>"},{"location":"FAQ/#how-can-i-find-out-the-com-port-on-my-pc-to-connect-to-the-agon","title":"How can I find out the COM port on my PC, to connect to the Agon?","text":"<p>It depends on the OS you have. In Linux, when you insert your USB cable and type 'dmesg | grep tty', it should show. </p> <p>In Windows, it should show up in device manager, or in powershell type '[System.IO.Ports.SerialPort]::getportnames()'.</p> <p>In Mac OS, you can type 'ls /dev/tty.*' in Terminal to list all com ports currently attached.</p>"},{"location":"FAQ/#why-is-agon-model-xxx-delivered-with-out-of-date-firmware","title":"Why is Agon model XXX delivered with out-of-date firmware?","text":"<p>A legitimate question that you need to ask the respective vendor of your Agon.</p>"},{"location":"FAQ/#what-keyboard-do-i-need-for-my-agon","title":"What keyboard do I need for my Agon?","text":"<p>You need a keyboard that supports the PS/2 protocol, regardless of the physical connection that it has. Some Agon variants have a PS/2 interface, so any keyboard with a PS/2 connector should be fine. However, a number of Agon variants use a USB connector for their keyboard interface; for these you either need a USB keyboard that still supports the PS/2 protocol in backward compatibility mode (and it is usually hard to find out if it does), or a regular PS/2 keyboard with a PASSIVE PS/2-to-USB connector. An example for the latter, which is known to work well is this one. This is a pass-through connector, that just rewires the PS/2 signals to the USB connector. Perfect for the Agon.</p> <p>A PS/2-to-USB connector cannot make use of active logic and/or microcontrollers inside the connector. If the connector is dirt-cheap, it's usually passive, but even active converters can be offered relatively cheap.</p> <p>If a PS/2-&gt;USB converter has both a PS/2 keyboard and PS/2 mouse cable, a thick USB connector and/or a 'bulge' in the middle of the cable AND it doesn't specifically mention the term PASSIVE, it's a dead giveaway to be an active (non-supported) converter. Don't buy these: they scan/convert the PS/2 signals to a USB HID protocol that the Agon doesn't support. Examples to avoid 1 and 2</p>"},{"location":"FAQ/#can-you-recommend-a-ps2-keyboard","title":"Can you recommend a PS/2 keyboard?","text":"<p>Sure, there's a crowd-sourced spreadsheet here with a list of known working keyboards.</p> <p>If you have one, and it's not on the list, then please feel free to add an entry.</p>"},{"location":"FAQ/#how-do-i-configure-a-different-keyboard-layout","title":"How do I configure a different keyboard layout?","text":"<p>You can use the following command from the MOS command line, from BBC BASIC (using the *), or loaded on boot/reset using a line in the autoexec.txt file on your SD card:</p> <pre><code>*SET KEYBOARD n\n</code></pre> <p>The keyboard layout for UK = 0, US = 1 Other available layouts are available from MOS 1.03+, documented here</p>"},{"location":"FAQ/#how-do-i-exit-to-the-mos-command-line-from-within-bbc-basic","title":"How do I exit to the MOS command line, from within BBC Basic?","text":"<p>Use the following command:</p> <pre><code>*BYE\n</code></pre>"},{"location":"FAQ/#where-can-i-find-the-userhardware-manual-for-my-agon-edition","title":"Where can I find the user/hardware manual for my Agon edition?","text":"<p>Check out these links for your particular Agon edition: - Byte Attic AgonLight R1.0 - Byte Attic Agon Origins edition - Olimex AgonLight2 - Agon Console8</p>"},{"location":"FAQ/#is-there-a-community-list-of-agon-software","title":"Is there a community list of Agon software?","text":"<p>We're listing a few here, though there will certainly be others: - Sabotrax/agon-software - The Byte Attic - Agon overview</p>"},{"location":"FAQ/#is-there-an-emulator-available","title":"Is there an Emulator available?","text":"<p>Indeed there is</p>"},{"location":"FAQ/#what-is-the-difference-between-the-agon-light-and-the-olimex-agon-light-2","title":"What is the difference between the Agon Light and the Olimex Agon Light 2?","text":"<p>The main differences are:</p> <ul> <li>The keyboard connector is USB, yet still requires a keyboard that supports the PS/2 protocol</li> <li>LIPO battery charging circuit</li> <li>UEXT connector</li> <li>USB C power connector</li> <li>Plastic boxed 34-pin GPIO connector </li> </ul> <p>And there are some minor revisions to discrete components on the board. Other than that, it is functionally identical to the original Agon Light design.</p>"},{"location":"FAQ/#im-having-issues-with-some-video-modes","title":"I'm having issues with some video modes","text":"<p>Historically, this has been a problem when the VDP firmware was built using the Arduino IDE.  You are strongly advised to use PlatformIO to build the VDP firmware, and to update to the latest versions; in doing so you should no longer have any issues with screen modes.  PlatformIO takes care of all the dependencies and settings and thus is much easier to use than the Arduino IDE.  The Console8 VDP firmware no longer supports being built using the Arduino IDE and instead is built using PlatformIO to avoid these kind of issues.</p> <p>If you wish to still use the Arduino IDE and are building the Quark variant of the VDP firmware, you will need to make sure you have PSRAM enabled in the Arduino IDE settings when you compile and transfer the VDP code.</p>"},{"location":"FAQ/#id-like-to-start-programming-bbc-basic-where-might-i-start","title":"I'd like to start programming BBC Basic - where might I start?","text":"<p>Have a look at this excellent guide. We also provide some documentation at our community site.</p>"},{"location":"FAQ/#are-there-any-simple-bbc-basic-examples","title":"Are there any simple BBC BASIC examples?","text":"<p>Your AGON may have a 'tests' folder with some BBC BASIC examples; if it doesn't, they can be found here.</p>"},{"location":"FAQ/#is-basic-the-only-programming-language-available","title":"Is BASIC the only programming language available?","text":"<p>The AGON comes pre-shipped with BASIC as it is a good language to start coding with, but you are not limited to it. The following languages are supported:</p> <ul> <li>Forth</li> <li>Assembly Language (either via BBC Basic inline assembler or external assembler)</li> <li>C (Cross-compiled from a PC, via ZDS tools or AgDev)</li> </ul>"},{"location":"FAQ/#id-like-to-start-assembly-programming-for-the-agon-platform-where-might-i-start","title":"I'd like to start assembly programming for the Agon platform - where might I start?","text":"<p>We would recommend watching and learning these excellent tutorials</p> <p>Download the latest version of the onboard assembler. Don't dally using the one that came with your uSD card package, things move quickly in this space - use the latest.</p>"},{"location":"FAQ/#id-like-to-start-cc-programming-for-the-agon-platform-where-might-i-start","title":"I'd like to start C/C++ programming for the Agon platform - where might I start?","text":"<p>Assuming you already know some C/C++, start downloading the best C/C++ cross-development toolchain there currently is, and look at some online examples from tools/games.</p>"},{"location":"FAQ/#id-like-to-start-forth-programming-for-the-agon-platform-where-might-i-start","title":"I'd like to start Forth programming for the Agon platform - where might I start?","text":"<p>There is an excellent Forth implementation available here</p>"},{"location":"FAQ/#is-there-some-in-depth-api-documentation-available-for-me-to-look-at","title":"Is there some in-depth API documentation available for me to look at?","text":"<p>The community is building out at set of markdown documents to detail several aspects. These are extremely useful to a programmer.</p>"},{"location":"FAQ/#is-there-a-documented-memory-map-available-to-me-as-a-programmer","title":"Is there a documented memory map available to me as a programmer?","text":"<p>A memory map can be found here</p>"},{"location":"FAQ/#id-like-to-read-all-details-about-agons-ez80-microcontroller","title":"I'd like to read all details about Agon's ez80 microcontroller","text":"<p>Buckle up!</p> <ul> <li>eZ80F92 datasheet - details regarding the eZ80F92 microcontroller peripherals like I2C, SPI, Flash memory, debug interface, timers</li> <li>eZ80 CPU datasheet - details regarding the ez80 CPU itself, cpu architecture, registers, memory mode, interrupts and instruction set</li> <li>Application note AN033301-0711 - details of the ZDS Application Binary Interface (ABI), how to call C functions from Assembly and vice versa. Also applicable to the AgDev environment which is compliant to the ABI.</li> </ul>"},{"location":"FAQ/#can-you-code-feature-x","title":"Can you code feature {x}?","text":"<p>All suggestions are welcome, though the developers will be concentrating on key features. If we think your idea has legs, we'll add it to the pile.</p>"},{"location":"FAQ/#why-is-feature-x-not-documented-anywhere","title":"Why is feature {x} not documented anywhere?","text":"<p>You might have found an opportunity to make a valuable contribution to the Agon community. Take a look at the community documentation and create a pull request.</p>"},{"location":"FAQ/#id-like-to-discuss-my-project-or-ideas-with-like-minded-people","title":"I'd like to discuss my project or ideas with like-minded people","text":"<p>Perhaps you have some cool ideas and you want to run them past people, or you want to watch some of the developers talk, or you've followed all the instructions here and broke something and now you'd like to ask around to see if someone else has had the same experience? There is a Discord server available for Agon &amp; Console 8 community discussions.</p>"},{"location":"GPIO/","title":"User GPIO pins","text":"<p>GPIO, or General Purpose Input and Output, is an interface on a computer that is not dedicated to a single task. On the Agon this is exposed as a series of pins for the user to interface to. This might be for input controls, such as a joystick or buttons, motion sensors, or outputs to control your Christmas tree lights, send data to other displays, microprocessors, or even connect to the internet.</p> <p>Whilst sharing many similar pins, there are some variations across the range of Agon machines.</p> <p>The first generation Agon Light has a double row of 32 pins, whereas the Agon Light 2 has a double row of 34 pins. The additional pair of pins have been added for a battery power supply connection.</p> <p>The Agon Console 8 adds a few extra rows for additional connectivity to other parts of the ESP processor.</p> <p>More information about using these features can be found in the MOS-API documentation.</p>"},{"location":"GPIO/#gpio-pinouts-original-agon-light-by-bernardo-kastrup","title":"GPIO Pinouts - Original Agon Light by Bernardo Kastrup","text":"<p>Viewed from the back, component side up, with the connector to the right of the board.</p> <p></p>"},{"location":"GPIO/#gpio-pinouts-agon-light-origins-edition-by-bernardo-kastrup","title":"GPIO Pinouts - Agon Light Origins Edition by Bernardo Kastrup","text":"<p>Viewed from the back, component side up, with the connector to the right of the board. A slight change with an additional pair of pins to the right hand side. The pin numbering is the same as the Agon Light 2 by Olimex.</p> <p></p>"},{"location":"GPIO/#gpio-pinouts-agon-light-2-manufactured-by-olimex","title":"GPIO Pinouts - Agon Light 2 manufactured by Olimex","text":"<p>The general layout is the same as the Origins Edition, apart from pins 1 &amp; 2.</p> <p></p> <p>Olimex's proprietary UEXT connector is mounted next to the main IO bus. </p> <p>Note that although there are duplicate pins exposed on the UEXT conector as the main IO bus, they are connected to the same pins on the ez80 chip. They are there for convenience, but do not provide any additional hardware ports.</p> <p>It is sometimes useful to have the duplicate pins for different purposes. For example, connecting a Nintendo Nunchuck controller on the UEXT using Olimex's adapter board, and a joystick on the main IO bus.</p> <p></p>"},{"location":"GPIO/#gpio-pinouts-console-8-manufactured-by-heber","title":"GPIO Pinouts - Console 8 manufactured by Heber","text":"<p>Viewed from the top front, component side up.</p> <p>The Console 8's pin numbering is different and although they look similar at first, some of the pins do not align with those of the Agon Light, so do not plug an Agon Light peripheral into the io bus of a Console 8. Pins marked * go via a transputer.</p> <p></p>"},{"location":"MOS-API/","title":"What is the MOS API","text":"<p>The MOS API can be used by external applications to access MOS functionality.</p> <p>Please note that this documentation uses assembler in the examples in a format that is compatible with the Zilog ZDS II assembler.  The assembler syntax used in BBC BASIC is similar, but not identical.  Additionally you will need to use the new ADL version of BBC BASIC to use the new eZ80 ADL mode and extended instruction set.</p> <p>This documentation is not intended as a tutorial on eZ80 assembler, but as a reference for those who are already familiar with the eZ80 or Z80 instruction set and wish to use MOS APIs in their programs.</p>"},{"location":"MOS-API/#usage-from-z80-assembler","title":"Usage from Z80 assembler","text":"<p>There are four RST instructions for accessing MOS functionality from Z80.</p> <ul> <li><code>RST 00h</code>: Reset the eZ80</li> <li><code>RST 08h</code>: Execute a MOS command</li> <li><code>RST 10h</code>: Output a single character to the VDP</li> <li><code>RST 18h</code>: Output a stream of characters to the VDP (MOS 1.03 or above)</li> </ul> <p>In addition, if you are using the Zilog ZDS II assembler you may wish to include the file <code>mos_api.inc</code> in your project.  The Console8 version can be found in the folder src of project agon-mos.  The original Quark versions of this file can be found in the folder src of project agon-mos.</p> <p>NB:</p> <ul> <li>Using the <code>RST.LIS</code> opcode in an eZ80 assembler will ensure the MOS RST instructions are called regardless of the eZ80s current addressing mode.</li> <li>In the <code>mos_api.inc</code> file you will find:</li> <li>EQUs for all the MOS commands, data structures and system variables.</li> <li>An incomplete list of VDP control variables.  For a full list, see the VDP documentation</li> <li>A complete list FatFS APIs, however these are not yet all implemented in MOS.  Those that are implemented are documented below.</li> </ul> <p>Further information on the <code>RST</code> handlers provided by MOS are as follows:</p>"},{"location":"MOS-API/#rst-08h-execute-a-mos-command","title":"<code>RST 08h</code>: Execute a MOS command","text":"<p>Parameters:</p> <ul> <li><code>A</code>: MOS command number to execute</li> </ul> <p>NB:</p> <ul> <li>There is a macro in <code>mos_api.inc</code> with EQUs for all the MOS commands</li> <li>Other MOS-command dependant parameters may be required</li> </ul> <p>Macro:</p> <pre><code>;\n; Macro for calling the API\n; Parameters:\n; - `F`unction: One of the function numbers listed above\n;\nMOSCALL:    MACRO   function\n        LD  A, function\n        RST.LIS 08h\n        ENDMACRO    \n</code></pre> <p>Example:</p> <pre><code>; OSRDCH: Read a character in from the ESP32 keyboard handler\n;\nOSRDCH:     MOSCALL mos_getkey\n        OR  A       \n        JR  Z, OSRDCH       ; Loop until key is pressed\n        RET\n</code></pre>"},{"location":"MOS-API/#rst-10h-output-a-single-character-to-the-vdp","title":"<code>RST 10h</code>: Output a single character to the VDP","text":"<p>Parameters:</p> <ul> <li><code>A</code>: Character to output</li> </ul> <p>Example:</p> <pre><code>; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS\n; A: Character to write\n;\nOSWRCH:     RST.LIS 10h         ; This calls a RST in the eZ80 address space\n        RET\n</code></pre>"},{"location":"MOS-API/#rst-18h-output-a-stream-of-characters-to-the-vdp-mos-103-or-above","title":"<code>RST 18h</code>: Output a stream of characters to the VDP (MOS 1.03 or above)","text":"<p>Parameters:</p> <ul> <li><code>HL(U)</code>: Address of the data stream (16-bit for Z80 mode, 24-bit for ADL mode)</li> <li><code>BC</code>: Length of stream (or 0 if the stream is delimited)</li> <li><code>A</code>: Stream delimiter (if <code>BC</code>=0)</li> </ul> <p>Returns: - <code>A</code>: Last character displayed (length mode) OR Delimeter (delimeter mode) - <code>BC</code>: 0 - <code>HL(U)</code>: Address of last character displayed + 1 (length mode) OR location of delimeter (delimeter mode) - <code>E</code>: Value of <code>A</code> upon entry</p> <p>Example:</p> <pre><code>; Write a stream of characters to the VDP\n; HLU: Address of buffer containing data - if in 16-bit segment, U will be replaced by MB\n;  BC: Number of characters to write out, or 0 if the data is delimited\n;   A: End of data delimiter, i.e. 0 for C strings\n;\n        LD  HL, text        ; Address of text\n        LD  BC, 0           ; Set to 0, so length ignored...\n        LD  A, 0            ; Use character in A as delimiter\n        RST.LIS 18h         ; This calls a RST in the eZ80 address space\n        RET\n;\ntext:       DB  \"Hello World\", 0\n</code></pre>"},{"location":"MOS-API/#the-mos-api","title":"The MOS API","text":"<p>MOS API calls can be executed from a classic 64K Z80 segment or whilst the eZ80 is running in 24-bit ADL mode. For classic mode, 16 bit registers are passed as pointers to the MOS commands; these are automatically promoted to 24 bit by adding the MB register to bits 16-23 of the register. When running in ADL mode, a 24-bit register will be passed, but MB must be set to 0.</p> <p>The following MOS commands are supported:</p>"},{"location":"MOS-API/#0x00-mos_getkey","title":"<code>0x00</code>: mos_getkey","text":"<p>Read a keypress from the VDP</p> <p>Parameters: None</p> <p>Returns: - <code>A</code>: The keycode of the character pressed</p>"},{"location":"MOS-API/#0x01-mos_load","title":"<code>0x01</code>: mos_load","text":"<p>Load a file from SD card</p> <p>Parameters:  - <code>HL(U)</code>: Address of filename (zero terminated) - <code>DE(U)</code>: Address at which to load - <code>BC(U)</code>: Maximum allowed size (bytes)</p> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>BC(U)</code></p> <p>Returns: - <code>A</code>: File error, or 0 if OK - <code>F</code>: Carry reset if no room for file, otherwise set</p>"},{"location":"MOS-API/#0x02-mos_save","title":"<code>0x02</code>: mos_save","text":"<p>Save a file to SD card</p> <p>Parameters: </p> <ul> <li><code>HL(U)</code>: Address of filename (zero terminated)</li> <li><code>DE(U)</code>: Address to save from</li> <li><code>BC(U)</code>: Number of bytes to save</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>BC(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: File error, or 0 if OK</li> <li><code>F</code>: Carry set</li> </ul>"},{"location":"MOS-API/#0x03-mos_cd","title":"<code>0x03</code>: mos_cd","text":"<p>Change current directory on the SD card</p> <p>Parameters: </p> <ul> <li><code>HL(U)</code>: Address of path (zero terminated)</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: File error, or 0 if OK</li> </ul>"},{"location":"MOS-API/#0x04-mos_dir","title":"<code>0x04</code>: mos_dir","text":"<p>List SD card folder contents to screen.</p> <p>This is a simple directory listing command that will list the contents of the current directory to the screen.  More advanced directory listing functionality for applications to use is available via the FatFS commands API.</p> <p>Parameters: </p> <ul> <li><code>HL(U)</code>: Address of path (zero terminated)</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: File error, or 0 if OK</li> </ul>"},{"location":"MOS-API/#0x05-mos_del","title":"<code>0x05</code>: mos_del","text":"<p>Delete a file or folder from the SD card</p> <p>Parameters: </p> <ul> <li><code>HL(U)</code>: Address of path (zero terminated)</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: File error, or 0 if OK</li> </ul>"},{"location":"MOS-API/#0x06-mos_ren","title":"<code>0x06</code>: mos_ren","text":"<p>Rename a file on the SD card</p> <p>Parameters: </p> <ul> <li><code>HL(U)</code>: Address of filename1 (zero terminated)</li> <li><code>DE(U)</code>: Address of filename2 (zero terminated)</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: File error, or 0 if OK</li> </ul>"},{"location":"MOS-API/#0x07-mos_mkdir","title":"<code>0x07</code>: mos_mkdir","text":"<p>Make a folder on the SD card</p> <p>Parameters: </p> <ul> <li><code>HL(U)</code>: Address of path (zero terminated)</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: File error, or 0 if OK</li> </ul>"},{"location":"MOS-API/#0x08-mos_sysvars","title":"<code>0x08</code>: mos_sysvars","text":"<p>Fetch a pointer to the system variables</p> <p>Parameters: None</p> <p>Returns:</p> <ul> <li><code>IXU</code>: Pointer to the MOS system variable area (this is always 24 bit)</li> </ul>"},{"location":"MOS-API/#0x09-mos_editline","title":"<code>0x09</code>: mos_editline","text":"<p>Invoke the line editor</p> <p>Parameters: </p> <ul> <li><code>HL(U)</code>: Address of the buffer</li> <li><code>BC(U)</code>: Buffer length</li> <li><code>E</code>: Flags to control editor behaviour</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code></p> <p>Returns: - <code>A</code>: Key that was used to exit the input loop (CR=13, ESC=27)</p> <p>Editor behaviour flags are as follows: | Bit | Description | | --- | ----------- | | 0   | When set, buffer will be cleared before use | | 1   | When set, tab-completion for MOS commands and files is enabled * | | 2   | When set, hotkeys are disabled * | | 3   | When set, input history will be disabled * | | 4-7 | Reserved for future use (for future compatibility, ensure these are set to zero) |</p> <p>* Support for editor control flags was added in Console8 MOS 2.2.0.  Prior to this the only documented values for <code>E</code> were 0 and 1 to indicate whether the buffer should be cleared.</p>"},{"location":"MOS-API/#0x0a-mos_fopen","title":"<code>0x0A</code>: mos_fopen","text":"<p>Get a file handle</p> <p>Parameters: </p> <ul> <li><code>HL(U)</code>: Address of filename (zero terminated)</li> <li><code>C</code>: Mode</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns: - <code>A</code>: Filehandle, or 0 if couldn't open</p> <p>Mode can be one of: fa_read, fa_write, fa_open_existing, fa_create_new, fa_create_always, fa_open_always or fa_open_append</p> <p>NB: If you open the file using mos_fopen, you must close it using mos_fclose, not ffs_api_fclose</p>"},{"location":"MOS-API/#0x0b-mos_fclose","title":"<code>0x0B</code>: mos_fclose","text":"<p>Close a file handle</p> <p>Parameters: </p> <ul> <li><code>C</code>: Filehandle, or 0 to close all open files</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Number of files still open</li> </ul>"},{"location":"MOS-API/#0x0c-mos_fgetc","title":"<code>0x0C</code>: mos_fgetc","text":"<p>Get a character from an open file</p> <p>Parameters: </p> <ul> <li><code>C</code>: Filehandle</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns: - <code>A</code>: Character read - <code>F</code>: C set if last character in file, otherwise NC (MOS 1.04 or greater)</p>"},{"location":"MOS-API/#0x0d-mos_fputc","title":"<code>0x0D</code>: mos_fputc","text":"<p>Write a character to an open file</p> <p>Parameters: </p> <ul> <li><code>C</code>: Filehandle</li> <li><code>B</code>: Character to write</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns: None</p>"},{"location":"MOS-API/#0x0e-mos_feof","title":"<code>0x0E</code>: mos_feof","text":"<p>Check for end of file</p> <p>Parameters: </p> <ul> <li><code>C</code>: Filehandle</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns: - <code>A</code>: 1 if at end of file, otherwise 0</p>"},{"location":"MOS-API/#0x0f-mos_geterror","title":"<code>0x0F</code>: mos_getError","text":"<p>Copy an error string to a buffer</p> <p>Parameters: </p> <ul> <li><code>E</code>: The error code</li> <li><code>HL(U)</code>: Address of buffer to copy message into</li> <li><code>BC(U)</code>: Size of buffer</li> </ul> <p>Preserves: <code>DE(U)</code>, <code>HL(U)</code>, <code>BC(U)</code></p> <p>Returns: None</p>"},{"location":"MOS-API/#0x10-mos_oscli","title":"<code>0x10</code>: mos_oscli","text":"<p>Execute a MOS command</p> <p>Parameters: </p> <ul> <li><code>HL(U)</code>: Pointer the the MOS command string</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: MOS error code</li> </ul> <p>NB previously documentation for this command was incorrect, as it documented additional parameters in <code>DE(U)</code> and <code>BC(U)</code>.  These registers are not currently used.</p>"},{"location":"MOS-API/#0x11-mos_copy","title":"<code>0x11</code>: mos_copy","text":"<p>Copy a file on the SD card</p> <p>Parameters: </p> <ul> <li><code>HL(U)</code>: Address of filename1 (zero terminated)</li> <li><code>DE(U)</code>: Address of filename2 (zero terminated)</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: File error, or 0 if OK</li> </ul> <p>NB: Requires MOS 1.03 or greater</p>"},{"location":"MOS-API/#0x12-mos_getrtc","title":"<code>0x12</code>: mos_getrtc","text":"<p>Get a time string from the RTC (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a buffer to copy the string to (at least 32 bytes)</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Length of time string</li> </ul>"},{"location":"MOS-API/#0x13-mos_setrtc","title":"<code>0x13</code>: mos_setrtc","text":"<p>Set the RTC (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a 6-byte buffer with the time data in</li> </ul> <pre><code>+0: Year (offset from 1980, so 1989 is 9)\n+1: Month (1 to 12)\n+2: Day of Month (1 to 31)\n+3: Hour (0 to 23)\n+4: Minute (0 to 59)\n+5: Second (0 to 59)\n</code></pre> <p>Preserves: <code>HL(U)</code></p> <p>Returns: None</p>"},{"location":"MOS-API/#0x14-mos_setintvector","title":"<code>0x14</code>: mos_setintvector","text":"<p>Set an interrupt vector (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>E</code>: Interrupt vector number to set</li> <li><code>HLU</code>: Address of new interrupt vector (24-bit pointer)</li> </ul> <p>Preserves: <code>HLU</code>, <code>DEU</code></p> <p>Returns:</p> <ul> <li><code>HL(U)</code>: Address of the previous interrupt vector (24-bit pointer)</li> </ul>"},{"location":"MOS-API/#0x15-mos_uopen","title":"<code>0x15</code>: mos_uopen","text":"<p>Open UART1 (Requires MOS 1.03 or above)</p> <p>To handle the received interrupts, you will need to assign a handler to UART1's interrupt vector (0x1A).</p> <p>Parameters:</p> <ul> <li><code>IXU</code>: Pointer to a UART struct</li> </ul> <pre><code>+0: Baud rate (24-bit, little endian)\n+3: Data bits (5, 6, 7 or 8)\n+4: Stop bits (1 or 2)\n+5: Parity bits (0: None, 1: Odd, 3: Even)\n+6: Flow control (0: None, 1: Hardware)\n+7: Enabled interrupts\n    - Bit 0: Set to enable received data interrupt\n    - Bit 1: Set to enable transmit data interrupt\n    - Bit 2: Set to enable line status change interrupt\n    - Bit 3: Set to enable modem status change interrupt\n    - Bit 4: Set to enable transmit complete interrupt\n</code></pre> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Error code (always 0)</li> </ul>"},{"location":"MOS-API/#0x16-mos_uclose","title":"<code>0x16</code>: mos_uclose","text":"<p>Close UART1 (Requires MOS 1.03 or above)</p>"},{"location":"MOS-API/#0x17-mos_ugetc","title":"<code>0x17</code>: mos_ugetc","text":"<p>Read a character from UART1 (Requires MOS 1.03 or above)</p> <p>Returns:</p> <ul> <li><code>A</code>: The character read</li> <li><code>F</code>: C if successful, NC if the UART is closed</li> </ul>"},{"location":"MOS-API/#0x18-mos_uputc","title":"<code>0x18</code>: mos_uputc","text":"<p>Write a character to UART1 (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: The character to write</li> </ul> <p>Returns:</p> <ul> <li><code>F</code>: C if successful, NC if the UART is closed</li> </ul>"},{"location":"MOS-API/#0x19-mos_getfil","title":"<code>0x19</code>: mos_getfil","text":"<p>Get a pointer to a FIL structure in MOS (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: Filehandle</li> </ul> <p>Preserves: <code>BC(U)</code></p> <p>Returns:</p> <ul> <li><code>HLU</code>: 24-bit pointer to a FIL structure (in MOS RAM)</li> </ul>"},{"location":"MOS-API/#0x1a-mos_fread","title":"<code>0x1A</code>: mos_fread","text":"<p>Read a block of data from a file (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: Filehandle</li> <li><code>HLU</code>: Pointer to a buffer to read the data into</li> <li><code>DEU</code>: Number of bytes to read</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p> <p>Returns:</p> <ul> <li><code>DEU</code>: Number of bytes read</li> </ul>"},{"location":"MOS-API/#0x1b-mos_fwrite","title":"<code>0x1B</code>: mos_fwrite","text":"<p>Write a block of data to a file (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: Filehandle</li> <li><code>HLU</code>: Pointer to a buffer that contains the data to write </li> <li><code>DEU</code>: Number of bytes to write out</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p> <p>Returns:</p> <ul> <li><code>DEU</code>: Number of bytes written</li> </ul>"},{"location":"MOS-API/#0x1c-mos_flseek","title":"<code>0x1C</code>: mos_flseek","text":"<p>Move the read/write pointer in a file (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: Filehandle</li> <li><code>HLU</code>: Least significant 3 bytes of the offset from the start of the file</li> <li><code>E</code>: Most significant byte of the offset (set to 0 for files &lt; 16MB)</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: FRESULT</li> </ul>"},{"location":"MOS-API/#0x1d-mos_setkbvector","title":"<code>0x1D</code>: mos_setkbvector","text":"<p>Allows user programs to access VDP keyboard packets without overriding the entire uart0 interrupt handler. The user program registered, will be called during the uart0 interrupt handler, being passed the address of the full VDP keyboard packet. Normal MOS key handling is disabled when a user program is registered.</p> <p>Parameters:</p> <ul> <li><code>C</code>: Address length in HL (0 = 24bit, 1 = 16bit). If 1 then set the top byte of HLU(callback address) to MB (for ADL=0 callers)</li> <li><code>HL(U)</code>: Callback address of user program to register, or 0 to clear any previously registered vector</li> </ul> <p>Returns: Nothing upon registration. The user program can expect the full VDP packet address in DE(24-bit) upon entry.</p> <p>example code that registers a custom handler.</p>"},{"location":"MOS-API/#0x1e-mos_getkbmap","title":"<code>0x1E</code>: mos_getkbmap","text":"<p>Fetch a pointer to the virtual keyboard map (Requires MOS 1.04 RC2 or above)</p> <p>Parameters: None</p> <p>Returns:</p> <ul> <li><code>IXU</code>: Pointer to the keyboard bitmap (this is always 24 bit)</li> </ul>"},{"location":"MOS-API/#0x1f-mos_i2c_open","title":"<code>0x1F</code>: mos_i2c_open","text":"<p>Open the I2C bus as Master (Requires MOS 1.04 RC3 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: Frequency ID (1: 57600, 2: 115200, 3: 230400)</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns: None</p>"},{"location":"MOS-API/#0x20-mos_i2c_close","title":"<code>0x20</code>: mos_i2c_close","text":"<p>Close the I2C bus (Requires MOS 1.04 RC3 or above)</p> <p>Parameters: None</p> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns: None</p>"},{"location":"MOS-API/#0x21-mos_i2c_write","title":"<code>0x21</code>: mos_i2c_write","text":"<p>Write a block of bytes to the I2C bus (Requires MOS 1.04 RC3 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: I2C Address</li> <li><code>B</code>: Number of bytes to write (maximum 32)</li> <li><code>HL(U)</code>: Pointer to a buffer to read the bytes from</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns: - <code>A</code>: Status     - <code>0</code>: OK     - <code>1</code>: No response from I2C slave     - <code>2</code>: Data NACK     - <code>4</code>: Bus arbitration lost     - <code>8</code>: Bus error</p>"},{"location":"MOS-API/#0x22-mos_i2c_read","title":"<code>0x22</code>: mos_i2c_read","text":"<p>Read a block of bytes from the I2C bus (Requires MOS 1.04 RC3 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: I2C Address</li> <li><code>B</code>: Number of bytes to read (maximum 32)</li> <li><code>HL(U)</code>: Pointer to a buffer to write the bytes to</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns: - <code>A</code>: Status     - <code>0</code>: OK     - <code>1</code>: No response from I2C slave     - <code>2</code>: Data NACK     - <code>4</code>: Bus arbitration lost     - <code>8</code>: Bus error</p>"},{"location":"MOS-API/#fatfs-commands","title":"FatFS commands","text":"<p>MOS makes use of FatFS to access the SD card.  Some of FatFS's functionality is exposed via the MOS API.  The exact API calls listed here may be expanded in later versions of MOS.</p> <p>For more information on FatFS data structures and functions, see the FatFS documentation.</p>"},{"location":"MOS-API/#0x80-ffs_fopen","title":"<code>0x80</code>: ffs_fopen","text":"<p>Open a file (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to an empty FIL structure</li> <li><code>DE(U)</code>: Pointer to a C (zero-terminated) filename string</li> <li><code>C</code>: File open mode</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>C</code></p> <p>Returns:</p> <ul> <li><code>A</code>: FRESULT</li> </ul> <p>Example:</p> <pre><code>            LD  HL, fil             ; FIL buffer\n            LD  DE, filename            ; Filename (0 terminated)\n            LD  C, fa_read          ; Mode\n            MOSCALL ffs_fopen           ; Open the file\n            LD  DE, buffer          ; Where to store the read file\n            LD  BC, 256             ; Number of bytes to read\n            MOSCALL ffs_fread           ; Read the data in\n            PUSH    BC              ; Preserve number of bytes read\n            MOSCALL ffs_fclose          ; Close the file\n            POP BC              ; BC: Number of bytes read\n            RET \n\nfilename:       DB  \"example.txt\", 0        ; The file to read\n\nfil:            DS  FIL_SIZE            ; FIL buffer (defined in mos_api.inc)\nbuffer:         DS  256             ; Buffer for storing read data\n</code></pre>"},{"location":"MOS-API/#0x81-ffs_fclose","title":"<code>0x81</code>: ffs_fclose","text":"<p>Close a file (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a FIL structure</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: FRESULT</li> </ul> <p>See ffs_fopen for an example</p>"},{"location":"MOS-API/#0x82-ffs_fread","title":"<code>0x82</code>: ffs_fread","text":"<p>Read from a file (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a FIL structure</li> <li><code>DE(U)</code>: Pointer to a buffer to store the data in</li> <li><code>BC(U)</code>: Number of bytes to read (typically the size of the buffer)</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p> <p>Returns:</p> <ul> <li><code>BC(U)</code>: Number of bytes read</li> <li><code>A</code>: FRESULT</li> </ul> <p>See ffs_fopen for an example</p>"},{"location":"MOS-API/#0x83-ffs_fwrite","title":"<code>0x83</code>: ffs_fwrite","text":"<p>Write to a file (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a FIL structure</li> <li><code>DE(U)</code>: Pointer to a buffer to read the data from</li> <li><code>BC(U)</code>: Number of bytes to write (typically the size of the buffer)</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p> <p>Returns:</p> <ul> <li><code>BC(U)</code>: Number of bytes written</li> <li><code>A</code>: FRESULT</li> </ul> <p>Example:</p> <pre><code>            LD  HL, fil             ; FIL buffer\n            LD  DE, filename            ; Filename (0 terminated)\n            LD  C, fa_write | fa_create_always  ; Mode\n            MOSCALL ffs_fopen           ; Open the file\n            LD  DE, buffer          ; Location of data to write\n            LD  BC, 256             ; Number of bytes to write\n            MOSCALL ffs_write           ; Write the data\n            MOSCALL ffs_fclose          ; Close the file\n            RET \n\nfilename:       DB  \"example.txt\", 0        ; The file to read\n\nfil:            DS  FIL_SIZE            ; FIL buffer (defined in mos_api.inc)\nbuffer:         DS  256             ; Buffer containing data to write out\n</code></pre>"},{"location":"MOS-API/#0x84-ffs_fseek","title":"<code>0x84</code>: ffs_fseek","text":"<p>Move the read/write pointer in a file (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a FIL structure</li> <li><code>DE(U)</code>: Least significant 3 bytes of the offset from the start of the file</li> <li><code>C</code>: Most significant byte of the offset (set to 0 for files &lt; 16MB)</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>BC(U)</code></p>"},{"location":"MOS-API/#0x8e-ffs_feof","title":"<code>0x8E</code>: ffs_feof","text":"<p>Detect end of file (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a FIL structure</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: 1 if at the end of the file, otherwise 0</li> </ul>"},{"location":"MOS-API/#0x91-ffs_dopen","title":"<code>0x91</code>: ffs_dopen","text":"<p>Open a directory (Requires Console8 MOS 2.2.0 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a blank DIR structure</li> <li><code>DE(U)</code>: Pointer to a C (zero-terminated) directory path string</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: FRESULT</li> </ul>"},{"location":"MOS-API/#0x92-ffs_dclose","title":"<code>0x92</code>: ffs_dclose","text":"<p>Close a directory (Requires Console8 MOS 2.2.0 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a DIR structure</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: FRESULT</li> </ul>"},{"location":"MOS-API/#0x93-ffs_dread","title":"<code>0x93</code>: ffs_dread","text":"<p>Read next directory entry into a FILINFO data structure (Requires Console8 MOS 2.2.0 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a DIR structure</li> <li><code>DE(U)</code>: Pointer to a FILINFO structure</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: FRESULT</li> </ul>"},{"location":"MOS-API/#0x96-ffs_stat","title":"<code>0x96</code>: ffs_stat","text":"<p>Get file information (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a FILINFO structure</li> <li><code>DE(U)</code>: Pointer to a C (zero-terminated) filename string</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: FRESULT</li> </ul> <p>Example:</p> <pre><code>            LD  HL, filinfo         ; FILINFO buffer\n            LD  DE, filename            ; Filename (0 terminated)\n            MOSCALL ffs_stat\n            RET\n\nfilename:       DB  \"example.txt\", 0        ; The file to read\n\nfilinfo:        DS  FILINFO_SIZE            ; FILINFO buffer (defined in mos_api.inc)\n</code></pre>"},{"location":"MOS-API/#0x9e-ffs_getcwd","title":"<code>0x9E</code>: ffs_getcwd","text":"<p>Get the current working directory (Requires Console8 MOS 2.2.0 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a buffer to store the directory path in</li> <li><code>BC(U)</code>: Maximum length of the buffer</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: FRESULT</li> </ul>"},{"location":"MOS-API/#system-variables","title":"System Variables","text":"<p>The MOS API command mos_sysvars returns a pointer to the base of the MOS system variables area in IXU - <code>A</code> 24-bit pointer.</p> <p>The following system variables are available in mos_api.inc:</p> <p><pre><code>; System variable indexes for api_sysvars\n; Index into _sysvars in globals.asm\n;\nsysvar_time:        EQU 00h ; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)\nsysvar_vpd_pflags:  EQU 04h ; 1: Flags to indicate completion of VDP commands\nsysvar_keyascii:    EQU 05h ; 1: ASCII keycode, or 0 if no key is pressed\nsysvar_keymods:     EQU 06h ; 1: Keycode modifiers\nsysvar_cursorX:     EQU 07h ; 1: Cursor X position\nsysvar_cursorY:     EQU 08h ; 1: Cursor Y position\nsysvar_scrchar:     EQU 09h ; 1: Character read from screen\nsysvar_scrpixel:    EQU 0Ah ; 3: Pixel data read from screen (R,B,G)\nsysvar_audioChannel:    EQU 0Dh ; 1: Audio channel \nsysvar_audioSuccess:    EQU 0Eh ; 1: Audio channel note queued (0 = no, 1 = yes)\nsysvar_scrWidth:    EQU 0Fh ; 2: Screen width in pixels\nsysvar_scrHeight:   EQU 11h ; 2: Screen height in pixels\nsysvar_scrCols:     EQU 13h ; 1: Screen columns in characters\nsysvar_scrRows:     EQU 14h ; 1: Screen rows in characters\nsysvar_scrColours:  EQU 15h ; 1: Number of colours displayed\nsysvar_scrpixelIndex:   EQU 16h ; 1: Index of pixel data read from screen\nsysvar_vkeycode:    EQU 17h ; 1: Virtual key code from FabGL\nsysvar_vkeydown     EQU 18h ; 1: Virtual key state from FabGL (0=up, 1=down)\nsysvar_vkeycount:   EQU 19h ; 1: Incremented every time a key packet is received\nsysvar_rtc:     EQU 1Ah ; 8: Real time clock data\nsysvar_keydelay:    EQU 22h ; 2: Keyboard repeat delay\nsysvar_keyrate:     EQU 24h ; 2: Keyboard repeat rate\nsysvar_keyled:      EQU 26h ; 1: Keyboard LED status\nsysvar_scrMode:     EQU 27h ; 1: Screen mode (from MOS 1.04)\nsysvar_rtc_enable:  EQU 28h ; 1: RTC enable status (from Console8 MOS 2.0.0)\nsysvar_mouseX:      EQU 29h ; 2: Mouse X position\nsysvar_mouseY:      EQU 2Bh ; 2: Mouse Y position\nsysvar_mouseButtons:    EQU 2Dh ; 1: Mouse left+right+middle buttons (bits 0-2, 0=up, 1=down)\nsysvar_mouseWheel:      EQU 2Eh ; 1: Mouse wheel delta\nsysvar_mouseXDelta:     EQU 2Fh ; 2: Mouse X delta\nsysvar_mouseYDelta:     EQU 31h ; 2: Mouse Y delta\n</code></pre> Example: Reading a virtual keycode in ADL mode (24-bit): <pre><code>        MOSCALL mos_getkey\n        LD  A, (IX + sysvar_vkeycode)   ; Load A with the virtual keycode from FabGL\n</code></pre> Example: Reading a virtual keycode in Z80 mode (16-bit): <pre><code>        MOSCALL mos_getkey\n        LD.LIL  A, (IX + sysvar_vkeycode)   ; Load A with the virtual keycode from FabGL\n</code></pre></p>"},{"location":"MOS/","title":"What is the MOS","text":"<p>The MOS is a command line Machine Operating System, similar to CP/M or DOS, that provides a human interface to the Agon file system.</p> <p>It also provides the MOS API for programmers to use that provides some basic facilities for file I/O and other common operations for BBC BASIC and other third-party applications.</p> <p>This documentation explains the general features of MOS, as well as commands it offers and how to use them.  It covers the Quark 1.04 version of MOS, and the later Console8 MOS versions up to and including 2.2.3.  Versions of MOS prior to Quark 1.04 may be missing some features described below.</p>"},{"location":"MOS/#system-requirements","title":"System Requirements","text":"<p>To get the most out of MOS, you will need the following:</p> <ul> <li>A 32GB or less micro-SD card formatted FAT32</li> </ul> <p>Technically MOS will work without an SD card, but you won't be able to do much with it.</p>"},{"location":"MOS/#using-an-sd-card","title":"Using an SD card","text":"<p>On powering on, your Agon will automatically mount the SD card and look for an <code>autoexec.txt</code> file in the root folder. If it finds one, it will execute the commands in the file.</p> <p>MOS also supports a <code>mos</code> folder to add in some additional commands, and from Console8 MOS 2.2.0 onwards it also supports a <code>bin</code> folder for executables.</p>"},{"location":"MOS/#the-mos-folder","title":"The <code>mos</code> folder","text":"<p>The <code>mos</code> folder is a special folder that must be placed at the top level of your SD card that can be used to extend the functionality of MOS.</p> <p>When you attempt to use a command that is not built into MOS, it will look in the <code>mos</code> folder on the SD card for a file with the same name as the command with a <code>.bin</code> extension. If it finds one, it will execute that file as if it were a built-in command.</p> <p>Commands provided via the <code>mos</code> folder are known as \"moslets\".  These have a special requirement in that they must be built to run from memory address <code>0x0B0000</code> onwards.  The use of this address is intended to allow moslets to run without affecting the main user program space.  The idea being that this will let you use a moslets from within BASIC without having to worry about it overwriting your program.</p>"},{"location":"MOS/#the-bin-folder","title":"The <code>bin</code> folder","text":"<p>From Console8 MOS 2.2.0 onwards, MOS will also support a <code>bin</code> folder at the top level of your SD card.</p> <p>The <code>bin</code> folder can be used to store programs that can be run from MOS.  These differ from moslets in that they are expected to be full standalone programs that will be run and executed at the default memory address of <code>0x040000</code>, and thus will overwrite existing programs.</p> <p>If you have attempted to use a command that was not built into MOS, and was not found in the <code>mos</code> folder, MOS will then look in the <code>bin</code> folder for a file with the same name as the command with a <code>.bin</code> extension. If it finds one, it will load and run that file.</p> <p>NB there is currently no way to control the memory address that a program in the <code>bin</code> folder will be loaded to, so if you have a program that needs to be loaded at a specific address, you will need to use the <code>LOAD</code> command to load it manually.  Additionally there is no way to control the manner in which MOS searches for commands, so if you have a program in the <code>bin</code> folder that you want to run, you will need to ensure that there is no built-in command or moslet with the same name.  These limitations may be changed in the future.</p>"},{"location":"MOS/#the-autoexectxt-file","title":"The <code>autoexec.txt</code> file","text":"<p>If, at boot-up time, MOS detects an <code>autoexec.txt</code> file in the root folder of the SD card, it will read the file in, and execute the MOS commands in the file sequentially from top to bottom.</p> <p>For example, to set keyboard to US, load BBC BASIC from the root folder, change to the test folder, then run BASIC</p> <pre><code>SET KEYBOARD 1\nLOAD bbcbasic.bin\nCD test\nRUN\n</code></pre> <p>The manner in which this file is executed differs slightly between Quark 1.04 and the Console8 releases.  Quark will blindly execute the commands and silently carry on if there is an error, whereas Console8 will stop execution if there is an error in the file, report the error as well as which line the error occurred on.</p> <p>As of Console8 MOS 2.2.0 the autoexec.txt file will run on every boot.  Previous versions of MOS (including Quark 1.04) would only run the autoexec.txt file on a \"hard reset\" (i.e. a power cycle, or press of the reset button) and not on a soft reset (i.e. a <code>CTRL+ALT+DEL</code>).</p>"},{"location":"MOS/#soft-boot","title":"Soft Boot","text":"<p>Presssing <code>CTRL+ALT+DEL</code> will reboot MOS on the eZ80. (<code>CTRL+SHIFT+ESC</code> for MOS 1.02 or earlier)</p> <p>NB:  This assumes that MOS is still talking to the VDP, as it is the VDP that is responsible for detecting the keypresses.  Sometimes a soft reboot key combination will therefore not work, and you may need to instead press the reset button on your Agon.</p>"},{"location":"MOS/#the-mos-command-line-interface","title":"The MOS Command Line Interface","text":"<p>MOS provides a command line interface (CLI) that allows you to interact with the Agon file system and perform some basic control over your Agon computer.</p> <p>The MOS CLI is loosely inspired by the Acorn MOS present in the BBC Micro and later Acorn computer systems like the Archimedes.</p> <p>MOS works alongside the Agon's VDP, using the facilities of the VDP to display text on the screen and accept input from the keyboard.  The VDP provides some useful facilities, such as a \"paged mode\" that will stop the screen from scrolling until you press the <code>SHIFT</code> key to continue, or <code>ESCAPE</code> to exit.  Paged mode can be toggled on and off by pressing <code>CTRL+N</code> and <code>CTRL+O</code> respectively.</p>"},{"location":"MOS/#the-mos-line-editor","title":"The MOS line editor","text":"<p>MOS provides a simple line editor that allows you to edit the current command line before submitting it to the system.  This same line editor is available for third-party applications like BBC BASIC to use.</p> <p>The line editor allows you to move the cursor around the current line of text, insert and delete characters, and submit the line to the system.  Whilst much of the functionality on Agon is inspired by the BBC Micro, the line editor differs - there is no \"copy\" cursor system on the Agon.  This line editor is similar to those that you will find on modern operating systems like MacOS, Linux or Windows.</p> <p>The MOS CLI line editor will also provide some basic command history, keeping track of the last 10 commands the user has entered.  Pressing the <code>UP</code> arrow key when at the beginning of a line will replace the current line with the last entered command.  Similarly pressing the <code>DOWN</code> arrow key at the end of a line will cycle through the command history in the opposite direction.  The <code>HOME</code> and <code>END</code> keys will move the cursor to the start and end of the current line respectively.</p> <p>The Console8 MOS 2.2.0 release also adds support for pressing the <code>PAGE UP</code> and <code>PAGE DOWN</code> keys to quickly step through the command history.</p> <p>Also added to the 2.2.0 release is \"tab completion\".  If you start typing a command and then press the <code>TAB</code> key, MOS will attempt to complete the command for you.  This includes both built-in commands, moslets found in the <code>mos</code> folder, programs found in the current directory, and programs found in the <code>bin</code> folder.</p> <p>There is also support for programmable function keys in the 2.2.0 release.  For more information on that see the HOTKEY command.</p>"},{"location":"MOS/#the-mos-command-prompt","title":"The MOS command prompt","text":"<p>On versions of MOS prior to the 2.2.0 release, the MOS command prompt is a simple <code>*</code> character.  This is the point at which you can enter commands to the system.</p> <p>From the Console8 MOS 2.2.0 release onwards the prompt has been extended to include the current directory.  This is to help you keep track of where you are in the file system.  The prompt will look something like this:</p> <pre><code>/programs *\n</code></pre> <p>(It is intended that future versions of MOS will allow you to customise the prompt to your liking.)</p>"},{"location":"MOS/#mos-commands","title":"MOS Commands","text":"<p>MOS offers a number of commands that allow you to interact with the Agon file system and control your computer.  These commands are entered at the MOS command prompt, and are executed by pressing the <code>RETURN</code> key.  If you are inside BBC BASIC, you can also enter MOS commands by preceding them with an asterisk <code>*</code>.</p> <p>MOS commands are case-insensitive, and can be abbreviated with a dot <code>.</code>.  For example, <code>DELETE myfile</code> and <code>DEL. myfile</code> are equivalent.  When you abbreviate a command, the first matching command is used, so whilst there are several commands that begin with <code>C</code>, <code>C.</code> will execute the <code>CAT</code>.  Commands that accept multiple parameters will expect those parameters to be space-delimited.  Numbers are in decimal, but can be prefixed with an ampersand <code>&amp;</code> for hexadecimal.</p> <p>To aid users coming from other systems, several commands have aliases, for example <code>DELETE</code> and <code>ERASE</code> are equivalent.  The aliases are listed in the command descriptions below.</p> <p>Commands are described below.  Commands parameters are described with angle brackers <code>&lt;param&gt;</code> and optional parameters are indicated with square brackets <code>[&lt;param&gt;]</code> or <code>[-flag]</code>, and alternative parameters are shown either side of a <code>|</code> character.</p> <p>Any command that requires a memory address will expect a 24-bit address value.</p> <p>The commands available in MOS are as follows:</p>"},{"location":"MOS/#dot","title":"<code>.</code> (dot)","text":"<p>Syntax: <code>*. [&lt;path&gt;]</code> (Alias for <code>CAT</code>)</p> <p>This command is an alias for the <code>CAT</code> command.  If a path is provided, it will list the contents of that directory, otherwise it will list the contents of the current directory.</p>"},{"location":"MOS/#cat","title":"<code>CAT</code>","text":"<p>Syntax: <code>*CAT [-l] [&lt;path&gt;]</code> (Aliases include <code>DIR</code> and <code>.</code>)</p> <p>The \"Catalogue\" command, which displays a directory listing of the current directory, or of the directory at the path given.</p> <p>From Console8 MOS 2.2.0 onwards, the <code>-l</code> flag can be used to display the long form of the directory listing, which includes the file size and date/time of last modification, otherwise a shorter form of the directory listing will be displayed.  Versions of MOS prior to 2.2.0 will always display the long form of the directory listing.</p>"},{"location":"MOS/#cd","title":"<code>CD</code>","text":"<p>Syntax: <code>*CD &lt;path&gt;</code></p> <p>Change current directory.</p> <p>The path provided to the <code>CD</code> command uses <code>/</code> as the directory separator, and can be either an absolute path or a relative path.  The root directory is <code>/</code>.  <code>CD ..</code> can be used to move up one directory level.</p>"},{"location":"MOS/#cdir","title":"<code>CDIR</code>","text":"<p>Syntax: <code>*CDIR &lt;path&gt;</code></p> <p>This command is an alias for the <code>CD</code> command.</p> <p>Available from Console8 MOS 2.2.0 onwards.</p>"},{"location":"MOS/#cls","title":"<code>CLS</code>","text":"<p>Syntax: <code>*CLS</code></p> <p>Clear the screen.</p> <p>(This command performs a VDU 12, which is the same as the <code>CLS</code> command in BBC BASIC.)</p>"},{"location":"MOS/#copy","title":"<code>COPY</code>","text":"<p>Syntax: <code>*COPY &lt;source&gt; &lt;destination&gt;</code></p> <p>Create a copy of a file.</p> <p>From Console8 MOS 2.2.0 onwards, the <code>COPY</code> command will also support the use of wildcards in the source file name, such as <code>*.txt</code>, and can support the destination being a directory.</p>"},{"location":"MOS/#cp","title":"<code>CP</code>","text":"<p>Syntax: <code>*CP &lt;source&gt; &lt;destination&gt;</code></p> <p>This command is an alias for the <code>COPY</code> command.</p> <p>Available from Console8 MOS 2.2.0 onwards.</p>"},{"location":"MOS/#credits","title":"<code>CREDITS</code>","text":"<p>Syntax: <code>*CREDITS</code></p> <p>Outputs some credits and version numbers for third-party libraries used in the Agon firmware.</p>"},{"location":"MOS/#delete","title":"<code>DELETE</code>","text":"<p>Syntax: <code>*DELETE &lt;filename&gt;</code> (Aliases include <code>ERASE</code>)</p> <p>Delete a file or folder (must be empty). </p>"},{"location":"MOS/#dir","title":"<code>DIR</code>","text":"<p>Syntax: <code>*DIR [&lt;path&gt;]</code></p> <p>This command is an alias for the <code>CAT</code> command.</p>"},{"location":"MOS/#erase","title":"<code>ERASE</code>","text":"<p>Syntax: <code>*ERASE &lt;filename&gt;</code></p> <p>This command is an alias for the <code>DELETE</code> command.</p>"},{"location":"MOS/#exec","title":"<code>EXEC</code>","text":"<p>Syntax: <code>*EXEC &lt;filename&gt;</code></p> <p>Executes commands from a text file.</p> <p>Commands will be executed one at a time.  If an error occurs processing a command, execution will stop and the error will be reported.</p> <p>(This is essentially how the <code>autoexec.txt</code> file is processed at boot time.)</p> <p>NB: This command is not available in Quark 1.04.</p>"},{"location":"MOS/#help","title":"<code>HELP</code>","text":"<p>Syntax: <code>*HELP [&lt;command&gt; | all]</code></p> <p>Displays help information for a command.  If no command is provided, a list of available commands will be displayed.</p> <p>NB prior to Console8 MOS 2.2.0 the <code>HELP</code> command required a command name to be provided, or the <code>all</code> keyword to display all commands.</p>"},{"location":"MOS/#hotkey","title":"<code>HOTKEY</code>","text":"<p>Syntax: <code>*HOTKEY [&lt;n&gt; [&lt;command string&gt;]]</code></p> <p>Sets or clears programmable function keys.</p> <p>Using this command you can set the function keys <code>F1-F12</code> on your to perform a specific command.  There are three ways in which this command works: 1. If no parameters are provided, then the current hotkeys will be displayed. 2. If a function key number <code>n</code> is provided alone without a command string, then the current command assigned to that function key will be cleared. 3. If a function key number <code>n</code> and a command string are provided, then the command string will be assigned to that function key.     - If the command string includes <code>%s</code> then the current input line will be substituted in place of <code>%s</code>.</p>"},{"location":"MOS/#jmp","title":"<code>JMP</code>","text":"<p>Syntax: <code>*JMP &lt;address&gt;</code></p> <p>Jumps to the specified address in memory.  Using this command, you can jump to any address in memory, including the ROM.  If used from the MOS command line, the processor will be in the eZ80 ADL mode.</p>"},{"location":"MOS/#load","title":"<code>LOAD</code>","text":"<p>Syntax: <code>*LOAD &lt;filename&gt; [&lt;address&gt;]</code></p> <p>Load a file from the SD card into the specified address in memory.  If no address parameters is specified, then the address will default to <code>&amp;40000</code>.</p>"},{"location":"MOS/#mkdir","title":"<code>MKDIR</code>","text":"<p>Syntax: <code>*MKDIR &lt;name&gt;</code></p> <p>Make a new directory on the SD card.</p>"},{"location":"MOS/#mount","title":"<code>MOUNT</code>","text":"<p>Syntax: <code>*MOUNT</code></p> <p>Mount the SD card.</p> <p>If you have ejected your SD card, you can use this command to re-mount it.</p>"},{"location":"MOS/#move","title":"<code>MOVE</code>","text":"<p>Syntax: <code>*MOVE &lt;source&gt; &lt;destination&gt;</code></p> <p>This command is an alias for the <code>RENAME</code> command.</p>"},{"location":"MOS/#mv","title":"<code>MV</code>","text":"<p>Syntax: <code>*MV &lt;source&gt; &lt;destination&gt;</code></p> <p>This command is an alias for the <code>RENAME</code> command, and is only available from Console8 MOS 2.2.0 onwards.</p>"},{"location":"MOS/#rename","title":"<code>RENAME</code>","text":"<p>Syntax: <code>*RENAME &lt;source&gt; &lt;destination&gt;</code> (Aliases include <code>MOVE</code>)</p> <p>This is the command to rename a file or move a file to a different folder.</p> <p>To rename a file in the same folder.</p> <p><code>*RENAME autoexec.txt autoexec.bak</code></p> <p>Rename a file and move to a different folder (the destination folder must exist).</p> <p><code>*RENAME test.bas archive/test.bas</code></p> <p>From Console8 MOS 2.2.0 onwards, the <code>RENAME</code> command also supports allowing the destination to specify a directory.  If the destination is a directory, the source file will be moved to that directory and keep the same filename.  Additionally if the destination is a directory then the source file specified can include a wildcard, such as <code>*.txt</code>.</p>"},{"location":"MOS/#rm","title":"<code>RM</code>","text":"<p>Syntax: <code>*RM &lt;filename&gt;</code></p> <p>This command is an alias for the <code>DELETE</code> command, and is only available from Console8 MOS 2.2.0 onwards.</p>"},{"location":"MOS/#run","title":"<code>RUN</code>","text":"<p>Syntax: <code>*RUN &lt;address | .&gt; [&lt;parameters&gt;]</code></p> <p>Call an executable binary loaded in memory. If no parameters are passed, then the address will default to <code>&amp;40000</code>.  The address parameter can also be replaced with <code>.</code> to indicate that the default address of <code>&amp;40000</code> should be used.  Any additional parameters will be passed through to the executable.</p> <p>When using the <code>RUN</code> command MOS will check the header of the executable to determine which mode it is in, and will run the executable in the appropriate mode.  This allows you to run both Z80 mode executables, which are restricted to 64kb of RAM, and ADL mode executables which can use all 512kb of memory.  The header starts at byte 64 of the executable, which must contain <code>MOS</code>.  Byte 68 must be a <code>0</code> byte to indicate Z80 mode, or a <code>1</code> byte to indicate ADL mode.</p> <p>When a program is executed using the <code>RUN</code> command, MOS will set up the following processor registers:</p> <ul> <li><code>A</code> will be set to the current memory bank value <code>MB</code></li> <li><code>DE(U)</code> the execution address passed to <code>RUN</code></li> <li><code>HL(U)</code> pointer to additional parameters passed to <code>RUN</code></li> </ul>"},{"location":"MOS/#save","title":"<code>SAVE</code>","text":"<p>Syntax: <code>*SAVE &lt;filename&gt; &lt;address&gt; &lt;size&gt;</code></p> <p>Save a block of memory to the SD card.</p>"},{"location":"MOS/#set","title":"<code>SET</code>","text":"<p>Syntax: <code>*SET &lt;option&gt; &lt;value&gt;</code></p> <p>Set a system option.</p> <p>NB before Console8 MOS 2.2.0 the <code>SET</code> command was case-sensitive for the option name.</p>"},{"location":"MOS/#keyboard-layout","title":"Keyboard Layout","text":"<p>Syntax: <code>*SET KEYBOARD &lt;n&gt;</code></p> <p>Sets the current system keyboard layout.</p> <ul> <li>0: UK (default)</li> <li>1: US</li> <li>2: German</li> <li>3: Italian</li> <li>4: Spanish</li> <li>5: French</li> <li>6: Belgian</li> <li>7: Norwegian</li> <li>8: Japanese</li> <li>9: US International *</li> <li>10: US International (alternative) *</li> <li>11: Swiss (German) *</li> <li>12: Swiss (French) *</li> <li>13: Danish *</li> <li>14: Swedish *</li> <li>15: Portuguese *</li> <li>16: Brazilian Portugese *</li> <li>17: Dvorak *</li> </ul> <p>* These layouts are only supported from Console8 MOS 2.2.0 onwards.  The exact keyboard layouts supported will depend on the version of the VDP firmware you have installed.  Prior to Console8 MOS 2.2.0 keyboard values of 9 or above would be ignored.  From Console8 MOS 2.2.0 onwards any keyboard value can be specified - if the keyboard layout is not supported by the VDP firmware then it will be ignored.</p>"},{"location":"MOS/#console-mode","title":"Console Mode","text":"<p>Syntax: <code>*SET CONSOLE &lt;n&gt;</code></p> <p>Sets the console mode, where if <code>n</code> is <code>0</code> then console mode will be disabled, and if <code>n</code> is <code>1</code> then console mode will be enabled.</p> <p>When console mode is enabled, all (initial) \"command\" and text bytes sent to the VDP will be echoed out of the VDP to any attached USB serial device.  This can be useful for debugging purposes.</p> <p>It is recommended that instead of using this command, if you are running Console8 VDP 2.5.0 or later, you should use <code>VDU 2</code> instead to enable the \"printer\", which also outputs from the VDP to the same serial device.  The main difference is that the \"printer\" device will filter out any control codes, providing a safer output, whereas the console mode will output everything.  The printer can be disabled with <code>VDU 3</code>.  Additionally pressing <code>CTRL+B</code> on the keyboard will enable the printer, <code>CTRL+C</code> will disable it, and <code>CTRL+P</code> will toggle it.</p>"},{"location":"MOS/#time","title":"<code>TIME</code>","text":"<p>Syntax: - <code>*TIME</code> - <code>*TIME &lt;yyyy&gt; &lt;mm&gt; &lt;dd&gt; &lt;hh&gt; &lt;mm&gt; &lt;ss&gt;</code></p> <p>Set and read the ESP32 real-time clock</p>"},{"location":"MOS/#type","title":"<code>TYPE</code>","text":"<p>Syntax: <code>*TYPE &lt;filename&gt;</code></p> <p>Display the contents of a text file on the screen.</p>"},{"location":"MOS/#vdu","title":"<code>VDU</code>","text":"<p>Syntax: <code>*VDU &lt;char1&gt; &lt;char2&gt; ... &lt;charN&gt;</code></p> <p>Write a stream of character bytes to the VDP.  This can be used to perform various control functions, such as clearing the screen, changing the screen mode, setting the cursor position, or changing the text colour.  More information on VDU commands can be found in the VDP documentation.</p> <p>This command is similar to the <code>VDU</code> command in BBC BASIC, but instead of separating arguments with commas you must instead separate them with spaces.</p> <p>Prior to Console8 MOS 2.2.0, the <code>VDU</code> command would only accept 8-bit numbers as arguments.  Any values provided greater than 255 would be ignored.</p> <p>From Console8 MOS 2.2.0 onwards this command will now also support 16-bit numbers as arguments, and several different ways to indicate hexidecimal numbers.  The BBC BASIC standard of suffixing a number with a semicolon character <code>;</code> to indicate a 16-bit number is supported.  As well as the <code>&amp;</code> prefix for hexidecimal numbers, you can also use <code>0x</code> as a prefix, or <code>h</code> as a suffix.  Hexidecimal numbers provided greater than 255 will always be treated as 16-bit numbers.</p>"},{"location":"MOS/#memory-map","title":"Memory map","text":"<p>Addresses are 24-bit, unless otherwise specified</p> <ul> <li><code>&amp;000000 - &amp;01FFFF</code>: MOS (Flash ROM)</li> <li><code>&amp;040000 - &amp;0BDFFF</code>: User RAM</li> <li><code>&amp;0B0000 - &amp;0B7FFF</code>: Storage for loading MOS star command executables off SD card </li> <li><code>&amp;0BC000 - 0BFFFFF</code>: Global heap and stack</li> </ul>"},{"location":"Projects/","title":"Projects","text":"<p>In the Agon Projects Git, there are a handful of useful templates and projects.</p>"},{"location":"Projects/#the-templates","title":"The Templates","text":"<p>There are three template projects that can be used as a basis for your projects:</p> <ul> <li>A 16-bit mode Hello World app in assembler that demonstrates calling the MOS from a 64K segment in Z80 mode</li> <li>A 24-bit mode Hello World app in assembler</li> <li>A 24-bit mode Hello World app in C</li> </ul> <p>All three apps act as MOS extensions; the resultant binary can be copied into the <code>mos</code> folder on the SD card, can be executed as a star command, and will display any passed parameters.</p>"},{"location":"Projects/#the-applications","title":"The Applications","text":"<ul> <li>A memory dump application written as a 16-bit mode assembly language app.</li> <li>An eZ80 disassembler written as a C application.</li> </ul> <p>Both can be run as star commands from MOS.</p>"},{"location":"Theory-of-operation/","title":"Understanding the Agon Light computer platform","text":"<p>The Agon Light, and its variants, is a retro-style computer platform that is designed to be inexpensive and easy to manufacture, using commonly available parts.</p> <p>The platform is designed to be easy to understand, and easy to program.  It is designed to be a platform that is suitable for learning about computers, and learning about programming.</p> <p>Please note this is a preliminary guide to the Agon Light platform, and is subject to change.  The Agon Light platform is still under development, and this guide is still being written.</p>"},{"location":"Theory-of-operation/#the-agon-light-hardware","title":"The Agon Light hardware","text":""},{"location":"Theory-of-operation/#the-main-processor","title":"The main processor","text":"<p>The primary processor on which you run programs is an eZ80.  This is a microcontroller based on the Zilog Z80 processor, which was used in many computers and arcade machines in the 1970s and 1980s.  The eZ80 is a modern version of the Z80, with a few enhancements.  It has attached to it 512KB of RAM, which is considerably more than the 64KB that was common in the 1980s.  Also attached to the eZ80 chip is an SD card interface, allowing an SD card to be used for storage.</p> <p>The eZ80 was chosen as the main processor of the Agon Light because of its historic ubiquity, and because it is still manufactured today.  It is a relatively simple processor, and is easy to understand and program.</p>"},{"location":"Theory-of-operation/#the-video-display-processor-or-vdp","title":"The video display processor, or VDP","text":"<p>Whilst the eZ80 is manufactured today, none of the video chips that were used in computers of the 1970s and 1980s are still manufactured, so for video output a different solution is needed.  To solve this problem the Agon Light uses a separate video processor, which we call the VDP, the Video Display Processor.  This chip is responsible for sound and video output, and also keyboard and mouse input.  Technically, this is an ESP32-Pico-D4 chip, which has attached to it an 8MB RAM chip which is used for screen memory and storing bitmaps and sound samples.</p> <p>The exact technical details of the VDP however for most programmers is not important - in the Agon platform, from a software perspective, the VDP is designed to be used via a simple API, with the details of how it works abstracted away.  Indeed, when using an emulator of the Agon Light, the VDP chip is not emulated at all, and the emulator instead runs a compiled version of the VDP firmware using the host computer's video and audio hardware.</p> <p>Effectively, the design of the Agon Light is that of two computers in one.  The eZ80 is the computer that is used to run programs, and the VDP is a computer that draws the screen and plays sound.  The eZ80 and the VDP communicate with each other using a high speed serial interface.</p> <p>Some other retro-inspired computers take a different approach to solving the video output problem.  Often this involves making use of an FPGA chip, which is a chip that can be programmed to behave like any other chip.  This is a very flexible solution, but it is also very expensive.  The Agon Light takes a different approach, using a separate video processor chip, which is much cheaper than an FPGA.</p> <p>The use of what is effectively a separate computer for the VDP in the Agon platform creates a significant architectural difference to many classic home computers of the 8-bit, 16-bit and early 32-bit era.  Those classic computers would usually use a shared area of memory that the main processor and the video processor would both have access to.  This shared memory would be used to store the screen memory, and the main processor would write to this memory to update the screen.  This is not the case with the Agon platform.  The eZ80 and the VDP have no shared memory, and the VDP has no access to the eZ80's RAM.  This means that the VDP cannot read the screen memory directly, and the eZ80 cannot write directly to the screen memory.  Instead, the VDP has to be sent commands to draw things to the screen, and the eZ80 has to be sent commands to read things from the screen.  This is a significant difference to many classic computers, and is something that programmers need to be aware of when writing programs for the Agon platform.</p>"},{"location":"Theory-of-operation/#the-agon-software-platform","title":"The Agon software platform","text":"<p>From a software perspective, a significant inspiration for the Agon Light was the BBC Micro, a popular computer in the UK from the 1980s designed and built by Acorn Computers Ltd..  (Acorn went on to design the ARM processor, which is now the most commonly used processor design in the world.)  The BBC Micro was part of the BBC's Computer Literacy Project, which was a project to introduce computers to the UK population with an emphasis on education.  The BBC Micro was designed to be easy to use, and to be used in schools by children.</p> <p>There are several significant differences between the Agon Light and the BBC Micro, but the two most important ones are the main processor, and the video system.  A BBC Micro was based on the 6502 CPU, which was a competitor to the Z80.  The 6502 was a simpler processor than the Z80, and was cheaper to manufacture, and given the relative simplicity often significantly faster than the Z80.  The 6502 was used in many popular computers of the 1970s and 1980s, including the Apple II, the Commodore 64, and the Atari 2600.  The Z80 was used in many other popular computers of the 1970s and 1980s, including the Sinclair ZX80, the Sinclair ZX81, the Sinclair Spectrum, the Amstrad CPC, and the MSX.  The BBC Micro however was designed from the ground up to be a computer capable of having multiple processors, and the first second processor option available for the computer was the Z80.  A version of BBC BASIC was produced for Acorn's Z80 second processor, and this is the version of BBC BASIC that the Agon Light is directly based on.</p>"},{"location":"Theory-of-operation/#bbc-basic","title":"BBC BASIC","text":"<p>An important part of the BBC Micro was BBC BASIC, a well respected version of the BASIC programming language.  Compared to other versions of BASIC, BBC BASIC was very powerful since it included many advanced features, such as procedures, functions, and recursion.  It also included many commands for graphics and sound, which made it easy to write games and other programs that used graphics and sound.</p> <p>The original version of BBC BASIC for the 6502 processor was written by Sophie Wilson of Acorn.  The version of BBC BASIC for the Z80 was written by R.T.Russell, and was based on the original version by Sophie Wilson.  The version of BBC BASIC for the Agon Light is directly based on R.T.Russell's version, and is largely compatible with the BBC Micro version.</p> <p>BBC BASIC has an inbuilt assembler, which allows for machine code to be embedded within BASIC programs.  This is a very powerful feature, and allows for programs to be written that make use of the full power of the processor.  Machine code can run very many times faster than interpreted BASIC.  It should be noted that the Z80 version of BASIC as used on the Agon platform has an assembler for the Z80 built in, whereas the original 6502 version of BASIC for the BBC Micro included an assembler for the 6502 processor.  Programs written for the BBC Micro that include assembler code will therefore not run on the Agon Light without rewriting those assembler routines.</p>"},{"location":"Theory-of-operation/#bbc-basic-adl-version","title":"BBC BASIC ADL version","text":"<p>There is now a newer version of BBC BASIC for the Agon platform known as the \"ADL version\".  The original Z80 version of BBC BASIC was restricted to work within 64KB of RAM.  This limitation was due to the fact that the Z80 processor only has 16 address lines (also referred to as a 16-bit address bus), so technically it can only address 64KB of RAM.</p> <p>The newer eZ80 CPU used in the Agon Light has a 24-bit address bus, which means that it can potentially address up to 16MB of RAM.  Agon Light machines come with 512KB of RAM attached to the eZ80 CPU.</p> <p>To allow programs to make use of this extra RAM, and some other new facilities, the eZ80 has extensions known as \"ADL mode\".  This mode extends some processor registers to 24 bits, and allows for the use of the extra RAM.  The ADL version of BBC BASIC is designed to make use of this extra RAM, and to allow for programs to be written that make use of more than 64KB of RAM.</p> <p>The ADL version of BBC BASIC also includes modifications to the assembler to allow for the use of newer ADL machine code instructions.  This means that programs written for the ADL version of BBC BASIC may not run on the original Z80 version of BBC BASIC.</p>"},{"location":"Theory-of-operation/#vdu-commands-and-the-vdp","title":"VDU commands, and the VDP","text":"<p>The other significant difference between the Agon Light and the BBC Micro is the video system.  As video output is handled by a separate processor, and there is no shared memory between the two processors within an Agon Light, the design of the Agon system does not allow for the video system to work in the same kind of manner as a BBC Micro.  From a software perspective, however, the Agon Light is designed to be as similar as possible to the BBC Micro, and the video system is designed to be as similar as possible to the BBC Micro video system.  This means that many programs written for the BBC Micro can be ported to the Agon Light with minimal changes.</p> <p>Using BASIC on a BBC Micro, the primary way to draw things to the screen was via simple keywords such as <code>PRINT</code>, <code>MOVE</code>, <code>DRAW</code>, <code>PLOT</code>, <code>COLOUR</code> (etc.) and most importantly <code>VDU</code>.  It is the <code>VDU</code> keyword that sent commands to the video system.  Effectively all of the other keywords that drew onto the screen (or changed drawing settings) are just shorthand for <code>VDU</code> commands.</p> <p>The same is true on the Agon Light.  The Agon's VDP processor has been written to understand the same <code>VDU</code> commands as the BBC Micro, and so the same keywords that draw things to the screen on a BBC Micro will also draw things to the screen on an Agon Light.  This means that many programs written in BBC BASIC for the BBC Micro can be ported to the Agon Light with minimal changes.</p> <p>The Agon Light also includes a number of additional <code>VDU</code> commands that are not present on the BBC Micro, which allow for more advanced graphics and sound effects.  These commands are documented in the VDP section of this documentation.</p> <p>The nature of the MOS/VDP split on the Agon platform carries with it some limitations that you should be aware of.</p> <p>The nature of the VDP is that it is, essentially, a stream processor.  It accepts a stream of data from the eZ80, and interprets that as a stream of commands and data.  In regular use, there is no command to indicate the beginning of a command stream, and no command to indicate the end of a command stream.  The VDU commands that the VDP interprets are of a variable length, ranging from a single byte to potentially over 64kb.  A single <code>VDU</code> statement in BASIC could be a complete command from the perspective of the VDP, or it could be the first part of a command that is continued in the next <code>VDU</code> statement.  For commands that are intended to send across a large amount of data, such as a bitmap or a sound sample, the data is typically sent using a series of <code>VDU</code> statements, each of which is a part of the same command.</p> <p>Care must therefore be taken to ensure that the VDP is sent complete commands, and that commands are not interleaved.  For instance, it may be tempting when transfering over a sound sample to use <code>PRINT</code> or <code>DRAW</code> statements to show progress.  This will not work, because the VDP will interpret the <code>PRINT</code> or <code>DRAW</code> statements (which will have been translated into a raw VDU byte command stream) as part of the sound sample data.</p> <p>To solve this issue, the VDP provides a Buffered Commands API.  This allows for data to be sent to the VDP in discrete chunks, sent to one of over 65000 buffers.  Once all of the data has been sent, a command can be sent to the VDP to make use of the data in the buffer, whether that is to use the buffer as a sound sample, a bitmap, or a sequence of VDU commands.  So to print a progress bar whilst sending a sound sample, you would send the sound sample data to a buffer a chunk at a time using the Buffered Commands API \"add block\" command, and after each chunk use drawing commands to update the progress bar.  Once all of the sound sample data has been sent, you would then send a command to the VDP to identify that data as a sound sample, and/or use other commands to play that sample.</p>"},{"location":"Third-Party-Projects/","title":"Third Party Projects","text":"<p>Please note that this list is far from exhaustive. If you have a project that you would like to add to this list, please submit a pull request.</p>"},{"location":"Third-Party-Projects/#popup-mos","title":"Popup MOS","text":"<p>https://github.com/tomm/popup-mos</p> <p>A batteries-included SDCard template for Agon Light / Agon Light 2 / Console8</p>"},{"location":"Third-Party-Projects/#flash-upgrader","title":"Flash Upgrader","text":"<p>https://github.com/envenomator/agon-flash</p> <p>A utility to flash a MOS image to the eZ80F92 Flash without a ZDS USB cable, and to update the VDP firmware.</p>"},{"location":"Third-Party-Projects/#hex-loader","title":"Hex Loader","text":"<p>[https://github.com/envenomator/agon-hexload](https://github.com/envenomator/agon-hexload</p> <p>Playing microSD jockey during assemble/compile/transfer/test/debug cycles is no fun at all. This utility shortens this cycle significantly by removing the need to physically bring over new binaries to the Agon.</p> <p>With the hexload command you are able to transmit Intel I32 hex files to one of the Agon serial ports and run your code immediately from memory.</p>"},{"location":"Third-Party-Projects/#ez80-assembler","title":"eZ80 Assembler","text":"<p>https://github.com/envenomator/agon-ez80asm</p> <p>A fully-featured eZ80 assembler that runs on the Agon.</p>"},{"location":"Third-Party-Projects/#forth-interpreter","title":"Forth Interpreter","text":"<p>https://github.com/lennart-benschop/agon-forth</p>"},{"location":"Third-Party-Projects/#agon-utilities","title":"Agon Utilities","text":"<p>https://github.com/lennart-benschop/agon-utilities</p> <p>A selection of handy utilities including copy, compare, more, memfill, font, and a full-screen editor with nano-style key bindings.</p>"},{"location":"Third-Party-Projects/#sokoban","title":"Sokoban","text":"<p>https://github.com/envenomator/agon-sokoban</p> <p>Sokoban game for AGON</p>"},{"location":"Updating-Firmware-from103/","title":"Detailed firmware upgrade steps from 1.03 to Quark 1.04 or Console8 firmware","text":"<p>This guide lists all the required steps to upgrade an Agon, which has been delivered to you with older MOS/VDP version 1.03, to a later version. Please follow each step as closely as possible and make sure that each item on the preparation list is completed before attempting the first upgrade steps.</p>"},{"location":"Updating-Firmware-from103/#preparation","title":"Preparation","text":"<ol> <li>Connect your Agon to a VGA monitor and PS/2 capable keyboard. You need to interact with it using the keyboard and monitor in the first update step</li> <li>If you haven't done so already, prepare a micro SD card by formatting it with the FAT32 format and place the contents of a distribution 1 or 2 on it. If you already had a working SD card with stuff on it, just continue using it; then there is no need to format it or anything</li> <li>Connect your Agon to a PC using a USB data cable. The type of USB cable may differ according to the Agon platform you're using: <ul> <li>the Olimex AgonLight2 has a USB-C type connector</li> <li>the Agon Console8 has a USB-B type connector</li> <li>the Agon Origins edition has a USB-B type connector</li> <li>the original AgonLight(1) has a USB-A type connector</li> </ul> </li> <li>Find out which serial/COM port shows up on your PC, after connecting your Agon using a USB cable and note it down for later use:<ul> <li>Under Windows, it shows up in the 'Device Manager', or you can type '[System.IO.Ports.SerialPort]::getportnames()' in a PowerShell terminal</li> <li>Under Linux, you can find it by running 'dmesg | grep tty' in a shell</li> <li>Under MacOS, you can find it by running 'ls /dev/tty.*' in Terminal</li> </ul> </li> <li> <p>For the Olimex AgonLight2 - please make sure the jumpers on the board are placed like this: the LEFT jumper is unconnected/open/placed on just one pin, the RIGHT jumper is connected/closed/placed on both pins</p> <p></p> </li> <li> <p>If it doesn't exist yet, create a folder named 'mos' on the SD card </p> </li> <li>Download the file flash.bin and place it IN THE 'mos' FOLDER of your SD card</li> <li>Download one of the following options and place 'MOS.bin' in IN THE ROOT of your SD card:<ul> <li>If you'd like to upgrade to the latest and greatest Console8 release, please download MOS.bin</li> <li>If you'd like to upgrade to the latest official Quark 1.04 release, please download MOS.bin</li> </ul> </li> <li>Eject the SD card from your PC, insert it into your Agon</li> <li>RESET your Agon</li> <li>Download agon binaries to your PC and unzip it. I'll refer the unzipped folder later as 'agon-binaries'</li> <li>If you are using Linux/MacOS, please install python and install the python esptool.py using this guide from espressif</li> </ol>"},{"location":"Updating-Firmware-from103/#upgrade-the-agon-mos","title":"Upgrade the Agon MOS","text":"<ol> <li>Complete all the steps from the preparation requirements</li> <li>Make sure to reset your Agon, so it shows the Agon's VDP/MOS versions</li> <li>Make sure to exit BBC Basic, if that autostarted, by typing '*BYE' and ENTER. If your prompt is a '*', you are on a MOS prompt already</li> <li>Type 'flash mos' and ENTER</li> <li>If the flash tool starts, calculates the CRC from the MOS.bin file and asks you to 'Flash firmware (y/n)', press 'y'. If it doesn't ask, check your preparations and make sure the flash.bin is installed under /mos and MOS.bin is in the root of the SD card</li> <li>Agon MOS upgrade is done - continue to upgrade the Agon VDP</li> </ol>"},{"location":"Updating-Firmware-from103/#upgrade-the-agon-vdp","title":"Upgrade the Agon VDP","text":"<ol> <li>Complete all the steps from the preparation requirements</li> <li>Upgrade the Agon MOS first</li> <li>On windows start a PowerShell terminal, on Linux start a shell and on MacOS start Terminal</li> <li>Change folder to the folder 'agon-binaries', where you unzipped the downloaded binaries earlier, using the 'cd' command</li> <li> <p>Change to the subfolder of the VDP release you'd like to upgrade to:</p> <ul> <li>For a very recent Console8 release: On Windows, change to the subfolder '.\\firmware\\Console8 2.6.0\\' On Linux/MacOS, change to the subfolder ./firmware/Console8\\ 2.6.0/</li> <li>For the official Quark 1.04 release: On Windows, change to the subfolder '.\\firmware\\Quark 1.04\\' On Linux/MacOS, change to the subfolder ./firmware/Quark\\ 1.04/</li> </ul> </li> <li> <p>Start the upgrade script with the serial/COM port you noted earlier - COMXX and /dev/ttyUSBXXX are examples here:</p> <ul> <li>On Windows type - '.\\flash.bat COMXX'</li> <li>On Linux/MacOS, run these commands in sequence:<ul> <li>sed -i -e 's/\\r$//' flash.sh</li> <li>chmod +x flash.sh</li> <li>./flash.sh /dev/ttyUSBXXX</li> </ul> </li> </ul> </li> <li>When the esptool is done uploading and it says 'Hard resetting via RTS pin', please press the physical reset button on your Agon</li> </ol> <p>Done</p>"},{"location":"Updating-Firmware/","title":"Updating Firmware (prio v1.03)","text":""},{"location":"Updating-Firmware/#how-to-upgrade-from-quark-102-to-103-using-the-agon-flash-utility","title":"How to upgrade from Quark 1.02 to 1.03 using the Agon-Flash utility","text":"<p>NB this document is very outdated and needs to be rewritten.  If you have found your way here, please be aware that the instructions below are no longer correct, or the best way to udpate your Agon machine.</p> <p>Instructions kindly collated by Tim Delmare</p>"},{"location":"Updating-Firmware/#disclaimer","title":"Disclaimer","text":"<p>The responsibility for any issues during and/or after the firmware upgrade lies with the user</p>"},{"location":"Updating-Firmware/#host-pcs-and-os","title":"Host PCs and OS","text":"<p>This has been tested on:</p> <ul> <li>Windows 10</li> <li>Windows 11</li> <li>Ubuntu 20.04 LTS</li> <li>Ubuntu 22.04 LTS</li> </ul> <p>There are reported compatibility issues with the Arduino IDE / ESPTools running on MacOS, especially with the M series CPUs. I have collated some of the workarounds in the 'Configuring the Arduino IDE' steps.</p>"},{"location":"Updating-Firmware/#prerequisites","title":"Prerequisites","text":""},{"location":"Updating-Firmware/#you-will-need","title":"You will need","text":"<ul> <li>A USB cable (the one you are using to power the Agon is probably fine, as long as it supports data as well as power, which most do)</li> <li>A microSD card (the one you are using in the Agon)</li> <li>A microSD card adapter for your PC</li> </ul>"},{"location":"Updating-Firmware/#download-the-following-components-to-your-pc","title":"Download the following components to your PC","text":"<ul> <li>MOS 1.03 binary</li> <li>VDP 1.03 source code</li> <li>BBC BASIC 1.04 binary</li> <li>Agon MOS Flash Upgrader</li> </ul>"},{"location":"Updating-Firmware/#configure-the-arduino-ide","title":"Configure the Arduino IDE","text":"<p>If you have already configured the Arduino IDE for Agon then you can skip this step, otherwise follow the instructions here: Arduino IDE Settings</p>"},{"location":"Updating-Firmware/#update-steps","title":"Update Steps","text":"<p>If you do not have the Zilog cable then the order in which you do things is especially important. Update the MOS first. If you update the VDP first, you will not be able to update MOS using the Agon MOS Flash Upgrader due to changes in the MOS.</p>"},{"location":"Updating-Firmware/#1-update-the-mos","title":"1. Update the MOS","text":"<ol> <li>Mount the microSD card in your PC and create a directory call <code>mos</code> in the root directory if one does not already exist. Copy flash.bin to this directory</li> <li>Copy MOS.bin to the root directory</li> <li>Unmount the microSD card and insert it in your Agon</li> <li>Power the Agon on</li> <li>Type <code>*BYE</code> to quit BBC BASIC</li> <li>Type <code>CD /</code> to return to root directory (you can also use backslash)</li> <li>Type <code>FLASH MOS.bin 0x81E397C9</code></li> <li>Power off</li> </ol> <p>Once this has succeeded the Agon will not work properly until you upgrade VDP.</p>"},{"location":"Updating-Firmware/#2-update-bbc-basic","title":"2. Update BBC BASIC","text":"<ol> <li>Power the Agon off</li> <li>Remove the SD card and return to your PC</li> <li>Copy bbcbasic.bin to the root directory, overwriting any existing file</li> <li>Copy the following folders to the root directory to update the examples (optional, but recommended)</li> <li>examples</li> <li>resources</li> <li>tests</li> <li>Eject the SD card and return it to the Agon</li> </ol>"},{"location":"Updating-Firmware/#3-update-the-vdp","title":"3. Update the VDP","text":"<ol> <li>Create a folder called video and unzip the VDP source code inside this new folder</li> <li>Open video.ino in the Arduino IDE</li> <li>Connect the Agon to the computer using your USB cable</li> <li>Identify the port and set it in the Arduino IDE</li> <li>Now select Upload from the Sketch menu</li> </ol> <p>Note that compilation may take several minutes. Once this is complete, and the Arduino IDE has uploaded the new code to the ESP32 on the Agon, the Agon should automatically reboot with the latest and greatest.</p>"},{"location":"VDP/","title":"What is the VDP","text":"<p>The VDP is the Agon's Visual Display Processor. It is responsible for:</p> <ul> <li>Video output via the VGA connector</li> <li>Audio output via the built-in buzzer and audio jack</li> <li>Keyboard input via a PS/2 connector</li> <li>Mouse input via a PS/2 connector (on the Agon Console8, or with an adapter on the Agon Light)</li> </ul> <p>It runs on the ESP32-Pico-D4 co-processor and uses a fork of the FabGL library (known as vdp-gl) to support those functions.</p> <p>At a higher level, its input is a byte stream from the eZ80F92 main CPU over an internal high-speed UART connection @ 1,152,000 baud (384,000 baud for versions of MOS/VDP prior to 1.03). This stream contains a mixture of text and control characters. These control characters are mapped to the BBC BASIC VDU control characters, a choice made as BBC BASIC for Agon is the pre-installed programming language of Agon.  As a result, we refer to the commands that the VDP understands as VDU commands.</p> <p>The ESP32 also outputs data back to the eZ80F92, for example keyboard data and screen information via a custom serial protocol.</p>"},{"location":"VDP/#executing-a-vdu-sequence","title":"Executing a VDU sequence","text":""},{"location":"VDP/#from-bbc-basic","title":"From BBC BASIC","text":"<p>The <code>VDU</code> statement in BBC BASIC essentially just means \"send this data to the VDP\".  It will accept any number of integer arguments between 0 and 255, separated by commas.  If a value is immediately followed by a semicolon <code>;</code> instead of a comma then the value is a little-endian word from 0 to 65535.</p> <p>Example:</p> <p><code>VDU 25, 69, 640; 512;</code>: Plot a dot in the center of the screen</p> <p><code>VDU 65</code>: Print the letter \"A\", without a newline</p> <p>A single <code>VDU</code> statement in BASIC can potentially contain multiple commands for the VDP to interpret, or a VDU command could instead be split across multiple <code>VDU</code> statements.  Other BASIC keywords that generate screen output are effectively just wrappers for VDU command sequences.</p> <p>For example, the following code snippets are all directly equivalent, and result in an identical command stream being sent to the VDP:</p> <p><pre><code>PLOT 69, 640, 512\nPRINT \"A\";\n</code></pre> <pre><code>VDU 25, 69, 640; 512; 65\n</code></pre> <pre><code>VDU 25\nVDU 69\nVDU 640; 512;\nVDU ASC(\"A\")\n</code></pre> <pre><code>VDU 25, 69, 128, 2, 0, 2, 65\n</code></pre></p>"},{"location":"VDP/#from-mos-command-line-version-103-or-greater","title":"From MOS command line (Version 1.03 or greater)","text":"<p>MOS also supports a VDU command which can be used to send VDU commands to the VDP.  This is useful for testing the VDP without having to write a BASIC program.  Its command is simpler than the BASIC equivalent, accepting only 8-bit integer values between 0 and 255, separated by spaces.</p> <p>Example:</p> <p><code>VDU 17 15</code>: Set the text foreground colour to 15</p> <p>As of Console8 MOS 2.2.0, the <code>VDU</code> command is now more sophisticated and can support sending 16-bit values as well as 8-bit values.  More information can be found in the MOS documentation.</p>"},{"location":"VDP/#from-assembly-code-on-mos","title":"From Assembly code on MOS","text":"<p>MOS offers two ways to send VDU commands from assembly code.  The first is to use the <code>RST 10h</code> call, which will send the byte in the A register to the VDP.  The second is to use a <code>RST 18h</code> call which is used to send multiple bytes to the VDP at once.  (Neither of these calls require the string <code>VDU</code> to be included in the data sent to the VDP, and both require raw binary values to be sent, rather than an ASCII string.)</p> <p>More information about these can be found in the MOS API documentation.</p>"},{"location":"VDP/#vdu-character-sequences","title":"VDU Character Sequences","text":"<p>The aim is that the Agon's VDP should be as compatible as practical with the BBC Micro's VDU command, as well as the VDU commands supported by later versions of Acorn and R.T.Russell's BBC BASICs.  Where necessary, some extensions have been added to help facilitate the Agon's unique features and architecture.</p> <p>For a more detailed description of VDU commands supported by the Agon's VDP, see VDU Commands.</p> <p>The following is a high-level list of the VDU sequences that are supported:</p> <ul> <li><code>VDU 0</code>: Null (no operation)</li> <li><code>VDU 1</code>: Send next character to \"printer\" (if \"printer\" is enabled) \u00a7\u00a7</li> <li><code>VDU 2</code>: Enable \"printer\" \u00a7\u00a7</li> <li><code>VDU 3</code>: Disable \"printer\" \u00a7\u00a7</li> <li><code>VDU 4</code>: Write text at text cursor</li> <li><code>VDU 5</code>: Write text at graphics cursor</li> <li><code>VDU 6</code>: Enable screen (opposite of <code>VDU 21</code>) \u00a7\u00a7</li> <li><code>VDU 7</code>: Make a short beep (BEL)</li> <li><code>VDU 8</code>: Move cursor back one character</li> <li><code>VDU 9</code>: Move cursor forward one character</li> <li><code>VDU 10</code>: Move cursor down one line</li> <li><code>VDU 11</code>: Move cursor up one line</li> <li><code>VDU 12</code>: Clear text area (<code>CLS</code>)</li> <li><code>VDU 13</code>: Carriage return</li> <li><code>VDU 14</code>: Page mode On *</li> <li><code>VDU 15</code>: Page mode Off *</li> <li><code>VDU 16</code>: Clear graphics area (<code>CLG</code>)</li> <li><code>VDU 17, colour</code>: Define text colour (<code>COLOUR</code>)</li> <li><code>VDU 18, mode, colour</code>: Define graphics colour (<code>GCOL mode, colour</code>)</li> <li><code>VDU 19, l, p, r, g, b</code>: Define logical colour (<code>COLOUR l, p</code> / <code>COLOUR l, r, g, b</code>)</li> <li><code>VDU 20</code>: Reset palette and text/graphics colours and drawing modes \u00a7\u00a7</li> <li><code>VDU 21</code>: Disable screen (turns of VDU command processing, except for <code>VDU 1</code> and <code>VDU 6</code>) \u00a7\u00a7</li> <li><code>VDU 22, n</code>: Select screen mode (<code>MODE n</code>)</li> <li><code>VDU 23, n</code>: Re-program display character / System Commands</li> <li><code>VDU 24, left; bottom; right; top;</code>: Set graphics viewport **</li> <li><code>VDU 25, mode, x; y;</code>: PLOT command</li> <li><code>VDU 26</code>: Reset graphics and text viewports **</li> <li><code>VDU 27, char</code>: Output character to screen \u00a7</li> <li><code>VDU 28, left, bottom, right, top</code>: Set text viewport **</li> <li><code>VDU 29, x; y;</code>: Set graphics origin</li> <li><code>VDU 30</code>: Home cursor</li> <li><code>VDU 31, x, y</code>: Move text cursor to x, y text position (<code>TAB(x, y)</code>)</li> <li><code>VDU 127</code>: Backspace</li> </ul> <p>All other characters, i.e. those in the range of 32 to 126 and 128 to 255, are sent to the screen as ASCII, unaltered.</p> <p>Any VDU command that is the VDP does not recognise (such as <code>VDU 2</code> when running on Quark 1.04) will be ignored.</p> <p>* Requires VDP 1.03 or above  ** Requires VDP 1.04 or above  \u00a7 Requires Console8 VDP 2.3.0 or above  \u00a7\u00a7 Requires Console8 VDP 2.5.0 or above</p>"},{"location":"VDP/#vdu-23-commands","title":"VDU 23 commands","text":"<p><code>VDU 23</code> essentially has a split purpose.  The first is to redefine the system font display characters, and the second is to send commands to the VDP to control and access more sophisticated behaviour.</p> <p>For more information on these commands and a full list, please consult the <code>VDU 23</code> section of the VDU Commands document.  This includes the Bitmap and Sprite API.</p> <p>Amongst this you will also find system commands, which start with <code>VDU 23, 0</code>, most of which are unique to the Agon platform.  Within the system commands set you will find the Audio API, Buffered Commands API, Font API, and Context Management API.</p>"},{"location":"vdp/Bitmaps-API/","title":"VDU 23, 27: Bitmaps, sprites, and mouse cursor","text":"<p>VDU 23, 27 is reserved for the bitmap, sprite, and mouse cursor functionality.</p> <p>As of VDP 1.04, the bitmap system is integrated with the Buffered Commands API.  Bitmap data is stored in buffers, and can be manipulated using the Buffered Commands API on the VDP.</p>"},{"location":"vdp/Bitmaps-API/#bitmaps","title":"Bitmaps","text":"<p>The bitmap system we have on the Agon uses commands that are inspired by Acorn's Graphics eXtension ROM (GXR) system.  Some mistakes were made in the original interpretation of the GXR commands, and so until the Console8 VDP 2.2.0 release it was not possible to use code written for GXR on the Agon.</p> <p>Acorn only actually had two VDU commands for what it called \"sprites\", which in the Agon we consider to be \"bitmaps\".  The first command was used to select a bitmap (so that it may later be used with an appropriate PLOT command), and the second was to define a bitmap from an area of screen.</p> <p>The approach taken on Agon (initially at least) was to redefine the \"define bitmap from screen\" command to instead allow the uploading of a binary bitmap image.  In doing so, the parameters of the command changed, and the bitmap identifier was lost from the command parameters.  Instead, on the Agon, you need to always perform a \"select bitmap\" command before any other bitmap commands to set the bitmap being used.  Additionally on the Agon, prior to Console8 VDP 2.2.0, plotting bitmaps could only be performed with a custom command, and not with the standard <code>PLOT</code> commands.</p> <p>As of Console8 VDP 2.2.0, it is now possible to use Acorn GXR style \"sprite\" code on an Agon.  The <code>PLOT</code> code for drawing bitmaps is now supported, and bitmap command 1 can now be used to capture screen data into a bitmap identically to the GXR.  The documentation on the <code>PLOT</code> command (<code>VDU 25</code>) explains how to use it to draw bitmaps.</p> <p>In addition to GXRs two commands, the Agon VDP has several other commands for managing bitmaps, and additional commands to manage \"sprites\".</p> <p>As has been noted above, bitmap data is stored in buffers.  Acorn's original API design only allows for a maximum of 255 bitmaps, as they used an 8-bit ID, however buffers are identified with a 16-bit identifier.  This means that the Agon VDP can support a much larger number of bitmaps, in theory up to 65534 of them.  To allow access to these additional bitmaps, the Agon VDP several additional commands working with bitmaps using 16-bit IDs.  Those 16-bit IDs directly correspond to the IDs of the buffers in which the bitmpas are stored.  Bitmaps with 8-bit IDs are automatically mapped onto buffer IDs in the range 64000-64255.</p> <p>In general, commands to manage bitmaps using 16-bit IDs are numbered 32 higher than the equivalent command using an 8-bit ID (32 is <code>&amp;20</code> in hexadecimal).  For instance, the command to select a bitmap with an 8-bit ID is <code>VDU 23, 27, 0, n</code>, whereas the command to select a bitmap with a 16-bit ID is <code>VDU 23, 27, &amp;20, bufferId;</code>.</p> <p>Storing bitmaps in buffers allows for their data to be manipulated using the buffered commands API.  This can, for instance, allow for the colours of bitmaps to be changed, or for a bitmap to be mirrored, or split into multiple bitmaps.</p> <p>* Commands marked with an asterisk are only available in VDP 2.2.0 or later. ** Commands marked with a double asterisk are only available in VDP 2.6.0 or later.</p> <p>The commands to manage bitmaps are as follows:</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-0-n-select-bitmap-n","title":"<code>VDU 23, 27, 0, n</code>: Select bitmap n","text":"<p>This selects the bitmap with the given 8-bit ID as being the currently \"active\" bitmap for subsequent bitmap commands.</p> <p>As noted above, bitmaps with 8-bit IDs are stored in buffers with an ID of 64000+<code>n</code>.</p> <p>You need to select a bitmap before it can be plotted onto the screen or use any other bitmap commands.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-1-w-h-b1-b2-bn-load-colour-bitmap-data-into-current-bitmap","title":"<code>VDU 23, 27, 1, w; h; b1, b2 ... bn</code>: Load colour bitmap data into current bitmap","text":"<p>This command is used to load bitmap data directly into the currently selected bitmap.</p> <p>Before you can load bitmap data into a bitmap, you must first select the bitmap using <code>VDU 23, 27, 0, n</code>, where <code>n</code> is the 8-bit ID of the bitmap to be loaded, or using <code>VDU 23, 27, &amp;20, bufferId;</code> using a 16-bit buffer ID.</p> <p>The bitmap data is given as a series of bytes as part of the command in RGBA8888 format, meaning that each pixel is represented by four bytes, one each for the red, green, blue, and alpha components of the pixel.  Each component value is in the range of 0-255.  The bytes are given in row-major order, starting at the top left of the bitmap, and working across the rows, and then down the columns.</p> <p>The width and height of the bitmap must be given in pixels, and must match the number of bytes given in the data.  If the width and height do not match the data then the command will fail.</p> <p>It should be noted that whilst the image format supported by this command is for full 24-bit colour images with 256 levels of transparency (alpha) per pixel, the Agon hardware is only capable of displaying 2-bits per colour channel.  The graphics system also does not really support transparency, so any non-zero alpha value is interpreted as \"fully visible\".  Data loaded via this command remains in RGBA8888 format on the VDP, but is converted on the fly when the bitmap is drawn to the screen.</p> <p>(As RGBA8888 is a very wasteful format, given the hardware limitations, other options are now available.  Loading bitmaps with this command can take a long time, and it is not possible to intersperse other commands, such as showing progress on-screen, whilst the data is being sent.  There are however alternative ways of managing the data which avoids these issues.  Please see the section on \"Using buffers for bitmaps\" in the Buffered Commands API document for more information.)</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-1-n-0-0-capture-screen-data-into-bitmap-n","title":"<code>VDU 23, 27, 1, n, 0, 0;</code>: Capture screen data into bitmap n *","text":"<p>This command, added in Agon Console8 VDP 2.2.0, is compatible with the Acorn GXR command of the same number.  It captures the screen data into the bitmap with the given 8-bit ID.</p> <p>This version of the <code>VDU 23, 27, 1</code> command differs from the one documented before in that you do not need to explicitly select a bitmap before capturing screen data into it.  The bitmap ID is passed as a parameter to this version of the command.</p> <p>As you may have noticed, this command does not include any dimensions for the bitmap.  Those are set via the graphics system, taking the last two graphics cursor positions to define the bitmap rectangle.  Any <code>PLOT</code>, or <code>VDU 25</code>, style command will push the graphics cursor position - typically \"move\" style plot commands are used to define the rectangle.</p> <p>To be clear, this command should be performed after two \"move\" style PLOT commands.</p> <p>If a bitmap with the given ID already exists then it will be overwritten, and similarly if a buffer was already defined with the ID 64000+<code>n</code> then that will be overwritten too.</p> <p>Up to and including the Console8 VDP 2.5.0 release, the bitmap data captured using this command will be stored in \"native\" format.  The nature of the \"native\" format varies depending on the screen mode.  For all screen modes the bitmap will use 1 byte per pixel, but the data within that byte varies.  In 64 colour modes, the data is essentially in RGB222 with no alpha channel.  It is possible to convert bitmaps captured in 64 colour modes to RGBA2222 format by using the OR operation of the \"adjust\" command from the Buffered Commands API, ORing all the bytes in the bitmap's buffer with <code>&amp;C0</code> to set the pixel alpha bits to be \"opaque\", and then re-creating the bitmap from the corresponding buffer to be RGBA2222 (format 1).  For all other screen modes, the byte represents a palette index.  An unfortunate effect of this is that a bitmap captured in one screen mode may not be compatible with other screen modes.</p> <p>Also up to and including the Console8 VDP 2.5.0 release, bitmaps captured with this command would use \"exclusive\" coordinates, and so would be 1 pixel shorter and narrower than the area defined by the graphics cursor positions.  (This is not consistent with the behaviour of this command on Acorn systems.)</p> <p>From Console8 VDP 2.6.0, the bitmap data captured using this command will be stored in RGBA2222 format, regardless of the screen mode.  This is to ensure that the data is consistent and predictable, and to allow for the use of the bitmap in any screen mode.</p> <p>Bitmaps captured on Console8 VDP 2.6.0 or later also now use \"inclusive\" coordinates, and so will be 1 pixel taller and wider than bitmaps captured on earlier versions of the VDP.  This is to ensure that the bitmap captures the entire area defined by the graphics cursor positions.  This is consistent with the behaviour of this command on Acorn systems.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-2-w-h-col1-col2-create-a-solid-colour-rectangular-bitmap","title":"<code>VDU 23, 27, 2, w; h; col1; col2;</code>: Create a solid colour rectangular bitmap","text":"<p>Creates a new bitmap in RGBA8888 format with the given width and height, and fills it with a solid colour.  The colour is given as two 16-bit numbers, col1 and col2, which are combined to form a 32-bit number in RGBA colour range.</p> <p>The bitmap is created in the buffer with the ID 64000+<code>n</code>, where <code>n</code> is the 8-bit ID given in the command.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-3-x-y-draw-current-bitmap-on-screen-at-pixel-position-x-y","title":"<code>VDU 23, 27, 3, x; y;</code>: Draw current bitmap on screen at pixel position x, y","text":"<p>Prior to Agon Console8 VDP 2.2.0, this was the only way to draw a bitmap on-screen.  On more up to date VDP versions is strongly recommended that you use the appropriate PLOT command instead.</p> <p>Before this command can be used, a bitmap must be selected using <code>VDU 23, 27, 0, n</code>, where <code>n</code> is the 8-bit ID of the bitmap to be drawn, or using <code>VDU 23, 27, &amp;20, bufferId;</code> using a 16-bit buffer ID.</p> <p>The x and y parameters give the pixel position on the screen at which the top left corner of the bitmap will be drawn.  This is in contrast to <code>PLOT</code> commands which will (by default) use OS Coordinates, where the origin is at the bottom left of the screen and the screen is always considered to have the dimensions 1280x1024.</p> <p>Please note that this command does not obey the current graphics viewport or the currently selected coordinate system.  The bitmap will be drawn at the given pixel position, and will not be clipped by the viewport.  To draw bitmaps with clipping, you are advised to use the appropriate bitmap PLOT commands instead.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-20-bufferid-select-bitmap-using-a-16-bit-buffer-id","title":"<code>VDU 23, 27, &amp;20, bufferId;</code>: Select bitmap using a 16-bit buffer ID *","text":"<p>This command is essentially identical to <code>VDU 23, 27, 0, n</code>, however it uses a 16-bit buffer ID instead of an 8-bit bitmap ID.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-21-w-h-format-create-bitmap-from-selected-buffer","title":"<code>VDU 23, 27, &amp;21, w; h; format</code>: Create bitmap from selected buffer *","text":"<p>This command creates a new bitmap from the data in the currently selected buffer.</p> <p>Whilst bitmap data can be loaded into a buffer at any time, before that data can drawn on-screen it must be converted into a bitmap.  The VDP needs to understand the width and height of the bitmap, and the format of the data.  This command performs that conversion.</p> <p>Valid values for the format parameter are:</p> Value Meaning 0 RGBA8888 (4-bytes per pixel) 1 RGBA2222 (1-bytes per pixel) 2 Mono/Mask (1-bit per pixel) 3 Reserved for internal use by VDP (\"native\" format) <p>It should be noted that the \"alpha\" channel in both the RGBA8888 and RGBA2222 formats is not properly used by the Agon VDP.  Any non-zero value in the alpha channel is interpreted as \"fully visible\".  The Agon VDP does not currently support transparency.  The alpha channel is still stored in the bitmap data, and is used when the bitmap is drawn to the screen, but it is not used to blend the bitmap with the background.  (If we improve support for transparency in the future, to maintain compatibility we will do so by adding new bitmap formats, rather than changing the behaviour of the existing formats.)</p> <p>Mono/Mask bitmaps can be of any width, but their data must be sent using a whole number of bytes per row.  Mon/mask bitmaps are also required to have a colour, and will use the currently selected graphics foreground colour.  If you wish to use a different colour then you must change the graphics foreground colour before creating the bitmap.  Mono/mask bitmaps only draw their \"on\" pixels, and the \"off\" pixels are transparent.</p> <p>The use of the \"native\" format is reserved for internal use by the VDP.  They have some significant limitations, and are not intended for general use.</p> <p>As with <code>VDU 23, 27, 1, w; h; b1, b2...bn</code>, the width and height of the bitmap must be given in pixels, and must match the number of bytes given in the data.  If the width and height do not match the data then the command will fail.</p> <p>Prior to the Console8 VDP 2.2.0 release, mono/mask bitmaps were not supported.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-21-bitmapid-0","title":"<code>VDU 23, 27, &amp;21, bitmapId; 0;</code>","text":"<p>This command captures a bitmap from the screen into the buffer with the given 16-bit buffer ID.  It works the same as <code>VDU 23, 27, 1, n, 0, 0;</code>, but using a 16-bit buffer ID instead of an 8-bit bitmap ID.</p> <p>Support for this command was added in VDP 2.2.0.</p>"},{"location":"vdp/Bitmaps-API/#sprites","title":"Sprites","text":"<p>The Sprites system on the Agon VDP is an extension to the bitmap system.  They are not true \"hardware sprites\" as one might find on some 8-bit machines or consoles.  They are best thought of as \"automatically drawn bitmaps\".</p> <p>Technically the VDP can support up to 256 sprites.  They must be defined contiguously, and so the first sprite is sprite 0.  (In contrast, bitmaps can have any ID from 0 to 65534.)  Once a selection of sprites have been defined, you can activate them using the <code>VDU 23, 27, 7, n</code> command, where <code>n</code> is the number of sprites to activate.  This will activate the first <code>n</code> sprites, starting with sprite 0.  All sprites from 0 to n-1 must be defined.</p> <p>A single sprite can have multiple \"frames\", referring to different bitmaps.  (These bitmaps do not need to be the same size.)  This allows a sprite to include an animation sequence, which can be stepped through one frame at a time, or picked in any order.</p> <p>Any format of bitmap can be used as a sprite frame.  It should be noted however that \"native\" format bitmaps are not recommended for use as sprite frames, as they cannot get erased from the screen.  (As noted above, the \"native\" bitmap format is not really intended for general use.)  This is part of why from Agon Console8 VDP 2.6.0 bitmaps captured from the screen are now stored in RGBA2222 format.</p> <p>An \"active\" sprite can be hidden, so it will stop being drawn, and then later shown again.</p> <p>Moving sprites around the screen is done by changing the position of the sprite.  This can be done either by setting the absolute position of the sprite, or by moving the sprite by a given number of pixels.  (Sprites are positioned using pixel coordinates, and not by the logical OS coordinate system.)  In the current sprite system, sprites will not update their position on-screen until either another drawing operation is performed or an explicit <code>VDU 23, 27, 15</code> command is performed.</p> <p>Here are the sprite commands:</p> <ul> <li><code>VDU 23, 27, 4, n</code>: Select sprite n</li> <li><code>VDU 23, 27, 5</code>: Clear frames in current sprite</li> <li><code>VDU 23, 27, 6, n</code>: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+<code>n</code>)</li> <li><code>VDU 23, 27, 7, n</code>: Activate n sprites</li> <li><code>VDU 23, 27, 8</code>: Select next frame of current sprite</li> <li><code>VDU 23, 27, 9</code>: Select previous frame of current sprite</li> <li><code>VDU 23, 27, 10, n</code>: Select the nth frame of current sprite</li> <li><code>VDU 23, 27, 11</code>: Show current sprite</li> <li><code>VDU 23, 27, 12</code>: Hide current sprite</li> <li><code>VDU 23, 27, 13, x; y;</code>: Move current sprite to pixel position x, y</li> <li><code>VDU 23, 27, 14, x; y;</code>: Move current sprite by x, y pixels</li> <li><code>VDU 23, 27, 15</code>: Update the sprites in the GPU</li> <li><code>VDU 23, 27, 16</code>: Reset bitmaps and sprites and clear all data</li> <li><code>VDU 23, 27, 17</code>: Reset sprites (only) and clear all data</li> <li><code>VDU 23, 27, 18, n</code>: Set the current sprite GCOL paint mode to n **</li> <li><code>VDU 23, 27, &amp;26, n;</code>: Add bitmap n as a frame to current sprite using a 16-bit buffer ID</li> </ul>"},{"location":"vdp/Bitmaps-API/#notes-on-sprites","title":"Notes on sprites","text":"<p>This advice is valid up to and including the Agon Console8 VDP 2.6.0 release.  In the future this may change.</p> <p>The nature of how sprites are currently supported in the Agon VDP means that performance is not as good as it could be, and so they should be used sparingly.  If you have too many sprites on-screen then you may notice that some sprites may flicker, especially if they are positioned closer to the top of the screen.  Sprites are currently always drawn in order, so those with lower IDs will flicker less than those with higher IDs.</p> <p>Performance of the Agon emulator differs significantly from real hardware, owing to how the VDP system is emulated.  You will be able to have more sprites on-screen on the emulator than you will on real hardware.</p> <p>Technically, sprites are implemented as \"automatically drawn bitmaps\".  When a sprite is drawn on-screen, a copy of the area of screen that it covers is made, and then the sprite bitmap is drawn over that screen area.  (Sprite bitmaps can be transparent, and the background will show through.)  When a sprite is hidden, the area of screen that it covered is copied back onto the screen.  When you have a lot of sprites, this can mean that a lot of screen data is being copied around.</p> <p>Owing to inefficiencies in how sprites have been implemented, any operation that draws something to the screen will cause all sprites to be hidden, the drawing operation performed, and then all sprites are redrawn.  (This includes, for example, the flashing of the text cursor.)  Sprites are redrawn in order by their ID at the beginning of the screen being drawn to the VGA port.  This means that if there are a lot of active sprites, those later in the list get drawn to the screen buffer later, possibly after that part of the screen has been sent out of the VGA port.  This, essentially, is the cause of the flickering.</p> <p>One way to reduce flickering is to try to avoid using sprites near the top of the screen.  This gives more opportunity for the sprites to be redrawn.</p> <p>Owing to how sprites work, it is hard to offer definitive advice on how many sprites you can use.  The size of sprites you are using will also be a factor.  It is best to experiment and see what works for you.</p> <p>Sprites also behave differently on double-buffered screen modes.  On those modes sprites are never \"hidden\" and are instead drawn to screen before a buffer swap.  This means they tend not to flicker, but care needs to be taken to ensure that the screen is properly redrawn.</p> <p>Up to and including the Console8 VDP 2.5.0 release, sprites using bitmaps captured from screen would not work properly, and would not be erased from the screen.  This is because the bitmaps were stored in \"native\" format, and the VDP did not have the ability to erase them.  This has been fixed in the Console8 VDP 2.6.0 release, and bitmaps captured from the screen are now stored in RGBA2222 format, and so can be erased from the screen.</p> <p>Console8 VDP 2.6.0 also introduces the ability to set the GCOL paint mode for sprites.  This can allow for more sophisticated drawing operations to be performed with sprites, and some interesting effects.</p> <p>For completely optimal graphical performance, it is usually best to avoid using sprites, and instead use the bitmap system directly.  Using a small number of sprites can be a reasonable compromise.</p>"},{"location":"vdp/Bitmaps-API/#mouse-cursor","title":"Mouse cursor","text":""},{"location":"vdp/Bitmaps-API/#vdu-23-27-40-hotx-hoty-setup-a-mouse-cursor","title":"<code>VDU 23, 27, &amp;40, hotX, hotY</code>: Setup a mouse cursor","text":"<p>Sets up a new mouse cursor using the currently selected bitmap, with a hotspot at hotX, hotY.</p> <p>Once a mouse cursor has been set up in this way, it can be selected for display using <code>VDU 23, 0, &amp;89, 3, bitmapId;</code>.  Please note that this is a 16-bit ID, therefore if a bitmap had been selected using an 8-bit identifier you will need to add 64000 to the ID to get the 16-bit ID.</p> <p>Care should be taken to avoid using bitmapIds from 0-18, as those conflict with existing cursor Ids.</p>"},{"location":"vdp/Buffered-Commands-API/","title":"VDP Buffered Commands API","text":"<p>The VDP Buffered Commands API is a low-level API that allows for the creation of buffers on the VDP.  These buffers can be used for sequences of commands for later execution, storing data, capturing output from the VDP, as well as storing bitmaps and sound samples.</p> <p>Through the use of the APIs, it is possible to both send commands to the VDP in a \"packetised\" form, as well as to have \"functions\" or \"stored procedures\" that can be saved on the VDP and executed later.</p> <p>These commands are collected under <code>VDU 23, 0, &amp;A0, bufferId; command, [&lt;arguments&gt;]</code>.</p> <p>Examples below are given in BBC BASIC.</p> <p>A common source of errors when sending commands to the VDP from BASIC via VDU statements is to forget to use a <code>;</code> after a number to indicate a 16-bit value should be sent.  If you see unexpected behaviour from your BASIC code that is the most likely source of the problem.</p> <p>All commands must specify a buffer ID as a 16-bit integer.  There are 65534 buffers available for general use, with one buffer ID (number 65535) reserved for special functions, and is generally interpretted as meaning \"current buffer\".  As with all other VDP commands, these 16-bit values are sent as two bytes in little-endian order, and are documented as per BBC BASIC syntax, such as <code>bufferId;</code>.</p> <p>On a restart all buffers will be empty.  One should not assume however that buffers are empty when your program is run, as other programs may have already used the buffers.  Indeed, it is a valid use case to have a \"loader\" program that is designed to be run before another program to prepare a set of buffers for that second program to use.  It is therefore advisable to clear out the buffers before use.</p> <p>A single buffer can contain multiple blocks.  This approach allows for a buffer to be gradually built up over time, and for multiple commands to be sent to the VDP in a single packet.  This can be useful for sending large amounts of data to the VDP, such as a large bitmap or a sound sample, or using smaller blocks to contain for command sequences for more easily referencing an individual command (or indeed even fragments of command sequences).  By breaking up large data into smaller packets it is possible to avoid blocking the screen for long periods of time, allowing for a visual indicator of progress to be made to the user.</p> <p>Many of the commands accept an offset within a buffer.  An offset is typically a 16-bit value, however as buffers can be larger than 64kb an \"advanced\" offset mode is provided.  This advanced mode allows for offsets to be specified as 24-bit values, and also provides for a mechanism to refer to individual blocks within a buffer.  When this mode is used, the offset is sent as 3 bytes in little-endian order.  If the top bit of an advanced offset is set, this indicates that following the offset value there will be a 16-bit block number, with the remaining 23-bit offset value to be applied as an offset within the indicated block.  Using block offsets can be useful for modifying commands within buffers, as using block offsets can make identifying where parameters are placed within commands much easier to work out.</p> <p>At this time the VDP Buffered Commands API does not send any messages back to MOS to indicate the status of a command.  This will likely change in the future, but that may require changes to agon-mos to support it.</p>"},{"location":"vdp/Buffered-Commands-API/#command-0-write-block-to-a-buffer","title":"Command 0: Write block to a buffer","text":"<p><code>VDU 23, 0 &amp;A0, bufferId; 0, length; &lt;buffer-data&gt;</code></p> <p>This command is used to store a data block (a sequence of bytes) in a buffer on the VDP.  The exact nature of this data may vary.  It could be a sequence of VDU commands which can be executed later, a bitmap, a sound sample, or just a sequence of bytes.  When used for a sequence of VDU commands, this effectively allows for functions or stored procedures to be created.</p> <p>This is the most common command to use to send data to the VDP.  Typically you will call command 2 first to ensure that the buffer is empty, and then make a series of calls to this command to send data to the buffer.</p> <p>The <code>bufferId</code> is a 16-bit integer that identifies the buffer to write to.  Writing to the same buffer ID multiple times will add new blocks to that buffer.  This allows a buffer to be built up over time, essentially allowing for a command to be sent across to the VDP in multiple separate packets.</p> <p>Whilst the length of an individual block added using this command is restricted to 65535 bytes (as the largest value that can be sent in a 16-bit number) the total size of a buffer is not restricted to this size, as multiple blocks can be added to a buffer.  Given how long it takes to send data to the VDP it is advisable to send data across in smaller chunks, such as 1kb of data or less at a time.</p> <p>As writing to a single buffer ID is cumulative with this command, care should be taken to ensure that the buffer is cleared out before writing to it.</p> <p>When building up a complex sequence of commands it is often advisable to use multiple blocks within a buffer.  Typically this is easier to code, as otherwise working out exactly how many bytes long a command sequence is can be can be onerously difficult.  It is also easier to modify a command sequences that are broken up into multiple blocks.</p> <p>As mentioned above it is advisable to send large pieces of data, such as bitmaps or sound samples, in smaller chunks.  In between each packet of data sent to a buffer, the user can then perform other operations, such as updating the screen to indicate progress.  This allows for long-running operations to be performed without blocking the screen, and larger amounts of data to be transferred over to the VDP than may otherwise be practical given the limitations of the eZ80.</p> <p>If a buffer ID of 65535 is used then this command will be ignored, and the data discarded.  This is because this buffer ID is reserved for special functions.</p>"},{"location":"vdp/Buffered-Commands-API/#using-buffers-for-bitmaps","title":"Using buffers for bitmaps","text":"<p>Whilst it is advisable to send bitmaps over in multiple blocks, they cannot be used if they are spread over multiple blocks.  To use a bitmap its data must be in a single contiguous block, and this is achieved by using the \"consolidate\" command <code>&amp;0E</code>.</p> <p>Once you have a block that is ready to be used for a bitmap, the buffer must be selected, and then a bitmap created for that buffer using the bitmap and sprites API.  This is done with the following commands:</p> <pre><code>VDU 23, 27, &amp;20, bufferId;              : REM Select bitmap (using a buffer ID)\nVDU 23, 27, &amp;21, width; height; format  : REM Create bitmap from buffer\n</code></pre> <p>More extensive information on the bitmap and sprites API calls can be found in the bitmaps and sprites documentation.</p> <p>Until the \"create bitmap\" call has been made the buffer cannot be used as a bitmap.  That is because the system needs to understand the dimensions of the bitmap, as well as the format of the data.  Usually this only needs to be done once.  The format is given as an 8-bit value, with the following values supported:</p> Value Type Description 0 RGBA8888 RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha 1 RGBA2222 RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red 2 Mono/Mask Monochrome, 1-bit per pixel <p>The existing bitmap API uses an 8-bit number to select bitmaps, and these are automatically stored in buffers numbered 64000-64255 (<code>&amp;FA00</code>-<code>&amp;FAFF</code>).  Working out the buffer number for a bitmap is simply a matter of adding 64000.  All bitmaps created with that API will be RGBA8888 format.</p> <p>There is one other additional call added to the bitmap and sprites API, which allows for bitmaps referenced with a buffer ID to be added to sprites.  This is done with the following command:</p> <pre><code>VDU 23, 27, &amp;26, bufferId;              : REM Add bitmap to the current sprite\n</code></pre> <p>This command otherwise works identically to <code>VDU 23, 27, 6</code>.</p> <p>It should be noted that it is possible to modify the buffer that a bitmap is stored in using the \"adjust buffer contents\" and \"reverse contents\" commands (<code>5</code> and <code>24</code> respectively).  This can allow you to do things such as changing colours in a bitmap, or flipping an image horizontally or vertically.  This will even work on bitmaps that are being used inside sprites.</p> <p>Using commands targetting a buffer that create new blocks, such as \"consolidate\" or \"split\", will invalidate the bitmap and remove it from use.</p>"},{"location":"vdp/Buffered-Commands-API/#using-buffers-for-sound-samples","title":"Using buffers for sound samples","text":"<p>Much like with bitmaps, it is advisable to send samples over to the VDP in multiple blocks for the same reasons.</p> <p>In contrast to bitmaps, the sound system can play back samples that are spread over multiple blocks, so there is no need to consolidate buffers.  As a result of this, the sample playback system is also more tolerant of modifications being made to the buffer after a sample has been created from it, even if the sample is currently playing.  It should be noted that splitting a buffer may result in unexpected behaviour if the sample is currently playing, such as skipping to other parts of the sample.</p> <p>Full information on the sound system can be found in the audio API documentation.</p> <p>Once you have a buffer that contains block(s) that are ready to be used for a sound sample, the following command must be used to indicate that a sample should be created from that buffer:</p> <pre><code>VDU 23, 0, &amp;85, 0, 5, 2, bufferId; format\n</code></pre> <p>The <code>format</code> parameter is an 8-bit value that indicates the format of the sample data.  The following values are supported:</p> Value Description 0 8-bit signed, 16KHz 1 8-bit unsigned, 16KHz <p>Once a sample has been created in this way, the sample can be selected for use on a channel using the following command:</p> <pre><code>VDU 23, 0, &amp;85, channel, 4, 8, bufferId;\n</code></pre> <p>Samples uploaded using the existing \"load sample\" command (<code>VDU 23, 0, &amp;85, sampleNumber, 5, 0, length; lengthHighByte, &lt;sample data&gt;</code>) are also stored in buffers automatically.  A sample number using this system is in the range of -1 to -128, but these are stored in the range 64256-64383 (<code>&amp;FB00</code>-<code>&amp;FB7F</code>).  To map a number to a buffer range, you need to negate it, subtract 1, and then add it to 64256.  This means sample number -1 is stored in buffer 64256, -2 is stored in buffer 64257, and so on.</p>"},{"location":"vdp/Buffered-Commands-API/#command-1-call-a-buffer","title":"Command 1: Call a buffer","text":"<p><code>VDU 23, 0 &amp;A0, bufferId; 1</code></p> <p>This command will attempt to execute all of the commands stored in the buffer with the given ID.  If the buffer does not exist, or is empty, then this command will do nothing.</p> <p>Essentially, this command passes the contents of the buffer to the VDP's VDU command processor system, and executes them as if they were sent directly to the VDP.</p> <p>As noted against command 0, it is possible to build up a buffer over time by sending across multiple commands to write to the same buffer ID.  When calling a buffer with multiple blocks, the blocks are executed in order.</p> <p>Care should be taken when using this command within a buffer, as it is possible to create an infinite loop.  For instance, if a buffer contains a command to call itself, then this will result in an infinite loop.  This will cause the VDP to hang, and the only way to recover from this is to reset the VDP.</p> <p>Using a <code>bufferId</code> of -1 (65535) will cause the current buffer to be executed.  This can be useful for creating loops within a buffer.  It will be ignored if used outside of a buffered command sequence.</p>"},{"location":"vdp/Buffered-Commands-API/#command-2-clear-a-buffer","title":"Command 2: Clear a buffer","text":"<p><code>VDU 23, 0 &amp;A0, bufferId; 2</code></p> <p>This command will clear the buffer with the given ID.  If the buffer does not exist then this command will do nothing.</p> <p>Please note that this clears out all of the blocks sent to a buffer via command 0, not just the last one.  i.e. if you have built up a buffer over time by sending multiple commands to write to the same buffer ID, this command will clear out all of those commands.</p> <p>Calling this command with a <code>bufferId</code> value of -1 (65535) will clear out all buffers.</p>"},{"location":"vdp/Buffered-Commands-API/#command-3-create-a-writeable-buffer","title":"Command 3: Create a writeable buffer","text":"<p><code>VDU 23, 0 &amp;A0, bufferId; 3, length;</code></p> <p>This command will create a new writeable buffer with the given ID.  If a buffer with the given ID already exists then this command will do nothing.  This command is primarily intended for use to create a buffer that can be used to capture output using the \"set output stream\" command (see below), or to store data that can be used for other commands.</p> <p>It is generally quite rare that you will want to use this command.  Typically you will instead want to use command 0 to write data to a buffer.  It is not necessary to use this command before using command 0, and indeed doing so will lead to errors as you will end up with two blocks in the buffer, the first of which will be empty.  If you do wish to use this command to create a buffer for data and then write to it, you would need to use operation 2 of command 5, the \"set\" operation in the \"buffer adjust\" command, to set a sequence of bytes in the buffer to the data you want to write.  This is not recommended, as it is much easier to just use command 0 to write a data block to a buffer.</p> <p>This new buffer will be a single empty single block upon creation, containing zeros.</p> <p>The <code>length</code> parameter is a 16-bit integer that specifies the maximum size of the buffer.  This is the maximum number of bytes that can be stored in the buffer.  If the buffer is full then no more data can be written to it, and subsequent writes will be ignored.</p> <p>After creating a buffer with this command it is possible to use command 0 to write further blocks to the buffer, however this is probably not advisable.</p> <p>A <code>bufferId</code> of -1 (65535) and 0 will be ignored, as these values have special meanings for writable buffers.  See command 4.</p>"},{"location":"vdp/Buffered-Commands-API/#command-4-set-output-stream-to-a-buffer","title":"Command 4: Set output stream to a buffer","text":"<p><code>VDU 23, 0 &amp;A0, bufferId; 4</code></p> <p>Sets then current output stream to the buffer with the given ID.  With two exceptions, noted below, this needs to be a writable buffer created with command 3.  If the buffer does not exist, or the first block within the buffer is not writable, then this command will do nothing.</p> <p>Following this command, any subsequent VDU commands that send response packets will have those packets written to the specified output buffer.  This allows the user to capture the response packets from a command sent to the VDP.</p> <p>By default, the output stream (for the main VDU command processor) is the communications channel from the VDP to MOS running on the eZ80.</p> <p>Passing a buffer ID of -1 (65535) to this command will remove/detach the output buffer.  From that point onwards, any subsequent VDU commands that send response packets will have those responses discarded/ignored.</p> <p>Passing a buffer ID of 0 to this command will set the output buffer back to its original value for the current command stream.  Typically that will be the communications channel from the VDP to MOS running on the eZ80, but this may not be the case if a nested call has been made.</p> <p>When used inside a buffered command sequence, this command will only affect the output stream for that sequence of commands, and any other buffered command sequences that are called from within that sequence.  Once the buffered command sequence has completed, the output stream will effectively be reset to its original value.</p> <p>It is strongly recommended to only use this command from within a buffered command sequence.  Whilst it is possible to use this command from within a normal VDU command sequence, it is not recommended as it may cause unexpected behaviour.  If you do use it in that context, it is very important to remember to restore the original output channel using <code>VDU 23, 0, &amp;A0, 0; 4</code>.  (In the future, this command may be disabled from being used outside of a buffered command sequence.)</p> <p>At present, writable buffers can only be written to until the end of the buffer has been reached; once that happens no more data will be written to the buffer.  It is not currently possible to \"rewind\" an output stream.  It is therefore advisable to ensure that the buffer is large enough to capture all of the data that is expected to be written to it.  The only current way to \"rewind\" an output stream would be to clear the buffer and create a new one, and then call set output stream again with the newly created buffer.</p>"},{"location":"vdp/Buffered-Commands-API/#command-5-adjust-buffer-contents","title":"Command 5: Adjust buffer contents","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 5, operation, offset; [count;] &lt;operand&gt;, [arguments]</code></p> <p>This command will adjust the contents of a buffer, at a given offset.  The exact nature of the adjustment will depend on the operation used.</p> <p>Passing a <code>bufferId</code> of -1 (65535) to this command will adjust the contents of the current buffer.  This will only work if this command is used within a buffered command sequence, otherwise the command will not do anything.</p> <p>The basic set of adjustment operations are as follows:</p> Operation Description 0 NOT 1 Negate 2 Set value 3 Add 4 Add with carry 5 AND 6 OR 7 XOR <p>All of these operations will modify a byte found at the given offset in the buffer.  The only exception to that is the \"Add with carry\" operation, which will also store the \"carry\" value in the byte at the next offset.  With the exception of NOT and Negate, each command requires an operand value to be specified.</p> <p>To flip the bits of a byte at offset 12 in buffer 3, you would need to use the NOT operation, and so the following command would be used: <pre><code>VDU 23, 0, &amp;A0, 3; 5, 0, 12;\n</code></pre></p> <p>To add 42 to the byte at offset 12 in buffer 3, you would need to use the Add operation, and so the following command would be used: <pre><code>VDU 23, 0, &amp;A0, 3; 5, 3, 12; 42\n</code></pre></p> <p>When using add with carry, the carry value is stored in the byte at the next offset.  So to add 42 to the byte at offset 12 in buffer 3, and store the carry value in the byte at offset 13, you would need to use the Add with carry operation, and so the following command would be used: <pre><code>VDU 23, 0, &amp;A0, 3; 5, 4, 12; 42\n</code></pre></p>"},{"location":"vdp/Buffered-Commands-API/#advanced-operations","title":"Advanced operations","text":"<p>Whilst these operations are useful, they are not particularly powerful as they only operate one one byte at a time, with a fixed operand value, and potentially cannot reach all bytes in a buffer.  To address this, the API supports a number of advanced operations.</p> <p>The operation value used is an 8-bit value that can have bits set to modify the behaviour of the operation.  The following bits are defined:</p> Bit Description &amp;10 Use \"advanced\" offsets &amp;20 Operand is a buffer-fetched value (buffer ID and an offset) &amp;40 Multiple target values should be adjusted &amp;80 Multiple operand values should be used <p>These bits can be combined together to modify the behaviour of the operation.</p> <p>Fundamentally, this command adjusts values of a buffer at a given offset one byte at a time.  When either of the \"multiple\" variants are used, a 16-bit <code>count</code> must be provided to indicate how many bytes should be altered.</p> <p>Advanced offsets are sent as a 24-bit value in little-endian order, which can allow for buffers that are larger than 64kb to be adjusted.  If the top-bit of this 24-bit value is set, then the 16-bit value immediately following the offset is used as a block index number, and the remaining 23-bits of the offset value are used as an offset within that block.  When the \"advanced\" offset mode bit has been set then all offsets associated with this command must be sent as advanced offsets.</p> <p>The \"buffer-fetched value\" mode allows for the operand value to be fetched from a buffer.  The operand sent as part of the command in this case is a pair of 16-bit values giving the buffer ID and offset to indicate where the actual operand value should be fetched from.  An operand buffer ID of -1 (65535) will be interpretted as meaning \"this buffer\", and thus can only be used inside a buffered command sequence.  If the advanced offset mode is used, then the operand value is an advanced offset value.</p> <p>The \"multiple target values\" mode allows for multiple bytes to be adjusted at once.  When this mode is used, the <code>count</code> value must be provided to indicate how many bytes should be adjusted.  Unless the \"multiple operand values\" mode is also used, the operand value is used for all bytes adjusted.</p> <p>The \"multiple operand values\" mode allows for multiple operand values to be used.  When this mode is used, the <code>count</code> value must be provided to indicate how many operand values should be used.  This can allow, for instance, to add together several bytes in a buffer.  When this mode is used in conjunction with the \"multiple target values\" mode, the number of operand values must match the number of target values, and the operation happens one byte at a time.</p> <p>Some examples of advanced operations are as follows:</p> <p>Flip the bits of 7 bytes in buffer 3 starting at offset 12: <pre><code>VDU 23, 0, &amp;A0, 3; 5, &amp;40, 12; 7;\n</code></pre> This uses operation 0 (NOT) with the \"multiple target values\" modifier (&amp;40).</p> <p>Add 42 to each of the 7 bytes in buffer 3 starting at offset 12: <pre><code>VDU 23, 0, &amp;A0, 3; 5, &amp;43, 12; 7; 42\n</code></pre></p> <p>Set the byte at offset 12 in the fourth block of buffer 3 to 42: <pre><code>VDU 23, 0, &amp;A0, 3; 5, &amp;12, 12; &amp;80, 4; 42\n</code></pre> This is using operation 2 (Set) with the \"advanced offsets\" modifier (&amp;10).  As BBC BASIC doesn't natively understand how to send 24-bit values it is sent as the 16-bit value <code>12;</code> followed by a byte with its top bit set <code>&amp;80</code> to complete the 24-bit offset in little-endian order.  As the top bit of the offset is set, this indicates that the next 16-bit value will be a block index, <code>4;</code>.  Finally the value to write is sent, <code>42</code>.</p> <p>An operation like this could be used to set the position as part of a draw command.</p> <p>Set the value in buffer 3 at offset 12 to the sum of the five values 1, 2, 3, 4, 5: <pre><code>VDU 23, 0, &amp;A0, 3; 5, 2, 12; 0  : REM clear out the value at offset 12 (set it to 0)\nVDU 23, 0, &amp;A0, 3; 5, &amp;83, 12; 5; 1, 2, 3, 4, 5\n</code></pre></p> <p>AND together 7 bytes in buffer 3 starting at offset 12 with the 7 bytes in buffer 4 starting at offset 42: <pre><code>VDU 23, 0, &amp;A0, 3; 5, &amp;E5, 12; 7; 4; 42;\n</code></pre></p> <p>As we are working on a little-endian system, integers longer than one byte are sent with their least significant byte first.  This means that the add with carry operation can be used to add together integers of any size, so long as they are the same size.  To do this, both the \"multiple target values\" and \"multiple operand values\" modes must be used.</p> <p>The following commands will add together a 16-bit, 24-bit, 32-bit, and 40-bit integers, all targetting the value stored in buffer 3 starting at offset 12, and all using the operand value of 42: <pre><code>VDU 23, 0, &amp;A0, 3; 5, &amp;C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer\nVDU 23, 0, &amp;A0, 3; 5, &amp;C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer\nVDU 23, 0, &amp;A0, 3; 5, &amp;C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer\nVDU 23, 0, &amp;A0, 3; 5, &amp;C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer\n</code></pre> Take note of how the operand value is padded out with zeros to match the size of the target value.  <code>42;</code> is used as a base to send a 16-bit value, with zeros added of either 8-bit or 16-bits to pad it out to the required size.  The \"carry\" value will be stored at the next offset in the target buffer after the complete target value.  So for a 16-bit value, the carry will be stored at offset 14, for a 24-bit value it will be stored at offset 15, and so on.</p>"},{"location":"vdp/Buffered-Commands-API/#command-6-conditionally-call-a-buffer","title":"Command 6: Conditionally call a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]</code></p> <p>This command will conditionally call a buffer if the condition operation passes.  This command works in a similar manner to the \"Adjust buffer contents\" command.</p> <p>With this command a buffer ID of 65535 (-1) is always interpretted as \"current buffer\", and so can only be used within a buffered command sequence.  If used outside of a buffered command sequence then this command will do nothing.</p> <p>The basic set of condition operations are as follows:</p> Operation Description 0 Exists (value is non-zero) 1 Not exists (value is zero) 2 Equal 3 Not equal 4 Less than 5 Greater than 6 Less than or equal 7 Greater than or equal 8 AND 9 OR <p>The value that is being checked is fetched from the specified check buffer ID and offset.  With the exception of \"Exists\" and \"Not exists\", each command requires an operand value to be specified to check against.</p> <p>The operation value used is an 8-bit value that can have bits set to modify the behaviour of the operation.  The following bits are defined:</p> Bit value Description &amp;10 Use advanced offsets &amp;20 Operand is a buffer-fetched value (buffer ID and an offset) <p>These modifiers can be combined together to modify the behaviour of the operation.</p> <p>At this time, unlike with the \"adjust\" command, multiple target values and multiple operand values are not supported.  All comparisons are therefore only conducted on single 8-bit values.  (If comparisons of 16-bit values are required, multiple calls can be combined.)  Support for them may be added in the future.</p> <p>The <code>AND</code> and <code>OR</code> operations are logical operations, and so the operand value is used as a boolean value.  Any non-zero value is considered to be true, and zero is considered to be false.  These operations therefore are most useful when used with buffer-fetched operand values (operations &amp;28, &amp;29, &amp;38 and &amp;39).</p> <p>Some examples of condition operations are as follows:</p> <p>Call buffer 7 if the value in buffer 12 at offset 5 exists (is non-zero): <pre><code>VDU 23, 0, &amp;A0, 7; 6, 0, 12; 5;\n</code></pre></p> <p>Call buffer 8 if the value in buffer 12 at offset 5 does not exist (is zero): <pre><code>VDU 23, 0, &amp;A0, 8; 6, 1, 12; 5;\n</code></pre></p> <p>Combining the above two examples is effectively equivalent to \"if the value exists, call buffer 7, otherwise call buffer 8\": <pre><code>VDU 23, 0, &amp;A0, 7; 6, 0, 12; 5;\nVDU 23, 0, &amp;A0, 8; 6, 1, 12; 5;\n</code></pre></p> <p>Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42: <pre><code>VDU 23, 0, &amp;A0, 3; 6, 2, 4; 12; 42\n</code></pre></p> <p>Call buffer 5 if the value in buffer 2 at offset 7 is less than the value in buffer 2 at offset 8: <pre><code>VDU 23, 0, &amp;A0, 5; 6, &amp;24, 2; 7; 2; 8;\n</code></pre></p>"},{"location":"vdp/Buffered-Commands-API/#command-7-jump-to-a-buffer","title":"Command 7: Jump to a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 7</code></p> <p>This command will jump to the buffer with the given ID.  If the buffer does not exist, or is empty, then this command will do nothing.</p> <p>This essentially works the same as the call command (command 1), except that it does not return to the caller.  This command is therefore useful for creating loops.</p> <p>Using this command to jump to buffer 65535 (buffer ID -1) is treated as a \"jump to end of current buffer\".  This will return execution to the caller, and can be useful for exiting a loop.</p>"},{"location":"vdp/Buffered-Commands-API/#command-8-conditional-jump-to-a-buffer","title":"Command 8: Conditional Jump to a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]</code></p> <p>This command operates in a similar manner to the \"Conditionally call a buffer\" command (command 6), except that it will jump to the buffer if the condition operation passes.</p> <p>As with the \"Jump to a buffer\" command (command 7), a jump to buffer 65535 is treated as a \"jump to end of current buffer\".</p>"},{"location":"vdp/Buffered-Commands-API/#command-9-jump-to-an-offset-in-a-buffer","title":"Command 9: Jump to an offset in a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]</code></p> <p>This command will jump to the given offset in the buffer with the given ID.  If the buffer does not exist, or is empty, then this command will do nothing.</p> <p>The offset in this command is always an \"advanced\" offset, given as a 24-bit value in little-endian order.  As with other uses of advanced offsets, if the top-bit is set in the high byte of the offset value, a block number must also be provided.</p> <p>When jumping to an offset, using buffer ID 65535 is treated as meaning \"jump within current buffer\".  This can be useful for creating loops within a buffer, or when building up command sequences that may be copied across multiple buffers.</p> <p>Jumping to an offset that is beyond the end of the buffer is equivalent to jumping to the end of the buffer.</p>"},{"location":"vdp/Buffered-Commands-API/#command-10-conditional-jump-to-an-offset-in-a-buffer","title":"Command 10: Conditional jump to an offset in a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]</code></p> <p>A conditional jump with an offset works in a similar manner to the \"Conditional call a buffer\" command (command 6), except that it will jump to the given offset in the buffer if the condition operation passes.</p> <p>As with the \"Jump to an offset in a buffer\" command (command 9), the offset in this command is always an \"advanced\" offset, given as a 24-bit value in little-endian order, and the usual advanced offset rules apply.  And similarly, using buffer ID 65535 is treated as meaning \"jump within current buffer\".</p>"},{"location":"vdp/Buffered-Commands-API/#command-11-call-buffer-with-an-offset","title":"Command 11: Call buffer with an offset","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]</code></p> <p>Works just like \"Call a buffer\" (command 1), except that it also accepts an advanced offset.</p>"},{"location":"vdp/Buffered-Commands-API/#command-12-conditional-call-buffer-with-an-offset","title":"Command 12: Conditional call buffer with an offset","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]</code></p> <p>Works just like the \"Conditional call a buffer\" command (command 6), except that it also accepts an advanced offset.</p>"},{"location":"vdp/Buffered-Commands-API/#command-13","title":"Command 13: Copy blocks from multiple buffers into a single buffer","text":"<p><code>VDU 23, 0, &amp;A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;</code></p> <p>This command will copy the contents of multiple buffers into a single buffer.  The buffers to copy from are specified as a list of buffer IDs, terminated by a buffer ID of -1 (65535).  The buffers are copied in the order they are specified.</p> <p>This is a block-wise copy, so the blocks from the source buffers are copied into the target buffer.  The blocks are copied in the order they are found in the source buffers.</p> <p>The target buffer will be overwritten with the contents of the source buffers.  This will not be done however until after all the data has been gathered and copied.  The target buffer can therefore included in the list of the source buffers.</p> <p>If a source buffer that does not exist is specified, or a source buffer that is empty is specified, then that buffer will be ignored.  If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.</p> <p>The list of source buffers can contain repeated buffer IDs.  If a buffer ID is repeated, then the blocks from that buffer will be copied multiple times into the target buffer.</p> <p>If there is insufficient memory available on the VDP to complete this command then it will fail, and the target buffer will be left unchanged.</p>"},{"location":"vdp/Buffered-Commands-API/#command-14-consolidate-blocks-in-a-buffer","title":"Command 14: Consolidate blocks in a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 14</code></p> <p>Takes all the blocks in a buffer and consolidates them into a single block.  This is useful for bitmaps, as it allows for a bitmap to be built up over time in multiple blocks, and then consolidated into a single block for use as a bitmap.</p> <p>If there is insufficient memory available on the VDP to complete this command then it will fail, and the buffer will be left unchanged.</p>"},{"location":"vdp/Buffered-Commands-API/#command-15-split-a-buffer-into-multiple-blocks","title":"Command 15: Split a buffer into multiple blocks","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 15, blockSize;</code></p> <p>Splits a buffer into multiple blocks.  The <code>blockSize</code> parameter is a 16-bit integer that specifies the target size of each block.  If the source data is not a multiple of the block size then the last block will be smaller than the specified block size.</p> <p>If this command is used on a buffer that is already split into multiple blocks, then the blocks will be consolidated first, and then re-split into the new block size.</p> <p>If there is insufficient memory available on the VDP to complete this command then it will fail, and the buffer will be left unchanged.</p>"},{"location":"vdp/Buffered-Commands-API/#command-16-split-a-buffer-into-multiple-blocks-and-spread-across-multiple-buffers","title":"Command 16: Split a buffer into multiple blocks and spread across multiple buffers","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;</code></p> <p>Splits a buffer into multiple blocks, as per command 15, but then spreads the resultant blocks across the target buffers.  The target buffers are specified as a list of buffer IDs, terminated by a buffer ID of -1 (65535).  </p> <p>The blocks are spread across the target buffers in the order they are specified, and the spread will loop around the buffers until all the blocks have been distributed.  The target buffers will be cleared out before the blocks are spread across them.</p> <p>What this means is that if the source buffer is, let's say, 100 bytes in size and we split using a block size of 10 bytes then we will end up with 10 blocks.  If we then spread those blocks across 3 target buffers, then the first buffer will contain blocks 1, 4, 7 and 10, the second buffer will contain blocks 2, 5 and 8, and the third buffer will contain blocks 3, 6 and 9.</p> <p>This command attempts to ensure that, in the event of insufficient memory being available on the VDP to complete the command, it will leave the targets as they were before the command was executed.  However this may not always be possible.  The first step of this command is to consolidate the source buffer into a single block, and this may fail from insufficient memory.  If that happens then all the buffers will be left as they were.  After this however the target buffers will be cleared.  If there is insufficient memory to successfully split the buffer into multiple blocks then the call will exit, and the target buffers will be left empty.</p>"},{"location":"vdp/Buffered-Commands-API/#command-17-split-a-buffer-and-spread-across-blocks-starting-at-target-buffer-id","title":"Command 17: Split a buffer and spread across blocks, starting at target buffer ID","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 17, blockSize; targetBufferId;</code></p> <p>As per the above two commands, this will split a buffer into multiple blocks.  It will then spread the blocks across buffers starting at the target buffer ID, incrementing the target buffer ID until all the blocks have been distributed.</p> <p>Target blocks will be cleared before a block is stored in them.  Each target will contain a single block.  The exception to this is if the target buffer ID reaches 65534, as it is not possible to store a block in buffer 65535.  In this case, multiple blocks will be placed into buffer 65534.</p> <p>With this command if there is insufficient memory available on the VDP to complete the command then it will fail, and the target buffers will be left unchanged.</p>"},{"location":"vdp/Buffered-Commands-API/#command-18-split-a-buffer-into-blocks-by-width","title":"Command 18: Split a buffer into blocks by width","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 18, width; blockCount;</code></p> <p>This command splits a buffer into a given number of blocks by first of all splitting the buffer into blocks of a given width (number of bytes), and then consolidating those blocks into the given number of blocks.</p> <p>This is useful for splitting a bitmap into a number of separate columns, which can then be manipulated individually.  This can be useful for dealing with sprite sheets.</p>"},{"location":"vdp/Buffered-Commands-API/#command-19-split-by-width-into-blocks-and-spread-across-target-buffers","title":"Command 19: Split by width into blocks and spread across target buffers","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;</code></p> <p>This command essentially operates the same as command 18, but the block count is determined by the number of target buffers specified.  The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.</p>"},{"location":"vdp/Buffered-Commands-API/#command-20-split-by-width-into-blocks-and-spread-across-blocks-starting-at-target-buffer-id","title":"Command 20: Split by width into blocks and spread across blocks starting at target buffer ID","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 20, width; blockCount; targetBufferId;</code></p> <p>This command essentially operates the same as command 18, but the generated blocks are spread across blocks starting at the target buffer ID, as per command 17.</p>"},{"location":"vdp/Buffered-Commands-API/#command-21-spread-blocks-from-a-buffer-across-multiple-target-buffers","title":"Command 21: Spread blocks from a buffer across multiple target buffers","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;</code></p> <p>Spreads the blocks from a buffer across multiple target buffers.  The target buffers are specified as a list of buffer IDs, terminated by a buffer ID of -1 (65535).  The blocks are spread across the target buffers in the order they are specified, and the spread will loop around the buffers until all the blocks have been distributed.</p> <p>It should be noted that this command does not copy the blocks, and nor does it move them.  Unless the source buffer has been included in the list of targets, it will remain completely intact.  The blocks distributed across the target buffers will point to the same memory as the blocks in the source buffer.  Operations to modify data in the source buffer will also modify the data in the target buffers.  Clearing the source buffer however will not clear the target buffers.</p>"},{"location":"vdp/Buffered-Commands-API/#command-22-spread-blocks-from-a-buffer-across-blocks-starting-at-target-buffer-id","title":"Command 22: Spread blocks from a buffer across blocks starting at target buffer ID","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 22, targetBufferId;</code></p> <p>Spreads the blocks from a buffer across blocks starting at the target buffer ID.</p> <p>This essentially works the same as command 21, and the same notes about copying and moving blocks apply.  Blocks are spread in the same manner as commands 17 and 20.</p>"},{"location":"vdp/Buffered-Commands-API/#command-23-reverse-the-order-of-blocks-in-a-buffer","title":"Command 23: Reverse the order of blocks in a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 23</code></p> <p>Reverses the order of the blocks in a buffer.</p>"},{"location":"vdp/Buffered-Commands-API/#command-24-reverse-the-order-of-data-of-blocks-within-a-buffer","title":"Command 24: Reverse the order of data of blocks within a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 24, options, [valueSize;] [chunkSize;]</code></p> <p>Reverses the order of the data within the blocks of a buffer.  The <code>options</code> parameter is an 8-bit value that can have bits set to modify the behaviour of the operation.  The following bits are defined:</p> Bit value Description 1 Values are 16-bits in size 2 Values are 32-bits in size 3 (1+2) If both value size bits are set, then the value size is sent as a 16-bit value 4 Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value 8 Reverse blocks <p>These modifiers can be combined together to modify the behaviour of the operation.</p> <p>If no value size is set in the options (i.e. the value of the bottom two bits of the options is zero) then the value size is assumed to be 8-bits.</p> <p>It is probably easiest to understand what this operation is capable of by going through some examples of how it can be used to manipulate bitmaps.  The VDP supports two different formats of color bitmap, either RGBA8888 which uses 4-bytes per pixel, i.e. 32-bit values, or RGBA2222 which uses a single byte per pixel.</p> <p>The simplest example is rotating an RGBA2222 bitmap by 180 degrees, which can be done by just reversing the order of bytes in the buffer: <pre><code>VDU 23, 0, &amp;A0, bufferId; 24, 0\n</code></pre></p> <p>Rotating an RGBA8888 bitmap by 180 degrees is in principle a little more complex, as each pixel is made up of 4 bytes.  However with this command it is still a simple operation, as we can just reverse the order of the 32-bit values that make up the bitmap by using an options value of <code>2</code>: <pre><code>VDU 23, 0, &amp;A0, bufferId; 24, 2\n</code></pre></p> <p>Mirroring a bitmap around the x-axis is a matter of reversing the order of rows of pixels.  To do this we can set a custom value size that corresponds to our bitmap width.  For an RGBA2222 bitmap we can just set a custom value size to our bitmap width: <pre><code>VDU 23, 0, &amp;A0, bufferId; 24, 3, width\n</code></pre></p> <p>As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply our width by 4: <pre><code>VDU 23, 0, &amp;A0, bufferId; 24, 3, width * 4\n</code></pre></p> <p>To mirror a bitmap around the y-axis, we need to reverse the order of pixels within each row.  For an RGBA2222 bitmap we can just set a custom chunk size to our bitmap width: <pre><code>VDU 23, 0, &amp;A0, bufferId; 24, 4, width\n</code></pre></p> <p>For an RGBA8888 bitmap we need to set our options to indicate 32-bit values as well as a custom chunk size: <pre><code>VDU 23, 0, &amp;A0, bufferId; 24, 6, width * 4\n</code></pre></p>"},{"location":"vdp/Buffered-Commands-API/#command-25-copy-blocks-from-multiple-buffers-by-reference","title":"Command 25: Copy blocks from multiple buffers by reference","text":"<p><code>VDU 23, 0, &amp;A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;</code></p> <p>This command is essentially a version of command 13 that copies blocks by reference rather than by value.  The parameters for this command are the same as for command 13, and the same rules apply.</p> <p>If the target buffer is included in the list of source buffers then it will be skipped to prevent a reference loop.</p> <p>Copying by reference means that the blocks in the target buffer will point to the same memory as the blocks in the source buffers.  Operations to modify data blocks in the source buffers will therefore also modify those blocks in the target buffer.  Clearing the source buffers will not clear the target buffer - it will still point to the original data blocks.  Data blocks are only freed from memory when no buffers are left with any references to them.</p> <p>Buffers that get consolidated become new blocks, so will lose their links to the original blocks, thus after a \"consolidate\" operation modifications to the original blocks will no longer be reflected in the consolidated buffer.</p> <p>This command is useful to construct a single buffer from multiple sources without the copy overhead, which can be costly.  For example, this can be useful for constructing a bitmap from multiple constituent parts before consolidating it into a single block.  In such an example, using command 13 instead would first make a copy of the contents of the source buffers, and then consolidate them into a single block.  Using this command does not make that first copy, and so would be faster.</p> <p>This command is also useful for creating multiple buffers that all point to the same data.</p>"},{"location":"vdp/Buffered-Commands-API/#command-26-copy-blocks-from-multiple-buffers-and-consolidate","title":"Command 26: Copy blocks from multiple buffers and consolidate","text":"<p><code>VDU 23, 0, &amp;A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;</code></p> <p>This command is similar to performing a \"copy\" operation followed by a \"consolidate\" operation, and thus has similar behaviour to command 13 and/or command 25.  The parameters for this command are the same as for command 25.  As with command 25, you cannot include the target buffer in the list of source buffers.  If you do, then it will be skipped.</p> <p>This command will replace the target buffer with a new buffer that contains a single block that is the result of consolidating the blocks from the source buffers.  If the target buffer already contains a single block of the same size as the source buffers then it will re-use the memory, and so will be faster than performing a separate \"copy by reference\" and \"consolidate\" operation.</p> <p>It is useful for contructing a single buffer from multiple sources, such as for constructing a bitmap from multiple constituent parts.</p>"},{"location":"vdp/Buffered-Commands-API/#command-64-compress-a-buffer","title":"Command 64: Compress a buffer","text":"<p><code>VDU 23, 0, &amp;A0, targetBufferId; 64, sourceBufferId;</code></p> <p>This command will compress the contents of a buffer, replacing the target buffer with the compressed data.  Unless the target buffer is the same as the source, the source buffer will be left unchanged.</p>"},{"location":"vdp/Buffered-Commands-API/#command-65-decompress-a-buffer","title":"Command 65: Decompress a buffer","text":"<p><code>VDU 23, 0, &amp;A0, targetBufferId; 65, sourceBufferId;</code></p> <p>This command will decompress the contents of a buffer, replacing the target buffer with the decompressed data.  Unless the target buffer is the same as the source, the source buffer will be left unchanged.</p> <p>The source buffer must contain a complete set of compressed data, but need not be in a single block.  The decompressed data will be stored in a single block in the target buffer.</p> <p>Using this command, data can be sent from MOS in a compressed form, and then decompressed on the VDP.  This can be useful for sending large amounts of data over to the VDP, as it can reduce the amount of data that needs to be sent.</p> <p>The compression algorithm supported by this command and the corresponding \"compress\" command is \"TurboVega-style\" compression.  Source code for the compression and decompression routines and tools to use them on other systems can be found in the TurboVega agon_compression repository.</p>"},{"location":"vdp/Buffered-Commands-API/#examples","title":"Examples","text":"<p>What follows are some examples of how the VDP Buffered Commands API can be used to perform various tasks.</p>"},{"location":"vdp/Buffered-Commands-API/#loading-a-sample","title":"Loading a sample","text":"<p>Sound sample files can be large, and so it is not practical to send them over to the VDP in a single packet.  Even with optimised machine code, it could take several seconds to send a single sample over to the VDP.  This would block the screen, and make it impossible to show progress to the user.  Using the VDP Buffered Commands API we can send a sample over to the VDP in multiple packets.</p> <p>The following example will load a sound sample from a file called <code>sound.bin</code> and send it over to the VDP.  Lines 10-50 prepare things, opening up the file and getting its length.  Line 70 clears out buffer 42 so it is ready to store the sample.  The loop from lines 90 to 170 sends the sample one block at a time, adding the sample data to buffer 42.  Finally, lines 200-220 creates the sample, sets channel 1 to use it, and then plays it.</p> <pre><code> 10 blockSize% = 1000\n 20 infile% = OPENIN \"sound.bin\"\n 30 length% = EXT#infile%\n 40 PRINT \"Sound sample length: \"; length%; \"bytes\"\n 50 remaining% = length%\n 60 REM Load sample data into buffer 42\n 70 VDU 23, 0, &amp;A0, 42; 2       : REM Clear out buffer 42\n 80 PRINT \"Loading sample\";\n 90 REPEAT\n100   IF remaining% &lt; blockSize% THEN blockSize% = remaining%\n110   remaining% = remaining% - blockSize%\n120   PRINT \".\";       : REM Show progress\n130   VDU 23, 0, &amp;A0, 42; 0, blockSize%; : REM Send next blockSize% bytes to buffer 42\n140   FOR i% = 1 TO blockSize%\n150     VDU BGET#infile%\n160   NEXT\n170 UNTIL remaining% = 0\n180 CLOSE #infile%\n190 REM Set buffer 42 to be an 8-bit unsigned sample\n200 VDU 23, 0, &amp;85, 1, 5, 2, 42; 1     : REM Channel is ignored in this command\n210 VDU 23, 0, &amp;85, 1, 4, 8, 42;       : REM Set sample for channel 1 to buffer 42\n220 VDU 23, 0, &amp;85, 1, 0, 100, 750; length% DIV 16;  : REM Play sample on channel 1\n</code></pre> <p>Please note that the BASIC code here is not fast, owing to the fact that it has to read the sample file one byte at a time.  This is because BBC BASIC does not provide a way to read a chunk of a file at once.  This is not a limitation of the VDP Buffered Commands API, but rather of BBC BASIC.</p> <p>This can be optimised by writing a small machine code routine to read a chunk of a file at once, and then calling that from BASIC.  This is left as an exercise for the reader.</p> <p>Whilst this example illustrates loading a sample, it is easily adaptable to loading in a bitmap.</p>"},{"location":"vdp/Buffered-Commands-API/#repeating-a-command","title":"Repeating a command","text":"<p>This example will print out \"Hello \" 20 times.</p> <p>This is admitedly a contrived example, as there is an obvious way to achieve what this code does in plain BASIC, but it is intended to illustrate the API.  The technique used here can be fairly easily adapted to more complex scenarios.</p> <p>This example uses three buffers.  The first buffer is used to print out a string.  The second buffer is used to store a value that will be used to control how many times the string printing buffer is called.  The third buffer is used to call the string printing buffer the required number of times, and is gradually built up.</p> <pre><code> 10 REM Clear the buffers we're going to use (1-3)\n 20 VDU 23, 0, &amp;A0, 1; 2       : REM Clear out buffer 1\n 30 VDU 23, 0, &amp;A0, 2; 2       : REM Clear out buffer 2\n 40 VDU 23, 0, &amp;A0, 3; 2       : REM Clear out buffer 3\n 50 VDU 23, 0, &amp;A0, 1; 0, 6;   : REM Send the next 6 bytes to buffer 1\n 60 PRINT \"Hello \";            : REM The print will be captured into buffer 1\n 70 REM Create a writable buffer with ID 2, 1 byte long for our iteration counter\n 80 VDU 23, 0, &amp;A0, 2; 3, 1;\n 90 REM set our iteration counter to 20 - adjust (5), set value (2), offset 0, value 20\n100 VDU 23, 0, &amp;A0, 2; 5, 2, 0; 20\n110 REM gradually build up our command buffer in buffer 3\n120 VDU 23, 0, &amp;A0, 3; 0, 6;   : REM 6 bytes for the following \"call\" command\n130 VDU 23, 0, &amp;A0, 1; 1       : REM Call buffer 1 to print \"Hello \"\n140 VDU 23, 0, &amp;A0, 3; 0, 10;  : REM 10 bytes for the following \"adjust\" command\n150 REM Decrement the iteration counter in buffer 2\n160 VDU 23, 0, &amp;A0, 2; 5, 3, 0; -1\n170 VDU 23, 0, &amp;A0, 3; 0, 11;  : REM 11 bytes for the following \"conditional call\" command\n180 REM If the iteration counter is not zero, then call buffer 3 again\n190 VDU 23, 0, &amp;A0, 3; 6, 0, 2; 0;\n200 REM That's all the commands for buffer 3\n210 REM Now call buffer 3 to execute those commands\n220 VDU 23, 0, &amp;A0, 3; 1\n</code></pre> <p>It should be noted that after this code has been run the iteration counter in buffer ID 2 will have been reduced to zero.  Calling buffer 3 again at that point will result in the counter looping around to 255 on its first decrement, and then counting down from there, so you will see the loop run 256 times.  To avoid this, the iteration counter in buffer 2 should be reset to the desired value before calling buffer 3 again.</p> <p>Another thing to note is that if there were any additional commands added to buffer 3 beyond the final conditional call then it is likely that the VDP would crash, which is obviously not ideal.  This would happen because the call stack depth (i.e. number of \"calls within a call\") will have become too deep, and the command interpretter inside the VDP will have run out of memory.  This code works as-is because the conditional call is the last command in buffer 3 the VDP uses a method called \"tail call optimisation\" to avoid having to return to the caller.  The call is automatically turned into a \"jump\".  This is a technique that is used in many programming languages, and is a useful technique to be aware of.</p> <p>A safer way to write this code would be to use a conditional jump (command 8) rather than a conditional call.  This would avoid the call stack depth issue, and allow additional commands to be placed in buffer 3 after that jump.</p> <p>As a very simple example, you can imagine replacing buffer 1 with a buffer that draws something to the screen.  Those drawing calls could use relative positioning, allowing for repeated patterns to be drawn.  It could indeed do anything.  The point here is just to illustrate the technique.</p>"},{"location":"vdp/Buffered-Commands-API/#a-simplistic-reset-all-audio-channels-example","title":"A simplistic \"reset all audio channels\" example","text":"<p>Sometimes you will just want the ability to very quickly call a routine to perform a bulk action.  One potential example of this is to reset all audio channels to their default state (default waveform, and remove any envelopes that may have been applied).  The audio API provides a call to reset individual channels, but there is no call to reset them all.</p> <pre><code> 10 REM Clear the buffer we're going to use\n 20 resetAllChannels% = 7\n 30 VDU 23, 0, &amp;A0, resetAllChannels%; 2       : REM Clear out buffer\n 40 FOR channel = 0 TO 31\n 50   VDU 23, 0, &amp;A0, resetAllChannels%; 0, 5; : REM 5 bytes for the following \"reset channel\" command\n 60   VDU 23, 0, &amp;85, channel, 10\n 70 NEXT\n 80 REM Call the clear command\n 90 VDU 23, 0, &amp;A0, resetAllChannels%; 1\n</code></pre> <p>In this example we take a simplistic approach to building up a command that will reset all the audio channels.  The nature of the Audio API is that one can ask any channel to be reset, even if it has not been enabled, so we can just loop through all 32 potential channels.  An alternative approach could have been to disable all the channels and then enable a default number of channels.</p> <p>Once a command buffer has been sent it will remain on the VDP until that buffer is cleared.  This means that the <code>VDU 23, 0, &amp;A0, clearCommand%; 1</code> call can be made many times.  This can be useful if you wanted to reset all the audio channels at the start of a game loop, for instance.</p> <p>It is possible to write a more sophisticated version of this example that would use a loop on the VDP, rather than relying on sending multiple \"reset channel\" commands.  That would require the use of a few more buffers.  The reality of this approach however is that it is significantly more complex to accomplish and require quite a lot more BASIC code.  Since there is a lot of available free memory on the VDP for storing commands, it is not necessary to be overly concerned about the number of commands sent, so often a simpler approach such as the one in this example is on balance the better option.</p>"},{"location":"vdp/Buffered-Commands-API/#other-ideas-techniques-and-principles","title":"Other ideas, techniques, and principles","text":"<p>The examples above are intended to illustrate some of the principles of how the VDP Buffered Commands API can be used.  They are not intended to be complete solutions or illustrations of what is possible.</p>"},{"location":"vdp/Buffered-Commands-API/#stack-depth","title":"Stack depth","text":"<p>It should be noted that the VDP does not have a very deep call stack, and so it is possible to run out of stack space if you have a large number of nested calls.  (At the time of writing, the depth limit appears to be in the region of 20 calls.  For those that don't understand what \"stack depth\" means, an example of this would be calling buffer 1, which in turn calls buffer 2, which in turn calls buffer 3 and so on, up to calling buffer 20.)  If the depth limit is exceeded, the VDP will crash, and you will need to press the reset button.</p> <p>As noted above in the \"repeat\" example, the VDP will use a technique called \"tail call optimisation\" to help avoid/mitigate this issue.  This is where a call is automatically turned into a \"jump\" if it is the last command in a buffer.  This avoids the need to return to the caller, removing the need to start a new VDU command interpreter, and so avoids the call stack depth issue.</p> <p>Often the stack depth issue can be avoided by using a \"jump\" command rather than a \"call\" command (as this also does not need to start a new VDU command interpreter).  A jump differs from a call in that it just changes the command sequence being executed, and does not keep track of where it was being called from.</p> <p>The down-side of using a jump is that over-use of jumps can result in \"spaghetti code\", which can be difficult to follow.  It is therefore recommended to use jumps sparingly, and to use calls where possible.</p>"},{"location":"vdp/Buffered-Commands-API/#using-many-buffers","title":"Using many buffers","text":"<p>The API makes use of 16-bit buffer ID to allow a great deal of freedom.  Buffer IDs do not have to be used sequentially, so you are free to use whatever buffer IDs you like.  It is suggested that you can plan out different ranges of buffer IDs for your own uses.  For example, you could decide to use buffer IDs &amp;100-&amp;1FF for sprite management, &amp;200-&amp;2FF for sound management, &amp;400-&amp;4FF for data manipulation.  This is entirely up to you.</p> <p>Command buffers can be as short, or as long, as you like.  Often it will be easier to have many short buffers in order to allow for sophisticated behaviour.</p> <p>The VDP also has significantly more free memory available for storing commands and data than the eZ80 does, so it is not really necessary to be overly concerned about the number of commands sent.  (Currently there is 4 megabytes of free memory available on the VDP for storing commands, sound samples, and bitmaps.  The memory attached to the VDP is actually an 8 megabyte chip, and a later version of the VDP software may allow for even more of that to be used.)</p>"},{"location":"vdp/Buffered-Commands-API/#self-modifying-code","title":"Self-modifying code","text":"<p>A technique that was fairly common in the era of 8-bit home computers was to use self-modifying code.  This is where a program would modify its own code in order to achieve some effect.  The VDP Buffered Commands API allows for this technique to be used via the \"adjust buffer contents\" command.  For example this could be used to adjust the coordinates that are part of a command sequence to draw a bitmap, allowing for a bitmap to be drawn at different locations on the screen.</p>"},{"location":"vdp/Buffered-Commands-API/#jump-tables","title":"Jump tables","text":"<p>There are a number of ways to implement jump tables using the VDP Buffered Commands API.</p> <p>One such example would be to allocate a range of buffer IDs for use as jump table entries, and to use the \"adjust buffer\" command to change the lower byte of the buffer ID on a \"jump\" or \"call\" command (or a \"conditional\" version) to point to the buffer ID of the jump table entry.</p> <p>An alternative way could be to use \"jump with offset\" command with an advanced offset, specifying a block within a buffer to jump to, and adjusting that block as needed.  This would allow for a jump table to be built up within a single buffer.</p>"},{"location":"vdp/Buffered-Commands-API/#using-the-output-stream","title":"Using the output stream","text":"<p>Some VDU commands will send response packets back to MOS running on the eZ80.  These packets can be captured by using the \"set output stream\" command.  This can be used to capture the response packets from a command.</p> <p>When you have a captured response packet, the contents of the buffer can be examined to determine what the response was.  Values can be extracted from the buffer using the \"adjust buffer contents\" command and used to modify other commands.</p> <p>For example, you may wish to find out where the text cursor position is on screen and then use that information to work out whether the text cursor should be moved before printing new output.</p> <p>Care needs to be taken when using \"set output stream\" to ensure that the sequence of commands you're using doesn't create more response packets than you are expecting.  It is usually best to use this command within a buffered command sequence, as that will ensure that the output stream is reset to its original value once the buffered command sequence has completed.</p> <p>If you are using this command as part of a longer sequence it is recommended to use the \"set output stream\" command to reset the output stream to its original value (by using a buffer ID of 0) once you have captured the response packet you are interested in.</p> <p>Please note that at present the number of commands that send response packets is currently very limited, and so this technique is not as useful as it could be.  This will likely change in the future.</p> <p>Also to note here is that response packets will be written sequentially to the output stream.  There is no mechanism to control where in the output stream a response packet is written.  This means that if you are capturing response packets, you will need to be careful to ensure that the response packets you are interested in are not interleaved with other response packets that you are not interested in.  Clearing and re-creating a buffer before capturing response packets is recommended.</p>"},{"location":"vdp/Buffered-Commands-API/#use-your-imagination","title":"Use your imagination!","text":"<p>As can be seen, by having command sequences that can adjust the contents of buffers, and conditionally call other command sequences, it is possible to build up quite sophisticated behaviour.  You effectively have a programmable computer within the VDP.</p> <p>It is up to your imagination as to how exactly the API can be used.</p>"},{"location":"vdp/Context-Management-API/","title":"VDU 23, 0, &amp;C8: Context Management API","text":"<p>As of Console8 VDP 2.8.0 the VDP now has the ability to create and manage different graphical contexts.  This allows you to easily switch between different settings for drawing text and graphics on the VDP, and to save and restore these settings as needed.</p> <p>Almost all settings related to the text and graphics system are stored in the context.  These include things like the currently selected fonts for the text and graphics cursors, text cursor behaviour, position and display settings, the active cursor (whether the context is in <code>VDU 4</code> or <code>VDU 5</code> mode), the selected graphics coordinate system and last graphics cursor positions, the currently selected font, viewports, GCOL painting mode, the selected bitmap, and so on.</p> <p>The only graphical things that do not change with the context are things that should be considered \"global\" in nature.  That includes the contents of buffers and graphical items that make use of buffers, such as bitmaps and font definitions.  Sprites are also \"global\" in nature.  Additionally data related to the current screen mode and the system palette are global across all contexts.</p> <p>Changing the screen mode will reset the graphics system.  All saved contexts will be lost, and the current context stack cleared.</p>"},{"location":"vdp/Context-Management-API/#context-concepts","title":"Context concepts","text":"<p>There are two important concepts to understand when working with contexts, specifically the idea of a \"context stack\", and the idea of selecting a different context stack.</p>"},{"location":"vdp/Context-Management-API/#context-stacks","title":"Context Stacks","text":"<p>At any time you can choose to save the current graphics sytem state (context) to the context stack, or restore the last saved context from the stack.</p> <p>This allows for a simple way to save the current graphics system state, make temporary changes, and then step back to that previous state.</p> <p>This is a common concept in graphics programming APIs.  For example, in the HTML5 web canvas API, you can save the current state of the canvas, make changes, and then restore the previous state.  Similarly Apple's Core Graphics API has the same concept concept.</p> <p>You will always have an active context, and a context stack.</p>"},{"location":"vdp/Context-Management-API/#selecting-a-different-context-stack","title":"Selecting a Different Context Stack","text":"<p>The context management API also provides a way to select completely different context stacks.</p> <p>This can be useful if you want to have completely different sets of settings for different areas of your program, or applying to drawing different parts of the screen.</p>"},{"location":"vdp/Context-Management-API/#the-api","title":"The API","text":"<p>The API to manage contexts is relatively simple, and consists of the following commands:</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-0-contextid-select-context-stack","title":"<code>VDU 23, 0, &amp;C8, 0, contextId</code>: Select context stack","text":"<p>This command will select a different context stack to use.</p> <p>If there is no context stack with the given <code>contextId</code>, a copy of the current context stack will be created and saved to the ID, and the new context stack will be selected.</p> <p>If you wish to explicitly save the current context stack to a <code>contextId</code> you should first delete the context stack and then use this command.</p> <p>Once you have selected a context stack by ID, all subsequent changes to your context stack will be saved against that ID.</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-1-contextid-delete-context-stack","title":"<code>VDU 23, 0, &amp;C8, 1, contextId</code>: Delete context stack","text":"<p>This command will delete the context stack with the given <code>contextId</code>.</p> <p>Please note that deleting a stack from the store will not affect the current context stack, and will not affect the current context.</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-2-flags-reset","title":"<code>VDU 23, 0, &amp;C8, 2, flags</code>: Reset","text":"<p>This command will reset the current context.  It accepts a bitfield of flags to indicate what aspects of the settings should be reset.  Sending a flags value of <code>0</code> will perform the same type of context reset that happens on a screen mode change.</p> <p>The following flags are supported:</p> Bit Description 0 Reset graphics painting options 1 Reset graphics positioning settings, including graphics viewport and coordinate system 2 Reset text painting options 3 Reset text cursor visual settings, including text viewport 4 Reset text cursor behaviour 5 Reset currently selected fonts 6 Reset character to bitmap mappings 7 Reserved for future use <p>These are broad reset options, resetting all settings in the given category to their default values.  More fine-grained control to reset individual settings are available via other VDU commands.</p> <p>When all flags are set to <code>0</code>, this command performs a reset equivalent to changing the screen mode.  The text cursor behaviour and character to bitmap mappings will be left unchanged, as will the selected positioning system.</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-3-save-context","title":"<code>VDU 23, 0, &amp;C8, 3</code>: Save context","text":"<p>This command will save a copy of the current graphics style state to the context stack so you can later revert any changes you make to it using a \"restore\".</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-4-restore-context","title":"<code>VDU 23, 0, &amp;C8, 4</code>: Restore context","text":"<p>This command will restore the last saved context from the context stack.</p> <p>If there are no saved contexts on the stack, this command will do nothing.</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-5-contextid-save-and-select-a-copy-of-a-context","title":"<code>VDU 23, 0, &amp;C8, 5, contextId</code>: Save and select a copy of a context","text":"<p>Saves the current context to the context stack.  If there is a context stack saved with the given <code>contextId</code> then a copy of the most recent context at that <code>contextId</code> will be made and activated, replacing the current context.</p> <p>If there is no context stack with the given <code>contextId</code>, then a copy of the current context will be saved to the stack, and you will be left with the current context.</p> <p>Please note that this does not change the current context stack.</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-6-restore-all","title":"<code>VDU 23, 0, &amp;C8, 6</code>: Restore all","text":"<p>This command is equivalent to calling \"restore\" repeatedly until there are no more saved contexts on the stack.  It reverts back to the first context saved on the current stack.</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-7-clear-stack","title":"<code>VDU 23, 0, &amp;C8, 7</code>: Clear stack","text":"<p>This command will clear all saved contexts from the current context stack.  You will be left with the current context still active, but no history to \"restore\" to.</p>"},{"location":"vdp/Enhanced-Audio-API/","title":"VDP Enhanced Audio API","text":"<p>NB: This is implemented in VDP versions 1.04 and above.</p> <p>The Agon-VDP supports audio commands via <code>VDU 23,0,&amp;85</code>, followed by further data to give the exact command required.</p> <p>The first byte usually indicates the channel, and the second byte the command.</p> <p>Parameters vary in number and meaning depending on the command.  Some parameters are bytes, some are 16-bit values sent as two bytes in little-endian order.  In the documentation below, 16-bit values are shown as <code>value1; value2;</code>, as per BBC BASIC syntax, and bytes as <code>value1, value2, value3, ...</code>.</p> <p>Examples are given in BBC BASIC.</p> <p>A common source of errors when sending commands to the VDP from BASIC via VDU commands is to forget to use a <code>;</code> after a number to indicate a 16-bit value should be sent.  If you see unexpected behaviour from your BASIC code that is the most likely source of the problem.</p> <p>When a command is processed the VDP may send a message back to MOS with the status of that command.  (Generally a return value of <code>1</code> indicates success, and <code>0</code> failure, but there are some exceptions to this, most notably the Status command.  Not all audio comments return a status.)  When the MOS receives an audio command status value it will set the audio bit of the VDP protocol flags to indicate that an audio message has been received.  It also sets two system variable values, <code>sysvar_audioChannel</code> and <code>sysvar_audioSuccess</code> with the results of the command.  <code>sysvar_audioChannel</code> is the channel number, and <code>sysvar_audioSuccess</code> provides the status of that command.  These values can be read using a <code>mos_sysvars</code> API call, or an OSBYTE call from BASIC as documented here.</p> <p>It should be noted that VDP protocol flags are not automatically cleared by MOS, so it is the responsibility of the application to clear the audio bit of the VDP protocol flags before sending a command.  At present there is no way to do this directly from BBC BASIC.</p> <p>The full audio command set supported by the Agon-VDP is as follows:</p>"},{"location":"vdp/Enhanced-Audio-API/#command-0-play-note","title":"Command 0: Play note","text":"<p><code>VDU 23, 0, &amp;85, channel, 0, volume, frequency; duration;</code></p> <p>If the channel is not already busy, this command will play a note on the specified channel.</p> <p>The volume is a value from 0 to 127, where 0 is silent and 127 is full volume.  Values above 127 will be treated as 127.</p> <p>The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.</p> <p>The duration is a 16-bit value specifying in milliseconds the duration of the note to be played.  Specifying a value of -1 (65535) will cause the note to be played indefinitely until the channel is silenced by setting its volume to zero.  Specifying a value of zero will play the note for the duration of the attack and decay phases of any volume envelope set on the channel.  Additionally using a duration of zero on a channel that has been set to playback a sample, the sample will be played for its full duration.  (NB this is the sample duration at the time the play command was called.  Streaming in more data for the sample will not extend the duration of the note.)</p> <p>Returns 1 if the note was successfully queued for playback, or 0 if the channel was already in use.</p> <p>NB attempting to play a note on an inactive channel will return 1, but the note will not be played.  The channel must be active (see the status command) before a note can be played on it.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-1-status","title":"Command 1: Status","text":"<p><code>VDU 23, 0, &amp;85, channel, 1</code></p> <p>Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled.  The bit mask is as follows:</p> Bit Name Meaning 0 Active When set this indicates the channel is in use (has an active waveform) 1 Playing Indicates the channel is actively playing a note, and thus will reject calls to play a new note 2 Indefinite Set if the channel is playing an indefinite duration note 3 Has Volume Envelope Set if the channel has a volume envelope 4 Has Frequency Envelope Set if the channel has a frequency envelope <p>Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.</p> <p>For example, calling this command on a channel that is playing a note with no envelopes set will return a value of 3 (00000011).  A channel with a volume envelope set where playback is in the \"release\" phase of the envelope, and thus is free to play a new note, will return a value of 9 (00001001).  A completely silent channel with no envelopes set returns 0, whereas a silent channel that has a frequency envelope set will return 16 (00010000).</p>"},{"location":"vdp/Enhanced-Audio-API/#command-2-set-volume","title":"Command 2: Set volume","text":"<p><code>VDU 23, 0, &amp;85, channel, 2, volume</code></p> <p>Sets the volume of the specified channel.  The volume is a value from 0 to 127, where 0 is silent and 127 is full volume.  Values over 127 will be treated as 127 (with one exception described later).</p> <p>Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)</p> <p>Using this command provides more direct control over a channel than the play note command.  It can be used to adjust the volume of a channel that is already playing a note.</p> <p>Setting a non-zero volume level on a channel that is silent and not playing a note will cause the channel to play a note at the specified volume for an indefinite duration.  The note will be played at the frequency that was last set on the channel.</p> <p>Setting the volume to zero on a channel that is playing a note will silence the channel.  Whether this also aborts the note playback will depend on the VDP version you are using, and how you have set up the channel.</p> <p>Up to the Console8 VDP 2.4.0 release, setting the volume to zero will always abort note playback on a channel.</p> <p>From Console8 VDP 2.5.0 onwards, for channels that are playing a sample that has not reached the end of playback, setting the volume to zero will allow that sample to continue playing.  Attempting to play a new note on that channel will restart the sample.  Changing the sample will abort playback.  To guarantee stopping sample playback, set the duration to zero.  Behaviour for channels using other waveform types is unchanged.</p> <p>Returns back the volume level set or -1 (255) to indicate a failure.  Attempting to set the volume to -1 (or 255) on Console8 VDP 2.5.0 or later will not attempt to change the volume but instead will just return back the current volume level.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p>"},{"location":"vdp/Enhanced-Audio-API/#special-case-volume-envelope","title":"Special case: Volume envelope","text":"<p>If the channel is actively playing a note with a volume envelope set on the channel then when setting the volume of a channel to zero, rather than silencing the channel immediately, the volume envelope will be allowed to complete (enter its \"release\" phase) before the channel is silenced.  A channel with volume envelope in its \"release\" phase is not considered to be actively playing a note, so during this phase setting the volume to zero will immediately silence the channel.</p> <p>Calling this command on a channel that has an active volume envelope adjusts the base volume level being applied to that envelope.  For more information see the documentation for the volume envelope command.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-3-set-frequency","title":"Command 3: Set frequency","text":"<p><code>VDU 23, 0, &amp;85, channel, 3, frequency;</code></p> <p>Sets the frequency of the specified channel.  The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.</p> <p>Using this command provides more direct control over a channel than the play note command.  It can be used to adjust the frequency of a channel that is already playing a note.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p>"},{"location":"vdp/Enhanced-Audio-API/#special-case-frequency-envelope","title":"Special case: Frequency envelope","text":"<p>If the channel has a frequency envelope set then adjusting the frequency value whilst a note is playing will adjust the base frequency level being applied to that envelope.  For more information see the documentation for the frequency envelope command.</p>"},{"location":"vdp/Enhanced-Audio-API/#special-case-sample-playback","title":"Special case: Sample playback","text":"<p>Adjusting the frequency of a channel that is playing a sample will only result in the playback frequency being adjusted if the sample has been set to be tuneable.  By default samples are not tuneable, and so adjusting the frequency of a channel playing a sample will have no effect.  For more information see the documentation for the sample command.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-4-set-waveform","title":"Command 4: Set waveform","text":"<p><code>VDU 23, 0, &amp;85, channel, 4, waveformOrSample, [bufferId;]</code></p> <p>Sets the waveform type for a channel to use.  The <code>waveformOrSample</code> value is a single byte treated as a signed value.</p> <p>Using a negative value for the waveform indicates that a sample should be used instead.  For more information see the documentation for the sample command.</p> <p>By default a channel is set to use waveform 0 (square wave).</p> <p>Valid waveform values are as follows:</p> Value Waveform 0 Square wave 1 Triangle wave 2 Sawtooth wave 3 Sine wave 4 Noise (simple white noise with no frequency support) 5 VIC Noise (emulates a VIC6561; supports frequency) 8 Sample (specifying a 16-bit buffer ID for sample data) <p>When specifying a waveform type of <code>8</code> for a Sample, the buffer ID for the sample must be sent as the next 16-bit value.  There must be a sample created for the given buffer ID for the command to work, otherwise this command will fail.  Similarly if a negative waveform value is given to indicate a sample then the sample must have been created for the given sample number for the command to work.</p> <p>By default, a sample will ignore the frequency value set on the channel or in the play note command unless the sample has explicitly been set to be tuneable.  Samples will also, by default, automatically loop if the note played is longer than the sample itself, or it is played for an indefinite duration.  The sample will continue to loop until the note is stopped.  This behaviour can be changed with commands documented below.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-sample-management","title":"Command 5: Sample management","text":"<p><code>VDU 23, 0, &amp;85, channelOrSample, 5, sampleCommand, [parameters]</code></p> <p>These commands are used to manage samples on the VDP which can be assigned to a channel as a waveform for playback.</p> <p>Sample data is stored in buffers on the VDP, and can be manipulated using the buffered commands API.</p> <p>When a negative number is used in place of the channel number then the command is referring directly to a sample, rather than a channel.  Samples referenced in this manner are, by default, stored in buffers in the range 64256-64383 (<code>&amp;FB00</code>-<code>&amp;FB7F</code>).  To map a negative sample number to a buffer range, you need to negate it, subtract 1, and then add it to 64256.  This means sample number -1 is stored in buffer 64256, -2 is stored in buffer 64257, and so on.  Any buffer however can be used for sample data, using commands listed below that explicitly reference a buffer ID.</p> <p>Sample commands will return 1 if the command is processed successfully, or 0 to indicate a failure.</p> <p>Sample commands 5, 3 and above were added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-0-load-sample","title":"Command 5, 0: Load sample","text":"<p><code>VDU 23, 0, &amp;85, sample, 5, 0, length; lengthHighByte, &lt;sampleData&gt;</code></p> <p>This command is used to transfer a sample over to the VDP for later playback.</p> <p>As sample data can be long, rather than using this command, you are advised instead to upload your sample data to a buffer on the VDP in multiple blocks using the buffered commands API and then use command 5, 2 (documented below) to indicate that the data within a buffer is a sound sample.  That approach also allows for the use of different formats of sample data.</p> <p>When using this command, the sample data is assumed to be 8-bit signed PCM samples at 16kHz.  The sample data is sent as a series of bytes of the given length.</p> <p>The length provided to this command is a 24-bit value, sent in little-endian order.  It has been documented above as a 16-bit value followed by an 8-bit value for simplicity and/or compatibility with BBC BASIC.  Using a 24-bit length gives us the flexibility to support samples larger than 64kB.</p> <p>Specifying a sample number that has already been used will overwrite the existing sample with the new sample data, deleting all data contained within the corresponding buffer.  If the existing sample had been assigned to a channel for playback then playback will be stopped and the channel will be set to use the default waveform (square wave).</p> <p>A simple example of how to send a sample to the VDP using this command is as follows:</p> <pre><code> 10 REM Load a sample into the VDP\n 20 infile=OPENIN \"sample.raw\"\n 30 length=EXT#infile\n 40 REM Send sample info to the VDP for sample -1\n 50 VDU 23, 0, &amp;85, -1, 5, 0, length MOD 256, length DIV 256, length DIV 65536\n 60 REM Send sample data to the VDP\n 70 REPEAT\n 80   VDU BGET#infile\n 90 UNTIL EOF#infile\n100 CLOSE#infile\n110 REM Set channel 1 to use sample -1\n120 VDU 23, 0, &amp;85, 1, 4, -1\n130 REM Play sample on channel 1\n140 SOUND 1, -10, 10, length / 50\n</code></pre> <p>NB This example can be very slow as it sends the sample data byte-by-byte, taking just over 1s to send 2kb of data.  During this time your computer will be unresponsive, and it is not possible to output to screen any kind of progress as any such <code>PRINT</code> command will be interpretted as part of the sample data.  Unfortunately at present there is no way to send data in bulk to the VDP from BBC BASIC, or to read chunks of files into memory in one go.  For faster transfer of sample data you will need to write a program in assembly language and make use of file access APIs from MOS and the RST #18 vector to send larger chunks of data to the VDP.</p> <p>The VDP Buffered Commands API provides an alternative example of sending sample data to the VDP which allows for progress to be reported whilst the sample is being uploaded.</p> <p>As noted above, this command will return 1 on success or 0 for failure.  In the event of a failure the VDP will ignore and discard the sample data being sent to it.</p> <p>Failure may occur if an invalid sample number was given, or if the VDP could not allocate sufficient memory to store the sample.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-1-clear-sample","title":"Command 5, 1: Clear sample","text":"<p><code>VDU 23, 0, &amp;85, sample, 5, 1</code></p> <p>Removes the given sample number from the VDP.  If the sample had been assigned to a channel for playback then playback will be stopped and the channel will be set to use the default waveform (square wave).</p> <p>Deleting the underlying buffer using the buffered commands API will also remove the sample from the VDP.</p> <p>This command will return 1 on success or 0 for failure.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-2-create-a-sample-from-a-buffer","title":"Command 5, 2: Create a sample from a buffer","text":"<p><code>VDU 23, 0, &amp;85, channel, 5, 2, bufferId; format, [sampleRate;]</code></p> <p>This command is used to indicate that the data in the given buffer is a sound sample.  The channel number will be ignored for the purposes of this command, but will be used in the return result.</p> <p>The buffer ID is a 16-bit value giving the buffer number to use for the sample.  The buffer must have been created using the buffered commands API before this command is called.</p> <p>The format is a single byte giving the format of the sample data.  The following formats are supported:</p> Value Description 0 8-bit signed 1 8-bit unsigned <p>The format value can also have modifier bits set to modify the behaviour of the sample.  The following modifier bits are supported:</p> Value Description 8 sample rate is sent in the next 16-bits 16 sample is tuneable <p>The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).</p> <p>If the sample is indicated to be tuneable then the sample will be set by default to have a base frequency of 523Hz (C5, or the C above middle C).  This can be adjusted using the sample set frequency command 5, 3 documented below.  If the sample is not indicated to be tuneable then the sample will ignore the frequency value set on the channel or in the play note command.</p> <p>Once a sample has been created in this way, the sample can be selected for use on a channel using the following command:</p> <pre><code>VDU 23, 0, &amp;85, channel, 4, 8, bufferId;\n</code></pre> <p>Please note that if this command is called using a bufferId that has already been created as a sample then the existing sample definition will be overwritten.  This can be used, for example, to reset the parameters of a sample.  If the existing sample had been assigned to a channel for playback then playback will be stopped and the channel will be set to use the default waveform (square wave).</p> <p>This command will return 1 on success or 0 for failure.  The channel number of the response will correspond to the channel number given to this command.</p> <p>Support for changing sample rates, and tuneable samples, was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-3-set-sample-base-frequency","title":"Command 5, 3: Set sample base frequency","text":"<p><code>VDU 23, 0, &amp;85, sample, 5, 3, frequency;</code></p> <p>Sets the base frequency of the given sample, allowing playback of the sample to be tuned to different frequencies.  The 16-bit frequency value given specifies the frequency value in Hz that the sample data is deemed to represent.</p> <p>If the frequency of a sample has not been specified (or is set to zero) then the sample playback system will ignore the frequency value set on the channel or in the play note command.  Setting a base frequency allows the frequency of playback to be adjusted.</p> <p>This command will return 1 on success or 0 for failure.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-4-set-sample-frequency-for-a-sample-by-buffer-id","title":"Command 5, 4: Set sample frequency for a sample by buffer ID","text":"<p><code>VDU 23, 0, &amp;85, channel, 5, 4, bufferId; frequency;</code></p> <p>Sets the base frequency of the sample identified by the given bufferId.  This command effectively operates the same as command 5, 3 but allows you to specify the sample by buffer ID rather than sample number.</p> <p>As with command 5, 2 the channel number will only be used for the return value and will otherwise be ignored.</p> <p>This command will return 1 on success or 0 for failure.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-5-set-sample-repeat-start-point","title":"Command 5, 5: Set sample repeat start point","text":"<p><code>VDU 23, 0, &amp;85, sample, 5, 5, repeatStart; repeatStartHighByte</code></p> <p>Sets the start point for the sample repeat.  The repeat start point is a 24-bit value giving the offset in bytes from the start of the sample data to the point at which the sample should start repeating.  (See note against command 5, 0 for why this is a 24-bit value.)</p> <p>By default, samples will repeat from the start of the sample data.  Setting a repeat start point allows you to specify a point within the sample data from which the sample should repeat.  Setting a repeat start point to zero will cause the sample to repeat from the start of the sample data.  Setting a repeat start point to a value that goes beyond the end of the sample data will cause the sample to never repeat.</p> <p>This command will return 1 on success or 0 for failure.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-6-set-sample-repeat-start-point-by-buffer-id","title":"Command 5, 6: Set sample repeat start point by buffer ID","text":"<p><code>VDU 23, 0, &amp;85, channel, 5, 6, bufferId; repeatStart; repeatStartHighByte</code></p> <p>Operates the same as command 5, 5 but similar to command 5, 4 allows you to specify the sample by buffer ID rather than sample number.</p> <p>This command will return 1 on success or 0 for failure.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-7-set-sample-repeat-length","title":"Command 5, 7: Set sample repeat length","text":"<p><code>VDU 23, 0, &amp;85, sample, 5, 7, repeatLength; repeatLengthHighByte</code></p> <p>Sets the length of the sample repeat.  The repeat length is a 24-bit value giving the length in bytes of the sample repeat.  (See note against command 5, 0 for why this is a 24-bit value.)</p> <p>The default repeat length value for a sample is <code>-1</code> which indicates the sample should repeat until the end of the sample data, so by default samples will repeat.  (A length of -1 can be sent with this command as <code>&amp;FFFF; &amp;FF</code> for the length data.)</p> <p>Setting an explicit repeat length allows you to specify a length within the sample data for the sample to repeat.  Setting a length to zero, or a value that goes beyond the end of the sample data, will cause the sample to never repeat.</p> <p>This command will return 1 on success or 0 for failure.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-8-set-sample-repeat-length-by-buffer-id","title":"Command 5, 8: Set sample repeat length by buffer ID","text":"<p><code>VDU 23, 0, &amp;85, channel, 5, 8, bufferId; repeatLength; repeatLengthHighByte</code></p> <p>Operates the same as command 5, 7 but similar to command 5, 4 allows you to specify the sample by buffer ID rather than sample number.</p> <p>This command will return 1 on success or 0 for failure.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-6-volume-envelope","title":"Command 6: Volume envelope","text":"<p><code>VDU 23, 0, &amp;85, channel, 6, type, [parameters]</code></p> <p>These commands are used to set a volume envelope on a channel.</p> <p>When a volume envelope has been set on a channel then the volume level of the channel will be adjusted over time according to the envelope.  This can be used to create a variety of effects.</p> <p>The volume level given either by the play note command or the set volume command is used as the base/target volume level for the envelope.  The envelope will then adjust the volume level from this base level.</p> <p>When a volume envelope has been applied to a channel it will be applied to all notes played on that channel until the envelope is changed or removed, just like it would on a synthesiser.</p> <p>Volume envelopes have the concept of a \"release\" phase.  When a channel playing a note is in the \"release\" phase the channel may still be making a noise, but it is no longer considered to be busy and so it is free to be used for another note.</p> <p>It should be noted that volume envelopes are compatible with sample playback.  If a channel is set to play a sample and has a volume envelope set then it will be applied to the sample playback.  As the \"release\" phase of a volume envelope is not considered to be part of the duration of a note though, this means that some attention needs to be paid to the duration of notes when playing samples.  You are advised to either use envelopes without a release phase (i.e. with a release duration of <code>0</code>), or to subtract the duration of the release phase from the duration of the note when playing a sample.  Giving the complete duration of the sample when playing a note would otherwise result in the sample starting to repeat when the \"release\" phase begins.</p> <p>With all volume envelope types, it should be noted that the maximum volume level that the sound system supports is 127, and so volumes will get clipped to that level.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p> <p>The following envelope types are supported:</p>"},{"location":"vdp/Enhanced-Audio-API/#type-0-none","title":"Type 0: None","text":"<p><code>VDU 23, 0, &amp;85, channel, 6, 0</code></p> <p>Disables the volume envelope on the given channel.</p>"},{"location":"vdp/Enhanced-Audio-API/#type-1-adsr","title":"Type 1: ADSR","text":"<p><code>VDU 23, 0, &amp;85, channel, 6, 1, attack; decay; sustain, release;</code></p> <p>Sets the volume envelope on the given channel to use an ADSR envelope.</p> <p>Values for attack, decay and release are all 16-bit numbers giving a time for that phase in milliseconds.  The sustain value is an 8-bit number giving the level to sustain at, which is a modifier to the target level.</p> <p>This is a common type of envelope used in many synthesizers.  It is made up of four stages:</p> <ul> <li>Attack - The volume level rises from 0 to the target volume level over the given number of milliseconds.</li> <li>Decay - The volume level falls from the sustain level to the release level over the given number of milliseconds.</li> <li>Sustain - The volume level is held at the sustain level until the note is released.</li> <li>Release - The volume level falls from the sustain level to 0 over the given number of milliseconds.</li> </ul> <p>The volume level during the sustain phase is calculated using the simple formula: <pre><code>sustainLevel = (targetLevel * sustain) / 127\n</code></pre></p> <p>When playing a note on a channel that has an ADSR envelope set the note duration is handled slightly differently.  A note will always play for a minimum of the Attack and Decay phases.  Calling \"play note\" with a duration of zero will therefore play a note for the Attack and Decay phases.  The sustain phase will only be entered if the note duration is longer than the Attack and Decay phases.  The Release phase will be entered either when the note duration has elapsed or the Attack and Decay phases have completed, whichever is longer.</p> <p>An example of setting an ADSR envelope on a channel is as follows:</p> <pre><code> 10 REM Set channel 1 to use an ADSR envelope\n 20 VDU 23, 0, &amp;85, 1, 6, 1, 400; 100; 100, 2000;\n 30 REM Play a note on channel 1\n 40 VDU 23, 0, &amp;85, 1, 0, 60, 440; 1500;\n</code></pre> <p>In this example we are defining an ADSR envelope, and then playing a note.  We are using the <code>VDU`` command to play the note, rather than the</code>SOUND` command just for clarity.</p> <p>The ADSR envelope set here has an attack phase of 400ms, a decay phase of 100ms, a relative sustain level of 100 and a release phase of 2000ms.  The note we are playing is an \"A\" (440Hz) with a duration of 1500ms and a base/target volume of 60.</p> <p>What you hear when this code runs is a note that starts off quiet and over 0.4s it gradually gets louder until it reaches the target volume of 60 - this is the attack phase.  The note quickly over the next 0.1s reduces its volume down to the sustain level of 47 (calculated using (60 * 100) / 127) - this is the decay phase.  The note then holds at this volume level for a further 1s, at which point a total of 1500ms has elapsed (the note duration we sent to the play note command) - this is the sustain phase.  Finally the note gradually reduces its volume over 2s until it is silent - this is the release phase.</p> <p>As noted elsewhere, during this release phase the channel is considered to be free and so can be used to play another note.  Playing another note will interrupt the release phase and the new note will immediately play.</p>"},{"location":"vdp/Enhanced-Audio-API/#type-2-multi-phase-adsr","title":"Type 2: Multi-phase ADSR","text":"<p><code>VDU 23, 0, &amp;85, channel, 6, 2, attackCount, [level, duration;]*, sustainCount, [level, duration;]*, releaseCount, [level, duration;]*</code></p> <p>* this sub-phase data is optional, dependening on the preceding count value, and will repeat as necessary to match the count.</p> <p>This command will set up a volume envelope that supports multiple sub-phases for each attack/decay, sustain, and release phases.  Conceptually this command is similar to the simpler type 1 ADSR envelope, but it allows each phase to be split into sub-phases for greater control.</p> <p>This is a variable length command, with the exact format and number of parameters determined by the command itself.</p> <p>Each sub-phase consists of two pieces of data; a target volume level, and the duration of that sub-phase in the format <code>level, duration;</code>.  The duration is a 16-bit value setting the length in ms for that sub-phase.  The target volume level is the envelope data is a number from 0-255 and specifies a relative level centred around 127.  The actual target level, to be reached by the end of that sub-phase, is calculated as follows: <pre><code>actualTarget = (noteVolume * targetLevel) / 127\n</code></pre> (This is the same formula that the type 1 ADSR envelope uses for calculating the volume level its the sustain phase.)</p> <p>Unlike a type 1 ADSR envelope, this envelope type considers \"attack\" and \"decay\" to be part of the same envelope phase.  You can simulate distinct \"attack\" and \"decay\" phases by providing separate sub-phases for each within the attack/decay phase.</p> <p>Specifying zero attack/decay sub-phases is equivalent to specifying a single attack sub-phase with target volume level 127 of 0ms duration.</p> <p>As the \"sustain\" phase of a volume envelope extends until the note duration has completed, it gets some special consideration.  The following rules will apply:</p> <ul> <li>if no sustain phases are defined then the sustain level will match the end target level of the attack/decay phase</li> <li>if sustain sub-phases only consist of zero duration entries then the envelope will automatically evenly spread the remaining note duration amongst these sub-phases</li> <li>if any sub-phases contain a duration then the sustain phase will loop through these sub-phases<ul> <li>mixing in zero duration sub-phases will cause abrupt volume level steps</li> </ul> </li> </ul> <p>Envelopes with looping sustain phases will always complete a loop cycle before moving on to the release phase.  This means that a note effectively automatically extends its duration.  The audio system will, however, consider the note to be completed once the duration has been reached, even if the note is part-way through a \"sustain\" loop, allowing playback to be interrupted to start a new note.</p> <p>Once the sustain phase has completed the envelope will process the release sub-phases.  Conventionally the final release sub-phase will typically target a volume level of 0 for silence, although this is not required.</p> <p>TODO: add some examples</p> <p>Support for this envelope type was added in Agon Console8 VDP 2.5.0.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-7-frequency-envelope","title":"Command 7: Frequency envelope","text":"<p><code>VDU 23, 0, &amp;85, channel, 7, type, [parameters]</code></p> <p>These commands are used to set a frequency envelope on a channel.</p> <p>When a frequency envelope has been set on a channel then the frequency of the channel will be adjusted over time according to the envelope.  This can be used to create a variety of effects.</p> <p>The frequency given either by the play note command or the set frequency command is used as the base/target frequency for the envelope.  The envelope will then adjust the frequency from this base frequency.</p> <p>When a frequency envelope has been applied to a channel it will be applied to all notes played on that channel until the envelope is changed or removed, just like it would on a synthesiser.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p> <p>The following envelope types are supported:</p>"},{"location":"vdp/Enhanced-Audio-API/#type-0-none_1","title":"Type 0: None","text":"<p><code>VDU 23, 0, &amp;85, channel, 7, 0</code></p> <p>Disables the frequency envelope on the given channel.</p>"},{"location":"vdp/Enhanced-Audio-API/#type-1-stepped-frequency-envelope","title":"Type 1: Stepped frequency envelope","text":"<p><code>VDU 23, 0, &amp;85, channel, 7, 1, phaseCount, controlByte, stepLength; [phase1Adjustment; phase1NumberOfSteps; phase2Adjustment; phase2NumberOfSteps; ...]</code></p> <p>The design of the stepped frequency envelope is based on the pitch envelope provided as part of the <code>ENVELOPE</code> command in BBC BASIC.</p> <p>The number of phases is set by the <code>phaseCount</code> parameter.</p> <p>The <code>controlByte</code> parameter is a bit mask that controls how the envelope will operate.  The following bits are defined:</p> Bit Name Meaning 0 Repeats If set then the envelope will repeat indefinitely whilst the note continues to play.  If not set then the envelope will only be applied once. 1 Cumulative If Repeat has been set then the envelope will apply cumulatively on each repeat of the envelope.  If it is clear then the base frequency is used on each iteration thru the envelope. 2 Restrict If set the envelope frequency generator will be restricted to returning values the range 0-65535.  If the frequency goes outside this range then the envelope will set a zero frequency.  When clear the calculated frequency is permitted to go outside this range, and the actual frequency set will be treated as <code>MOD 65536</code>. <p>Currently no other bits are defined, and are reserved for future use, so should be set to zero.</p> <p>The <code>stepLength</code> parameter is a 16-bit number giving the length of each step in milliseconds.</p> <p>Each phase is defined by two parameters.  Firstly there is an adjustment value, given as a 16-bit number.  This is the amount that the frequency will be adjusted by for each step in the phase.  Secondly there is a number of steps for the phase, given as a 16-bit number.</p> <p>(In comparison, the BBC Micro's <code>ENVELOPE</code> command has a fixed three phase design, all time values were given in centiseconds, and would automatically repeat unless the top bit of the step length value was set.  The pitch envelope could not be applied cumulatively.  Two phase envelopes were achieved by setting the number of steps in the second phase to zero.)</p> <p>The following example sets a stepped frequency envelope on channel 1:</p> <pre><code> 10 REM Set channel 1 to use a stepped frequency envelope\n 20 VDU 23, 0, &amp;85, 1, 7, 1, 2, 1, 30; 40; 6; -30; 4;\n 30 REM Play a note on channel 1\n 40 SOUND 1, -10, 100, 30\n</code></pre> <p>This will play a simple \"siren\" like sound that goes up and down, which repeats for the duration of the note (1.5s).</p> <p>The envelope described here has two phases, and the steps are each set to be 30ms long.  The first phase has an adjustment of 40, and 6 steps.  The second phase has an adjustment of -30, and 4 steps.  The envelope will therefore start at the base frequency, and then increase by 40Hz every 30ms for 6 steps.  It will then decrease by 30Hz every 30ms for 4 steps.  The envelope will then repeat from the start.</p> <p>We can change the control byte value to 3, as follows for a different effect: <pre><code> 20 VDU 23, 0, &amp;85, 1, 7, 1, 2, 3, 30; 40; 6; -30; 4;\n</code></pre></p> <p>You may have noticed that with the envelope as defined we are raising by a total of 240Hz, and then lowering by a total of 120Hz...</p> <p>With this new control byte value, on each successive loop through the frequency envelope the note will get higher and higher.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-8-enable-channel","title":"Command 8: Enable Channel","text":"<p><code>VDU 23, 0, &amp;85, channel, 8</code></p> <p>This command will enable the given channel.</p> <p>By default, an Agon Light will start up with three channels enabled, numbered 0-2.  This command can be used to enable additional channels, up to 32 of them.</p> <p>Please note that channels do not have to be enabled in order.  For example, you can enable channel 31 without having enabled channels 0-30 first.</p> <p>Attempting to enable an already enabled channel will have no effect.</p> <p>It should be noted that enabling a channel has a cost, and so it is recommended that you only enable channels that you are actually using.  The performance of the VDP with a large number of channels enabled has not been tested.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-9-disable-channel","title":"Command 9: Disable Channel","text":"<p><code>VDU 23, 0, &amp;85, channel, 9</code></p> <p>This command will disable the given channel.</p> <p>The channel is immediately disabled.  Any sound that may have been playing is instantly stopped.</p> <p>Attempting to disable an already disabled channel will have no effect.</p> <p>Re-enabling a disabled channel will give you a fresh channel, with none of the previous settings for that channel being retained.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-10-reset-channel","title":"Command 10: Reset Channel","text":"<p><code>VDU 23, 0, &amp;85, channel, 10</code></p> <p>This command will reset the given channel.</p> <p>This is equivalent to disabling and then enabling the channel.</p> <p>As with the disable command, any sound that may have been playing is instantly stopped.</p> <p>Following a reset, the channel will be in the same state as it was when it was first enabled.  This includes the frequency, volume, and envelope settings.  Resetting a channel is a fast way to stop the sound on a channel, and clear any envelopes that may have been set.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-11-seek-to-position","title":"Command 11: Seek to position","text":"<p><code>VDU 23, 0, &amp;85, channel, 11, position; positionHighByte</code></p> <p>For channels that are playing a sample, this command will seek to the given position within the sample data.  NB this is a byte offset from the start of the sample data, and not a time offset.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-12-set-duration","title":"Command 12: Set duration","text":"<p><code>VDU 23, 0, &amp;85, channel, 12, duration; durationHighByte</code></p> <p>Adjusts the duration (in ms) of any currently playing note on a channel.  If a channel is not already playing a note, then a new note will be played for the duration given.  The new note will be played at the last frequency and volume set for the channel.</p> <p>This command can be used to play notes for a duration longer than can be specified in the play note command, which can be useful for playing long sound samples.</p> <p>When used on a channel that is already playing a note, if the duration set is less than the time that the channel has currently been playing then the note will be stopped.</p> <p>If the duration is set to -1 (65535) then the note will be played indefinitely until the channel is silenced by setting its volume to zero, or by setting a duration to less than the time that the channel has currently been playing.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-13-set-sample-rate","title":"Command 13: Set sample rate","text":"<p><code>VDU 23, 0, &amp;85, channel, 13, sampleRate;</code></p> <p>This command allows for the sample rate of a channel, or of the underlying audio system, to be adjusted.</p> <p>The primary intended use of this command is to allow for the sample rate of the underlying audio system to be adjusted.  This can be used to improve the quality of audio playback, or to reduce the processing time required by the VDP to play audio.  This is done by specifying a channel number of -1 (255).  The sample rate is a 16-bit value specifying the number of samples per second to play.</p> <p>By default when your Agon starts up the audio system's sample rate is set to 16kHz (16.384kHz to be precise).  Using a higher sample rate may result in slightly better quality audio, but will also use more processing time on the VDP.  Higher sample rates can be useful for tuned sample playback, or for playing back samples that have been recorded at a higher sample rate.</p> <p>When specifying a specific channel number, the effect of this command is to have that channel behave as if the underlying audio system is operating at the given sample rate.  This can be used to adjust the pitch of a channel relative to other channels.  This means that setting a sample rate higher than the underlying audio system will result in the channel being pitched lower than other channels, and vice versa.  Setting an individual channel to use a higher sample rate than the underlying audio system will not result in any greater clarity for that channel, and may result in a loss of quality for that channel.</p> <p>Changing the sample rate of the underlying audio system will affect all channels, and at the same time will reset the sample rate of all the channels to the same value.  This means that if you have set an individual channel to use a different sample rate than the underlying audio system then that channel will be reset to use the same sample rate as the underlying audio system.</p> <p>When changing the sample rate for the underlying audio system, the frequency of note playback is not affected by the sample rate, so changing the sample rate will not affect the pitch of notes being played.</p> <p>(NB there is a bug in the underlying audio system that means that changing the underlying sample rate will cause the pitch of notes currently being played to change.  If the next note played on a channel is at exactly the same frequency as the last note that will also play at an incorrect pitch.  Playing a note at a different frequency will clear this issue and all subsequent notes will be played at the correct pitch.  This issue does not affect sample playback.  This bug will be fixed in a future release.)</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-14-set-channel-waveform-parameters","title":"Command 14: Set channel waveform parameters","text":"<p><code>VDU 23, 0, &amp;85, channel, 14, parameter, value</code></p> <p>The exact use of this command will vary depending upon the waveform type being used by the channel.</p> Parameter Description 0 Duty cycle (0-255 for 0-100% - only applicable for channels with a square wave set) 2 Volume (0-127 for 0-100%) 3 Frequency (lower 8-bits only) &amp;83 Frequency (full 16-bit value) <p>The upper bits of the parameter byte are used to indicate the way that the value will be interpreted.  The following bits are defined:</p> Bit (Hex) Meaning 7 &amp;80 on = 16-bit value, off = 8-bit value <p>When a 16-bit value is used, the value is sent as two bytes in little-endian order, i.e. with the low byte first.  When a 8-bit value is used, the value is sent as a single byte.  If you specify a 16-bit value and only send a single byte then the next byte sent to the VDP (which you probably intended to be used for the next VDU command) will be used as the high byte of the value.</p> <p>If you provide a 16-bit value for a parameter that only supports an 8-bit value then the value will be truncated to 8-bits, i.e. the high 8-bits will be ignored.</p> <p>Future versions of this command may support setting other parameters, and the use of flags in the upper bits of the parameter byte to indicate different ways of interpreting the value provided.</p> <p>(Planned future versions of this command may support adjusting the parameter using a relative value, rather than an absolute one, or may support adjusting the parameter using a multiplier.  These features are not yet supported.)</p> <p>Returns 1 on success, 0 for failure.</p> <p>This command was added in the Console8 VDP 2.5.0 release.</p>"},{"location":"vdp/Font-API/","title":"VDU 23, 0, &amp;95: Font management","text":"<p>From Console8 VDP 2.8.0 onwards, the VDP now has an API to allow for different fonts to be uploaded to the VDP and used on your Agon.  At this time the VDP supports mono-spaced fonts only, each only at a single size.  Future versions of this API may introduce support for variable width fonts, and displaying text at different sizes.</p> <p>As with other APIs, the data for fonts is stored in buffers which are sent to the VDP using the Buffered Commands API.</p> <p>Generally when selecting a font to use, you will need to upload the font data to a buffer on the VDP, and then indicate that buffer contains a font.  Once this has been done the font can be selected and used to draw text on the screen.  The system font will always be available, and can be used by selecting font -1 (65535).</p> <p>You can define as many different fonts on the VDP as you have buffers available, and can switch between them as needed.  Your font selection is tied to your currently selected cursor, so you can select different fonts for use with your graphics cursor and your text cursor.</p> <p>The commands for the font API are as follows:</p>"},{"location":"vdp/Font-API/#vdu-23-0-95-0-bufferid-flags-select-font","title":"<code>VDU 23, 0, &amp;95, 0, bufferId; flags</code>: Select font","text":"<p>Select a font to use for drawing text.</p> <p>The <code>bufferId</code> here must refer to a buffer that has been uploaded to the VDP, and marked as a font using <code>VDU 23, 0, &amp;95, 1, &lt;args&gt;</code>, as described below, or -1 (65535) for the system font.</p> <p>The <code>flags</code> parameter is a bitfield which can be used to specify options for the font.  The following flags are supported:</p> Bit Description 0 Adjust cursor position to ensure text baseline is aligned 1-7 Reserved for future use <p>If you wish to change the font within a line of text, you should use a flags setting of <code>1</code>.  This will use data within the font to ensure that the cursor position is moved to keep the text baseline aligned.</p> <p>When changing the font at the start of a new line, you should use a flags setting of <code>0</code>, as otherwise the text may overlap the previous line.</p>"},{"location":"vdp/Font-API/#vdu-23-0-95-1-bufferid-width-height-ascent-flags-create-font-from-buffer","title":"<code>VDU 23, 0, &amp;95, 1, bufferId; width, height, ascent, flags</code>: Create font from buffer","text":"<p>This command is used to mark a buffer as containing font data.  The <code>bufferId</code> must refer to a buffer that has been uploaded to the VDP, and contains font data.  The <code>width</code> and <code>height</code> parameters indicate the width and height of each character in the font in pixels, and <code>ascent</code> is the distance in pixels from the top of the character to the baseline.</p> <p>The <code>flags</code> parameter is reserved for future use, and should be set to 0.  In the future it will be used for indicating variable width fonts, and other font properties.</p> <p>Font data is assumed to be a contiguous block of data, one character at a time, with a full 256 character definitions, from character 0 to 255.  The buffer passed to this command should contain a single block of data of an appropriate size for the font.  If the data has been uploaded in mutliple parts, it should be concatenated into a single block before calling this command using the appropriate commands in the bufferered commands API.</p> <p>Fonts are monochrome, and the data is assumed to be one character at a time.  Each character is stored in a byte-aligned format, where each row of a character is stored in a number of bytes equal to <code>(width + 7) / 8</code>, with their pixels organised most significant bit first, with as many rows as indicated by the <code>height</code>.  \"Most significant bit first\" means that the leftmost pixel of the character is stored in the most significant bit of the first byte, so a font that is 6 pixels wide would be stored in bits 7-2, with bits 1 and 0 ignored when rendering the font.</p>"},{"location":"vdp/Font-API/#vdu-23-0-95-2-bufferid-field-value-set-or-adjust-font-property","title":"<code>VDU 23, 0, &amp;95, 2, bufferId; field, value;</code>: Set or adjust font property","text":"<p>Allows you to set or adjust properties of a font that has been created using <code>VDU 23, 0, &amp;95, 1, &lt;args&gt;</code>.  The <code>bufferId</code> must refer to a buffer that has been marked as containing font data.</p> <p>The <code>field</code> parameter indicates the property to set, and the <code>value</code> parameter is the value to set it to.  Whilst the <code>value</code> must be sent as a 16-bit value, most of the fields will only use the least significant 8-bits of the sent value.  The following fields are supported:</p> Field Description 0 width 1 height 2 ascent 3 flags 4 buffer for character pointers (for variable width fonts) * 5 point size (defaults to 0) * 6 inleading (defaults to 0) * 7 exleading (defaults to 0) * 8 weight (defaults to 400) * 9 character set (defaults to 255) * 10 code page (defaults to 1252) * <p>Fields 0-4 directly equate to the parameters passed to <code>VDU 23, 0, &amp;95, 1, &lt;args&gt;</code>.</p> <p>* Please note that as of VDP 2.8.0, whilst data can be set for these fields, setting them will not affect the rendering of the font.  They are reserved for future use.</p>"},{"location":"vdp/Font-API/#vdu-23-0-95-3-bufferid-args-reserved","title":"<code>VDU 23, 0, &amp;95, 3, bufferId; [&lt;args&gt;]</code>: Reserved","text":"<p>This function is reserved for future use, and should not be used at this time.</p> <p>(The intent is that this will be used to set the name of the font.)</p>"},{"location":"vdp/Font-API/#vdu-23-0-95-4-bufferid-cleardelete-font","title":"<code>VDU 23, 0, &amp;95, 4, bufferId;</code>: Clear/Delete font","text":"<p>Deletes a font that has been created using <code>VDU 23, 0, &amp;95, 1, &lt;args&gt;</code>.  The <code>bufferId</code> must refer to a buffer that has been marked as containing font data.</p> <p>NB: This does not delete the buffer itself, only the font definition.  The data remains intact in the buffer, and can be re-used to create a new font if desired.</p>"},{"location":"vdp/Font-API/#vdu-23-0-95-5-bufferid-copy-system-font-to-buffer","title":"<code>VDU 23, 0, &amp;95, 5, bufferId;</code>: Copy system font to buffer","text":"<p>Copies the system font data into a buffer and makes a new font definition for it.</p> <p>The buffer at the <code>bufferId</code> will be cleared first and then the system font data will be copied into it.  The buffer will then be marked as containing font data, and can be used as a font in the same way as any other font.</p> <p>This command will let you make multiple copies of the system font which can then be modified independently of each other using the buffered commands API.</p>"},{"location":"vdp/PLOT-Commands/","title":"VDU 25: PLOT commands","text":"<p><code>VDU 25, code, x; y;</code></p> <p>The Agon VDP system supports a number of <code>PLOT</code> commands via <code>VDU 25</code>, which are used to draw lines, circles, and other shapes on the screen.  The command set is inherited from Acorn's BBC Micro, plus Acorn's Graphics eXtension ROM (GXR).</p> <p>PLOT commands sent to the VDP all require a command byte, followed by two 16-bit values for X and Y coordinates.  The command byte is used to specify the drawing operation, and the mode in which the drawing operation is performed.</p> <p>Most PLOT commands require additional coordinates than the single pair provided with the command.  The graphics system works using a concept of a \"graphics cursor\", and will keep track of the last few positions of the graphics cursor.  Every PLOT command \"pushes\" a copy of the current graphics cursor position onto a stack, and then moves the graphics cursor to the new position.  Commands that require additional coordinates will look at the last few positions on the stack to determine the additional coordinates.</p> <p>Support for PLOT commands has grown over time, but is still only a subset of those available on a BBC Micro with a GXR ROM.</p> <p>PLOT commands are essentially split into a drawing operation, and a mode that controls how the drawing operation is performed.  There are 8 different modes for each operation.  The command byte is effectively split into two parts where the lower 3 bits define the mode, and the upper 5 bits define the drawing operation.</p> <p>The complete set of PLOT codes supported by the Agon VDP follows.  For completeness, all commands from Acorn's command set are shown, including those that are not yet supported.</p> PLOT code (Decimal) Effect &amp;00-&amp;07 0-7 Solid line, includes both ends &amp;08-&amp;0F 8-15 Solid line, final point omitted &amp;10-&amp;17 16-23 Dot-dash line, includes both ends, pattern restarted \u00a7\u00a7\u00a7\u00a7 &amp;18-&amp;1F 24-31 Dot-dash line, final point omitted, pattern restarted \u00a7\u00a7\u00a7\u00a7 &amp;20-&amp;27 32-39 Solid line, first point omitted &amp;28-&amp;2F 40-47 Solid line, both points omitted &amp;30-&amp;37 48-55 Dot-dash line, first point omitted, pattern continued \u00a7\u00a7\u00a7\u00a7 &amp;38-&amp;3F 56-63 Dot-dash line, both points omitted, pattern continued \u00a7\u00a7\u00a7\u00a7 &amp;40-&amp;47 64-71 Point plot &amp;48-&amp;4F 72-79 Line fill left and right to non-background \u00a7\u00a7 &amp;50-&amp;57 80-87 Triangle fill &amp;58-&amp;5F 88-95 Line fill right to background \u00a7\u00a7 &amp;60-&amp;67 96-103 Rectangle fill &amp;68-&amp;6F 104-111 Line fill left and right to foreground \u00a7\u00a7 &amp;70-&amp;77 112-119 Parallelogram fill &amp;78-&amp;7F 120-127 Line fill right to non-foreground \u00a7\u00a7 &amp;80-&amp;87 128-135 Not supported (Flood until non-background) &amp;88-&amp;8F 136-143 Not supported (Flood until foreground) &amp;90-&amp;97 144-151 Circle outline &amp;98-&amp;9F 152-159 Circle fill &amp;A0-&amp;A7 160-167 Circular arc \u00a7\u00a7\u00a7\u00a7 &amp;A8-&amp;AF 168-175 Circular segment \u00a7\u00a7\u00a7\u00a7 &amp;B0-&amp;B7 176-183 Circular sector \u00a7\u00a7\u00a7\u00a7 &amp;B8-&amp;BF 184-191 Rectangle copy/move &amp;C0-&amp;C7 192-199 Not supported (Ellipse outline) &amp;C8-&amp;CF 200-207 Not supported (Ellipse fill) &amp;D0-&amp;D7 208-215 Not defined &amp;D8-&amp;DF 216-223 Fill path (Experimental - Not defined on Acorn systems) \u00a7\u00a7\u00a7\u00a7 &amp;E0-&amp;E7 224-231 Not defined &amp;E8-&amp;EF 232-239 Bitmap plot \u00a7 &amp;F0-&amp;F7 240-247 Not defined &amp;F8-&amp;FF 248-255 Not defined <p>Within each group of eight plot codes, the effects are as follows:</p> Plot code Effect 0  (8) Move relative 1  (9) Plot relative in current foreground colour 2  (A) Plot relative in logical inverse colour \u00a7\u00a7\u00a7 3  (B) Plot relative in current background colour 4  (C) Move absolute 5  (D) Plot absolute in current foreground colour 6  (E) Plot absolute in logical inverse colour \u00a7\u00a7\u00a7 7  (F) Plot absolute in current background colour <p>Codes 0-3 use the position data provided as part of the command as a relative position, adding the position given to the current graphical cursor position.  Codes 4-7 use the position data provided as part of the command as an absolute position, setting the current graphical cursor position to the position given.</p> <p>The various \"Line fill\" plot commands have an additional effect, which is to adjust the graphics cursor position to the right-hand edge of the filled line, if one was drawn.</p> <p>\u00a7 Support added in Agon Console8 VDP 2.1.0 \u00a7\u00a7 Support added in Agon Console8 VDP 2.2.0 \u00a7\u00a7\u00a7 Support added in Agon Console8 VDP 2.6.0 \u00a7\u00a7\u00a7\u00a7 Support added in Agon Console8 VDP 2.7.0</p>"},{"location":"vdp/PLOT-Commands/#interaction-with-gcol-paint-modes","title":"Interaction with GCOL paint modes","text":"<p>The GCOL command (<code>VDU 18, mode, colour</code>) is used to set the paint mode for the PLOT command.  The paint mode is used to control how the PLOT command interacts with the existing pixels on the screen.</p> <p>Up until Console8 VDP 2.6.0 the only fully supported GCOL paint mode was mode 0, which sets the pixel to the target colour value.  This is the default mode, and is used if no GCOL command has been issued.  There was limited support for mode 4, which inverts the pixel, but this was only supported for straight line drawing operations.</p> <p>As of Console8 VDP 2.6.0, the following modes are now available for all currently supported plot operations:</p> Mode Effect 0 Set on-screen pixel to target colour value 1 OR value with the on-screen pixel 2 AND value with the on-screen pixel 3 EOR value with the on-screen pixel 4 Invert the on-screen pixel 5 No operation 6 AND the inverse of the specified colour with the on-screen pixel 7 OR the inverse of the specified colour with the on-screen pixel <p>PLOT commands using an \"inverse\" plot code are essentially identical to setting a GCOL paint mode of 4, and will temporarily override the current GCOL paint mode if a different GCOL paint mode is set. </p>"},{"location":"vdp/PLOT-Commands/#line-drawing-plot-codes-00-3f","title":"Line drawing (PLOT codes &amp;00-&amp;3F)","text":"<p>For all of the line drawing plot codes, the position given with the PLOT command is the end point of the line.  The start point of the line is the last position on the graphics cursor stack.</p> <p>Support for plotting dotted lines was added in Agon Console8 VDP 2.7.0.  The default pattern is 1 pixel on, 1 pixel off, but this can be changed using the <code>VDU 23, 6, n1-n8</code> command which takes 8 bytes of data.  The length of pattern can be set using <code>VDU 23, 0, 242, n</code> where n is the number of pixels in the pattern.  Setting a length of zero will reset to the default pattern with a length of 8.  When drawing a line, the pattern is repeated as many times as necessary to draw the line and will be used from the top-most bit of the pattern data, repeating as necessary to draw the whole line.</p>"},{"location":"vdp/PLOT-Commands/#line-fill-codes-plot-codes-48-4f-58-5f-68-6f-78-7f","title":"Line fill codes (PLOT codes &amp;48-&amp;4F, &amp;58-5F, &amp;68-6F, &amp;78-&amp;7F)","text":"<p>These various PLOT codes will fill horizontal lines on the screen.  When executing \"drawing\" plot codes, the graphics system will scan the line to find appropriate start and end positions, depending on the PLOT code used and the screen contents.  The final calculated end position will be pushed to the graphics cursor stack.</p>"},{"location":"vdp/PLOT-Commands/#filled-triangles-plot-codes-50-57","title":"Filled triangles (PLOT codes &amp;50-&amp;57)","text":"<p>Filled triangles are drawn using the last two positions on the graphics cursor stack and the position given with the PLOT command.</p> <p>The behaviour of the triangle fill command has changed slightly in Agon Console8 VDP 2.6.0, and you may observe some slight differences in the exact pixels drawn when using this command.  Unfortunately the old behaviour was not compatible with the new GCOL paint modes, and so the behaviour had to be changed.  The behaviour is consistent with general \"best practice\" for triangle fill algorithms, and so should be more predictable and reliable.  As an example, with the revised triangle plotting it is possible to draw a fan of triangles using an EOR paint mode and you will not see the edges of the triangles \"cancel each other out\" as you would have done with the old behaviour.</p> <p>This new behaviour is not entirely consistent with the BBC Micro or GXR ROM, but it is more consistent with modern graphics systems and should be more predictable and reliable.  In practice, the differences are minimal and should not affect most programs.</p>"},{"location":"vdp/PLOT-Commands/#filled-rectangles-plot-codes-60-67","title":"Filled rectangles (PLOT codes &amp;60-&amp;67)","text":"<p>Filled rectangles are drawn using the last position on the graphics cursor stack and the position given with the PLOT command to define two corners of a rectangle.</p>"},{"location":"vdp/PLOT-Commands/#filled-parallelograms-plot-codes-70-77","title":"Filled parallelograms (PLOT codes &amp;70-&amp;77)","text":"<p>Parallelograms require three points to be defined.  They will therefore use the last two points pushed to the graphics cursor stack, coupled with the position given with the PLOT command.</p> <p>The three given points represent any three corners of the parallelogram.  The first and last (third) points are used to define opposing corners of the parallelogram.  The graphics system will calculate the fourth corner of the parallelogram as a point opposite to the second corner, and then fill the shape.</p>"},{"location":"vdp/PLOT-Commands/#circle-drawing-plot-codes-90-9f","title":"Circle drawing (PLOT codes &amp;90-&amp;9F)","text":"<p>Circle drawing requires two points to be defined.  They will therefore use the last point pushed to the graphics cursor stack, coupled with the position given with the PLOT command.  The first point is the centre of the circle, and the second point is a point on the circumference of the circle.</p>"},{"location":"vdp/PLOT-Commands/#arcs-segments-and-sectors-plot-codes-a0-b7","title":"Arcs, segments, and sectors (PLOT codes &amp;A0-&amp;B7) \u00a7\u00a7\u00a7\u00a7","text":"<p>Arcs, segments, and sectors require three points to be defined.  They will therefore use the last two points pushed to the graphics cursor stack, coupled with the position given with the PLOT command.</p> <p>Arcs, segments, and sectors are all drawn anticlockwise from a start point to an end.</p> <p>The first point defines the start of the arc, segment, or sector, which is a point on the circumference of the circle.  The second point defines the centre of the circle that the arc, segment, or sector is part of.  The distance from the first point to the second point defines the radius of the circle.  The final point (provided with the PLOT command) defines the end of the arc, segment, or sector.  This point does not have to be on the circumference of the circle, and the graphics system will calculate the point on the circumference that the arc, segment, or sector ends at.  Instead the final point is effectively used to define the angle of the arc.</p>"},{"location":"vdp/PLOT-Commands/#rectangle-copymove-plot-codes-b8-bf","title":"Rectangle copy/move (PLOT codes &amp;B8-&amp;BF)","text":"<p>These PLOT codes are interpreted slightly differently from others.  The purpose of these commands is to copy or move a rectangle of pixels from one location to another.  The rectangle is defined by the last two positions on the graphics cursor stack, and the position provided with the PLOT command is the destination to copy the rectangle to.</p> <p>A \"move\" operation will copy the rectangle to the new location, and then clear the original rectangle using the currently defined background colour.  (NB the background GCOL paint mode is not used when filling the original rectangle - the pixels will be set with the background colour).  A \"copy\" operation will copy the rectangle to the new location, but leave the original rectangle in place.</p> PLOT code Effect &amp;B8 Move cursor relative to last position &amp;B9 Relative rectangle move &amp;BA Relative rectangle copy &amp;BB Relative rectangle copy &amp;BC Move cursor to absolute position &amp;BD Absolute rectangle move &amp;BE Absolute rectangle copy &amp;BF Absolute rectangle copy"},{"location":"vdp/PLOT-Commands/#fill-path-experimental-plot-codes-d8-df","title":"Fill path - Experimental (PLOT codes &amp;D8-&amp;DF) \u00a7\u00a7\u00a7\u00a7","text":"<p>The ability to draw a filled path was added in the Agon Console8 VDP 2.7.0 release.  This command was not part of Acorn's original PLOT command set, either on the BBC Micro, in their Graphics Extension ROM, or in the later Acorn Archimedes operating systems.  For now, it should therefore be considered to be experimental.  Whilst at the time of writing this documentation it is thought that this command is not likely to change, it is possible that the command may be removed or altered in future releases.</p> <p>This command will fill a path defined by an arbitrary number of points.  The path must be at least three points long.</p> <p>As the path is is of an arbitrary length the nature of this commands operation differs from other PLOT commands.</p> <p>All new paths will be started with the last two points pushed to the graphics cursor stack, plus the position given with the PLOT command.  The path thus starts with three points and therefore, if no subsequent commands are received to extend the path, a triangle will be drawn.</p> <p>If the next VDU command received immediately after a fill path plotting command is also a matching \"Fill path\" PLOT command then the path will be extended with the new position given with the PLOT command.  If the next VDU command is not a matching \"Fill path\" PLOT command then the path will be considered to be complete, i.e. the path will be closed by connecting the last point to the first one and the graphics system will then fill the area defined by the path.</p> <p>Please note that any \"move\" PLOT command will be interpreted as closing the current path.  Whilst absolute and relative positioning PLOT commands can be combined when building up a path, changing between different codes (such as from \"foreground\" to \"background\" PLOTs) will be interpreted as closing the current path and starting a new path.</p> <p>If any other VDU commands are received after a \"Fill path\" PLOT command, then the path will be considered to be complete and the graphics system will fill the area defined by the path.  Similarly if there is a significant delay between the VDP receiving \"fill path\" PLOT commands, even if the next command uses a matching PLOT code, then the path will be considered to be complete and the graphics system will fill the area defined by the path.</p> <p>As a result of this mode of operation, it is not possible to interactively enter multiple \"fill path\" PLOT commands one after another at the BASIC command prompt using separate commands over multiple lines, as the system will interpret the character output for command entry as closing the current path.  Instead filled paths must be defined in a single command sequence, uninterrupted by other VDU commands, usually as part of a program.</p>"},{"location":"vdp/PLOT-Commands/#bitmap-plots-plot-codes-e8-ef","title":"Bitmap plots (PLOT codes &amp;E8-&amp;EF)","text":"<p>Bitmap plots will draw the currently selected bitmap to the screen.</p> <p>Before a bitmap plot can be used a valid bitmap must be selected using either <code>VDU 23, 27, 0, id</code> or <code>VDU 23, 27, &amp;20, bufferId;</code>.</p> <p>Bitmap plots will only draw non-transparent pixels to the screen.  When using \"foreground\" PLOTs, the bitmap is drawn to screen using the current foreground GCOL painting mode using the colour from the bitmap.  When using \"background\" PLOTs, the bitmap is drawn to screen using the current background GCOL painting mode using the currently selected background colour.  Inverse plot modes invert on-screen pixels that correspond to non-transparent pixels in the bitmap.</p>"},{"location":"vdp/PLOT-Commands/#plot-support-prior-to-vdp-104","title":"PLOT support prior to VDP 1.04","text":"<p>Prior to VDP 1.04 the PLOT command support was very limited, did not support relative positioning, and had buggy and incorrect interpretations of some of the PLOT codes.  As of VDP 1.04 the PLOT command support has been greatly improved, and is now much more compatible with the BBC Micro and GXR ROM.</p> <p>The most significant bug was the mis-interpretation of several \"move\" commands to instead be \"draw\".  As a result, some programs written for earlier versions of the VDP firmware may no longer work correctly.  Fixing these programs however is usually very straightforward and usually just involves changing the PLOT code used.</p>"},{"location":"vdp/PLOT-Commands/#compatibility","title":"Compatibility","text":"<p>If the VDP does not recognise a plot operation, it will be ignored.  This can allow you to write programs that \"feature detect\" whether the VDP supports a particular plot operation, and then use it if it does, or fall back to an alternative if it does not.</p>"},{"location":"vdp/Screen-Modes/","title":"Screen Modes","text":"<p>The Agon VDP supports a number of different screen modes, which are listed below.</p> <p>Screen modes are selected using <code>VDU 22, mode</code>, or in BASIC using <code>MODE mode</code>.</p> <p>The list of screen modes available for use got revised and greatly expanded in VDP version 1.04.  The revision was mostly to make the screen modes more compatible with the VGA standards, and thus more compatible with modern monitors.  The original screen modes are still available, but are now considered legacy modes.</p> <p>It should be noted that whilst the Agon VDU command system is designed to be compatible with the BBC Micro, the screen modes are not.  The BBC Micro has a different set of screen modes, and the Agon VDP does not support them.</p> <p>By default, the Agon VDU system uses and adopts the BBC Micro's \"logical\" coordinate system for graphics, which means that each screen mode appears to be 1280x1024 to software with the graphics origin 0,0 point at the bottom left of the screen.  As a result programs written the BBC Micro can usually be fairly easily adapted.</p> <p>This logical coordinate system differs from the BBC Micro and later Acorn systems in that Acorn systems all used round numbers for the multiplier between the logical and physical coordinate systems.  (This meant that on later Acorn systems some screen modes used logical resolutions other than 1024x1280, depending on the physical resolution of the mode.)  On Agon systems, the multiplier for the vertical resolution is, essentially never a round number.</p> <p>To work around the limitations of the logical coordinate system, it is possible to change the graphics system to use physical coordinates instead of logical coordinates.</p> <p>There are two VDU commands that will affect the screen modes that are available, and how the drawing system works.</p>"},{"location":"vdp/Screen-Modes/#vdu-commands","title":"VDU Commands","text":""},{"location":"vdp/Screen-Modes/#vdu-22-mode","title":"<code>VDU 22, mode</code>","text":"<p>This command selects a screen mode, where the screen mode is a single byte value and must be a mode from the list below.</p> <p>Screen modes numbered above 128 are double-buffered, meaning that the screen is drawn to an off-screen buffer, and then the buffer is copied to the screen.  This prevents flickering when drawing to the screen.</p> <p>As drawing operations, when in a double-buffered mode, are only performed in the off-screen buffer this means that the screen will not be updated until the active buffer is swapped.  This means, for instance, that if you enter a double-buffered screen mode in BASIC by using <code>MODE 129</code> then commands that you type will not be visible, as your input is being written to the off-screen buffer.  Commands will still be processed, but you will only see their effect when the buffer is swapped.  Buffers are swapped using <code>VDU 23, 0, &amp;C3</code></p> <p>It may sometimes not be possible to change into a screen mode, for instance because the VDP no longer has enough memory to support the mode.  In this case the system will fall back to the current mode, and if that fails to the default mode, which is mode 1.  All modes should always be available after a reset.</p>"},{"location":"vdp/Screen-Modes/#vdu-23-0-c0-n","title":"<code>VDU 23, 0, &amp;C0, n</code>","text":"<p>Turn logical screen scaling on and off, where 1=on and 0=off.</p> <p>When logical scaling is turned off, the graphics system will no longer use the 1280x1024 logical coordinate system and instead use pixel coordinates.  The screen origin point at 0,0 will change to be the top left of the screen, and the Y axis will go down the screen instead of up.  </p> <p>Support for this was added in VDP 1.03.</p>"},{"location":"vdp/Screen-Modes/#vdu-23-0-c1-n","title":"<code>VDU 23, 0, &amp;C1, n</code>","text":"<p>Switch legacy modes on or off.</p> <p>By default, the original screen modes 0-4 are not available and are instead replaced by new modes that are more compatible with modern monitors.  For compatibility with older software, written for Agon systems running earlier versions of the VDP firmware, this command can be used to switch back to those original, legacy, screen modes.</p> <p>Support for this was added in VDP 1.04</p>"},{"location":"vdp/Screen-Modes/#vdu-23-0-c3","title":"<code>VDU 23, 0, &amp;C3</code>","text":"<p>Swap the screen buffer (double-buffered modes only) or wait for VSYNC (all modes).</p> <p>This command will swap the screen buffer, if the current screen mode is double-buffered, doing so at the next VSYNC.  If the current screen mode is not double-buffered then this command will wait for the next VSYNC signal before returning.  This can be used to synchronise the screen with the vertical refresh rate of the monitor.</p> <p>Waiting for VSYNC can be useful for ensuring smooth graphical animation, as it will prevent tearing of the screen.</p> <p>(In BASIC performing a <code>*FX 19</code> command will also wait for VSYNC, but will not swap the screen buffer.)</p> <p>Support for this was added in VDP 1.04</p>"},{"location":"vdp/Screen-Modes/#screen-modes_1","title":"Screen modes","text":"<p>Modes over 128 are double-buffered</p>"},{"location":"vdp/Screen-Modes/#from-version-104-or-greater","title":"From Version 1.04 or greater","text":"Mode Horz Vert Cols Refresh *** 0 640 480 16 60hz * 1 640 480 4 60hz 2 640 480 2 60hz 3 640 240 64 60hz 4 640 240 16 60hz 5 640 240 4 60hz 6 640 240 2 60hz ** 7 n/a n/a 16 60hz 8 320 240 64 60hz 9 320 240 16 60hz 10 320 240 4 60hz 11 320 240 2 60hz 12 320 200 64 70hz 13 320 200 16 70hz 14 320 200 4 70hz 15 320 200 2 70hz 16 800 600 4 60hz 17 800 600 2 60hz 18 1024 768 2 60hz 129 640 480 4 60hz 130 640 480 2 60hz 132 640 240 16 60hz 133 640 240 4 60hz 134 640 240 2 60hz 136 320 240 64 60hz 137 320 240 16 60hz 138 320 240 4 60hz 139 320 240 2 60hz 140 320 200 64 70hz 141 320 200 16 70hz 142 320 200 4 70hz 143 320 200 2 70hz <p>* Mode 1 is the \"default\" mode, and is the mode that the system will use on startup.  It is also the mode that the system will fall back to use if it was not possible to change to the requested mode.</p> <p>** Mode 7 is the \"Teletext\" mode, and essentially works in a very similar manner to the BBC Micro's Teletext mode, which was also mode 7.</p> <p>*** As of Console8 VDP 2.8.0, mode 0 is now the mode that the VDP will use on startup.  The fallback mode when a requested mode is not available remains mode 1.</p>"},{"location":"vdp/Screen-Modes/#legacy-modes-prior-to-104","title":"Legacy modes (prior to 1.04)","text":"Mode Horz Vert Cols Refresh 0 1024 768 2 60hz 1 512 384 16 60hz 2 320 200 64 75hz 3 640 480 16 60hz"},{"location":"vdp/System-Commands/","title":"VDP System Commands","text":"<p><code>VDU 23, 0</code> is reserved for commands sent to the VDP.  These are largely unique to the Agon, and are used to access some of the more sophisticated features of the VDP.</p> <p>Some of the commands are used for operating system functionality, and will not usually need to be used by user applications, whilst others allow access to features that applications will want to use.</p> <p>Please note that not all versions of the VDP support the complete command set.  The following list uses the following symbols to indicate which VDP versions support which commands:</p> <p>* Requires VDP 1.03 or above  ** Requires VDP 1.04 or above  \u00a7 Requires Console8 VDP 2.3.0 or above  \u00a7\u00a7 Requires Console8 VDP 2.4.0 or above  \u00a7\u00a7\u00a7 Requires Console8 VDP 2.6.0 or above  \u00a7\u00a7\u00a7\u00a7 Requires Console8 VDP 2.7.0 or above  \u00a7\u00a7\u00a7\u00a7\u00a7 Requires Console8 VDP 2.8.0 or above</p> <p>Commands between &amp;80 and &amp;89 will return their data back to the eZ80 via the serial protocol.</p> <p>NB:</p> <ul> <li>Prior to MOS 1.03 the subset commands that it supported were indexed from &amp;00, not &amp;80. For example, <code>VDU 23, 0, &amp;02</code> to request the cursor position.</li> </ul>"},{"location":"vdp/System-Commands/#vdu-23-0-0a-n-set-cursor-start-line-and-appearance","title":"<code>VDU 23, 0, &amp;0A, n</code>: Set cursor start line and appearance \u00a7\u00a7\u00a7\u00a7","text":"<p>This command defines the start line (or row) of the cursor and its appearance.  Bits 0-4 define the start line of the cursor, and bits 5-6 define the cursor appearance.  The meaning of the appearance bits are as follows:</p> Bit 6 Bit 5 Meaning 0 0 Steady 0 1 Off 1 0 Fast blink 1 1 Slow blink <p>By default, the start line is zero, and the cursor appearance is a slow blink.</p> <p>This command works in conjunction with <code>VDU 23, 0, &amp;0B, n</code>, <code>VDU 23, 0, &amp;8A, n</code>, and <code>VDU 23, 0, &amp;8B, n</code> to define how the cursor will be drawn on screen.</p> <p>The cursor start line must be less than the current font height (which is currently 8 pixels, and cannot currently be adjusted).</p> <p>Support for this command was introduced in the Console8 VDP 2.7.0.  It's behaviour is compatible with the equivalent commands on the Acorn BBC Micro and RISC OS.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-0b-n-set-cursor-end-line","title":"<code>VDU 23, 0, &amp;0B, n</code>: Set cursor end line \u00a7\u00a7\u00a7\u00a7","text":"<p>This defines the end line of the cursor.  The displayed cursor will be drawn from the start line to the end line.  The end line must be greater than the start line, and less than the current font height.</p> <p>Together with the start line, this command defines the vertical size of the cursor.</p> <p>If the start and end lines are equal then the cursor will be drawn as a horizontal line.  If the end line value is less than the start line value then the cursor will not be drawn.  If a value is given that is greater than the current font height then the cursor will be drawn to the end of the font height.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-80-n-general-poll","title":"<code>VDU 23, 0, &amp;80, n</code>: General poll","text":"<p>This command will echo back <code>n</code> to MOS (see Serial Protocol)</p> <p>This command is used by MOS and the VDP to synchronise with each other during the system start-up process.  It is not intended to be used by applications.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-81-n-set-the-keyboard-locale","title":"<code>VDU 23, 0, &amp;81, n</code>: Set the keyboard locale","text":"<p>Sets the keyboard to a given locale/format.  The following locales are supported:</p> Locale Description 0 UK 1 US 2 German 3 Italian 4 Spanish 5 French 6 Belgian 7 Norwegian 8 Japanese ** 9 US International ** 10 US International Alternate ** 11 Swiss German ** 12 Swiss French ** 13 Danish ** 14 Swedish ** 15 Portuguese ** 16 Brazilian Portuguese \u00a7 17 Dvorak \u00a7 <p>Any other value will be interpreted as UK.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-82-request-text-cursor-position","title":"<code>VDU 23, 0, &amp;82</code>: Request text cursor position","text":"<p>This command will return the current text cursor position to MOS.  Once the cursor position has been returned the text cursor position data inside MOS's system variables will be updated to reflect the current cursor position.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-83-x-y-get-ascii-code-of-character-at-character-position-x-y","title":"<code>VDU 23, 0, &amp;83, x; y;</code>: Get ASCII code of character at character position x, y","text":"<p>This command will return the ASCII code of the character at the given character position to MOS.  There is a corresponding command <code>VDU 23, 0, &amp;93, x; y;</code> that works in the graphics coordinate system.</p> <p>This command works by comparing pixels on the screen at the given position to the currently selected font, using the currently selected text colour.  This means that it may not always be accurate, or able to succeed.  Redefining system font characters after they have been drawn, changing the font, modifing the definitions of characters within the selected font, changing the text colour, may cause this command to fail.</p> <p>This command will not recognise characters that have been mapped to bitmaps using <code>VDU 23, 0, &amp;92, char, bitmapId;</code>.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-84-x-y-get-colour-of-pixel-at-pixel-position-x-y","title":"<code>VDU 23, 0, &amp;84, x; y;</code>: Get colour of pixel at pixel position x, y","text":"<p>This command will return the colour of the pixel at the given pixel position to MOS.  The corresponding MOS system variables will be updated to reflect the read pixel colour.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-85-channel-command-args-audio-commands","title":"<code>VDU 23, 0, &amp;85, channel, command, &lt;args&gt;</code>: Audio commands","text":"<p>Sends a command to the VDP Enhanced Audio API **</p> <p>Prior to VDP 1.04 this command could only perform what is now audio command zero, which plays a note on a channel.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-86-fetch-the-screen-dimensions","title":"<code>VDU 23, 0, &amp;86</code>: Fetch the screen dimensions","text":"<p>Returns the screen dimensions to MOS.  Generally applications should not need to call this, as this information will be automatically sent to MOS when the screen mode is changed.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-87-rtc-control","title":"<code>VDU 23, 0, &amp;87</code>: RTC control *","text":"<p>This command controls the Real Time Clock within the Agon VDP.</p> <ul> <li><code>VDU 23, 0, &amp;87, 0</code>: Read the RTC</li> <li> <p>a data packet will be sent to MOS with the current RTC data, and MOS system variables updated accordingly</p> </li> <li> <p><code>VDU 23, 0, &amp;87, 1, y, m, d, h, m, s</code>: Set the RTC</p> </li> </ul>"},{"location":"vdp/System-Commands/#vdu-23-0-88-delay-rate-led-keyboard-control","title":"<code>VDU 23, 0, &amp;88, delay; rate; led</code>: Keyboard Control *","text":"<p>This command controls the keyboard repeat delay, repeat rate, and LED status.</p> <p>Only delay values between 250 and 1000 are supported, and represents a time in milliseconds before the key will start repeating.</p> <p>The rate value represents the time between key repeats, and is given in milliseconds.  Values from 33-500 are supported.</p> <p>The LED value is a bit mask that controls the state of the keyboard LEDs.  The following bits are defined:</p> Bit Name Meaning 0 Scroll Lock If set then the Scroll Lock LED will be turned on.  If clear then it will be turned off. 1 Caps Lock If set then the Caps Lock LED will be turned on.  If clear then it will be turned off. 2 Num Lock If set then the Num Lock LED will be turned on.  If clear then it will be turned off."},{"location":"vdp/System-Commands/#vdu-23-0-89-command-args-mouse-control","title":"<code>VDU 23, 0, &amp;89, command, [&lt;args&gt;]</code>: Mouse control **","text":"<p>Commands beginning with <code>VDU 23, 0, &amp;89</code> are reserved for mouse control, and are implemented from VDP 1.04 onwards.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-0-enable-the-mouse","title":"<code>VDU 23, 0, &amp;89, 0</code>: Enable the mouse","text":"<p>Enables the mouse cursor, and will start sending mouse data packets to MOS.</p> <p>If there is no mouse connected then this command will have no effect.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-1-disable-the-mouse","title":"<code>VDU 23, 0, &amp;89, 1</code>: Disable the mouse","text":"<p>Disables the mouse cursor, and will stop sending mouse data packets to MOS.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-2-reset-the-mouse","title":"<code>VDU 23, 0, &amp;89, 2</code>: Reset the mouse","text":"<p>Resets the mouse system restoring default settings.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-3-cursorid-set-mouse-cursor","title":"<code>VDU 23, 0, &amp;89, 3, cursorId;</code>: Set mouse cursor","text":"<p>Sets the mouse cursor to the given cursor ID.</p> <p>There are several built-in mouse cursors that are available for use.  These have been inherited from fab-gl and are numbered from 0-18.  The \"Cursor\" column in the table below shows the fab-gl name for the cursor.</p> ID Cursor Description 0 PointerAmigaLike 11x11 Amiga like colored mouse pointer 1 PointerSimpleReduced 10x15 mouse pointer 2 PointerSimple 11x19 mouse pointer 3 PointerShadowed 11x19 shadowed mouse pointer 4 Pointer 12x17 mouse pointer 5 Pen 16x16 pen 6 Cross1 9x9 cross 7 Cross2 11x11 cross 8 Point 5x5 point 9 LeftArrow 11x11 left arrow 10 RightArrow 11x11 right arrow 11 DownArrow 11x11 down arrow 12 UpArrow 11x11 up arrow 13 Move 19x19 move 14 Resize1 12x12 resize orientation 1 15 Resize2 12x12 resize orientation 2 16 Resize3 11x17 resize orientation 3 17 Resize4 17x11 resize orientation 4 18 TextInput 7x15 text input <p>Additional cursors can be defined using the <code>VDU 23, 27, &amp;40, hotX, hotY</code> command.  For details of that command see the Bitmaps API documentation.  Using that API it is possible to define a custom mouse cursor using a bitmap, which can then be selected using this command passing in the 16-bit bitmapId in place of a cursorId.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-4-x-y-set-mouse-cursor-position","title":"<code>VDU 23, 0, &amp;89, 4, x; y;</code>: Set mouse cursor position","text":"<p>Explicitly moves the mouse cursor to a given position on the screen.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-5-x1-y1-x2-y2-reserved","title":"<code>VDU 23, 0, &amp;89, 5, x1; y1; x2; y2;</code>: Reserved","text":"<p>This command is reserved for future use.  It is not yet implemented.</p> <p>(When implemented it will set the mouse area, which will restrict the mouse cursor to a given area of the screen.  The mouse cursor will not be able to leave this area.)</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-6-samplerate-set-mouse-sample-rate","title":"<code>VDU 23, 0, &amp;89, 6, sampleRate</code>: Set mouse sample rate","text":"<p>Sets the rate at which mouse data will be sampled.  The rate given is a number of samples per second.  The default rate is 60.</p> <p>Valid sample rates are 10, 20, 40, 60, 80, 100, and 200 (samples/sec).  Any other values will be ignored.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-7-resolution-set-mouse-resolution","title":"<code>VDU 23, 0, &amp;89, 7, resolution</code>: Set mouse resolution","text":"<p>Sets the mouse resolution.  Values in the range 0-3 are supported, or 255 (-1) to pick the default resolution.  The default resolution is 2.</p> <p>The following resolutions are supported:</p> Value Resolution 0 1 count per mm (25 dpi) 1 2 counts per mm (50 dpi) 2 4 counts per mm (100 dpi) (default) 3 8 counts per mm (200 dpi)"},{"location":"vdp/System-Commands/#vdu-23-0-89-8-scaling-set-mouse-scaling","title":"<code>VDU 23, 0, &amp;89, 8, scaling</code>: Set mouse scaling","text":"<p>Sets the mouse scaling factor.  Only values <code>1</code> and <code>2</code> are supported to indicate 1:1 or 1:2 scaling.  Additionally a value of <code>0</code> can be sent to indicate \"default\" scaling, which is 1:1.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-9-acceleration-set-mouse-acceleration","title":"<code>VDU 23, 0, &amp;89, 9, acceleration;</code>: Set mouse acceleration","text":"<p>This sets the mouse acceleration factor to a 16-bit value.  Setting the value to <code>0</code> will result in the default acceleration being used, which is 180.  The suggested range for this is 0-2000.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-10-wheelacceleration-wheelacchighbyte-set-mouse-wheel-acceleration-accepts-a-24-bit-value","title":"<code>VDU 23, 0, &amp;89, 10, wheelAcceleration; wheelAccHighByte</code>: Set mouse wheel acceleration (accepts a 24-bit value)","text":"<p>Sets the wheel acceleration factor to a 24-bit value.  Setting the value to <code>0</code> will result in the default acceleration being used, which is 60000.  The suggested range for this is 0-100000.</p>"},{"location":"vdp/System-Commands/#mouse-data-packets","title":"Mouse data packets","text":"<p>Mouse data packets are sent in response to all of the above commands, and if the mouse has been enabled whenever the mouse is moved.  This ensures that mouse data is constantly updated in MOS system variables.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-8a-n-set-the-cursor-start-column","title":"<code>VDU 23, 0, &amp;8A, n</code>: Set the cursor start column \u00a7\u00a7\u00a7\u00a7","text":"<p>This command defines the start pixel column of the text cursor.  The displayed cursor will be drawn from the start column to the end column.  The start column can be set to any value, but for the cursor to be visible it must be less than the current font width.  The default value is 0.</p> <p>Acorn systems did not support directly adjusting the number of columns used by the cursor, and so this command is not supported on those systems and is an Agon-specific extension.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-8b-n-set-the-cursor-end-column","title":"<code>VDU 23, 0, &amp;8B, n</code>: Set the cursor end column \u00a7\u00a7\u00a7\u00a7","text":"<p>This command defines the end pixel column of the cursor.  The displayed cursor will be drawn from the start column to the end column.  The end column can be set to any value, but for the cursor to be visible it must be greater than the start column, and less than the current font width.  The default value is 255, which together with the default start column value ensures the cursor is the full width of the currently selected font.</p> <p>Together with the start column, this command defines the width of the cursor.</p> <p>If the start and end column values are equal then the cursor will be drawn as a vertical line.  If a value is given that is greater than the current font width then the cursor will be drawn to the end of the font width.</p> <p>Acorn systems did not support directly adjusting the number of columns used by the cursor, and so this command is not supported on those systems and is an Agon-specific extension.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-8c-x-y-relative-cursor-movement-by-pixels","title":"<code>VDU 23, 0, &amp;8C, x; y;</code>: Relative cursor movement (by pixels) \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>This command will move the text cursor by the given number of pixels in the X and Y directions.  The primary purpose of this command is to allow for slight adjustments of the text cursor position to facilitate text drawing features such as superscript, subscript and manual kerning.</p> <p>Normal cursor scrolling and wrapping behaviour will be obeyed, depending on the currently set cursor behaviour.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-90-n-b1-b2-b3-b4-b5-b6-b7-b8-redefine-character-n-0-255-with-8-bytes-of-data","title":"<code>VDU 23, 0, &amp;90, n, b1, b2, b3, b4, b5, b6, b7, b8</code>: Redefine character n (0-255) with 8 bytes of data \u00a7","text":"<p>This command works identically to <code>VDU 23, n, b1, b2, b3, b4, b5, b6, b7, b8</code>, but allows characters 0-31 to also be redefined.</p> <p>NB from Console8 VDP 2.8.0 this command will only funciton if the currently selected font is the system font.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-91-reset-all-system-font-characters-to-original-definition","title":"<code>VDU 23, 0, &amp;91</code>: Reset all system font characters to original definition \u00a7","text":"<p>This command will reset all system font characters to their original definitions.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-92-char-bitmapid-map-character-char-to-display-bitmapid","title":"<code>VDU 23, 0, &amp;92, char, bitmapId;</code>: Map character char to display bitmapId \u00a7\u00a7","text":"<p>This command will map a character to a bitmap.  The bitmap ID given must be a valid bitmap ID.  The purpose of this command is to allow for fast and efficient drawing of bitmaps to the screen, by allowing them to be drawn as characters.</p> <p>Any character number can be used, including those in the range of 0-31, or the usual/normal alphabetic range.  This could be used, for instance, to create a custom colour font.  It could alternatively be used with characters in the range of 128-255 to define a custom graphical tile-set, like PETSCII but in colour.</p> <p>When a character has been mapped to use a bitmap the bitmap will be used in place of that character, and will be drawn at the current text cursor position, placing the bottom left of the bitmap at the cursor position.  The cursor position will then be moved to the right by the width of a character, and not by the width of the bitmap.</p> <p>That last point is important.  It means that if you use a bitmap that is larger than a character, then the next character will overlap the bitmap.  Similarly bitmaps that are taller than a character will overwrite the line of text above the current cursor.  This can be used to create some interesting effects, but can also be a source of visual bugs if you are not careful.  If you are using oversized bitmaps, then using the <code>VDU 9</code> to move forward an additional character may be useful.</p> <p>Bitmaps mapped to characters in this way are plotted using the current foreground GCOL paint mode.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-93-x-y-get-ascii-code-of-character-at-graphics-position-x-y","title":"<code>VDU 23, 0, &amp;93, x; y;</code>: Get ASCII code of character at graphics position x, y \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>This command will return the ASCII code of the character at the given graphics position to MOS.  This command is similar to <code>VDU 23, 0, &amp;83, x; y;</code>, but uses coordinates from the currently selected graphics coordinate system.  The position is for the top left of the character.</p> <p>This command works by comparing pixels on the screen at the given position to the currently selected font, using the currently selected text colour.  This means that it may not always be accurate, or able to succeed.  Redefining system font characters after they have been drawn, changing the font, modifing the definitions of characters within the selected font, changing the text colour, may cause this command to fail.</p> <p>This command will not recognise characters that have been mapped to bitmaps using <code>VDU 23, 0, &amp;92, char, bitmapId;</code>.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-94-n-read-colour-palette-entry-n-returns-a-pixel-colour-data-packet","title":"<code>VDU 23, 0, &amp;94, n</code>: Read colour palette entry n (returns a pixel colour data packet) \u00a7\u00a7","text":"<p>This command will return the colour of the given palette entry to MOS.  This data is sent using a \"screen pixel\" data packet.  The corresponding MOS system variables related to screen pixel colour will be updated to reflect the read palette entry.</p> <p>The Agon VDP system supports a 64 colour palette, so values in the range of 0-63 will return data on that palette entry.  The following special values are also supported:</p> Value Description 128 The current text foreground colour 129 The current text background colour 130 The current graphics foreground colour 131 The current graphics background colour <p>Any other colour value will not be recognise, and no response sent.</p> <p>It should be noted that before Console8 VDP 2.7.0 when reading palette entries for the current text and graphics colours, the data packet returned would reflect back the colour number <code>n</code> sent to this command, rather than responding with the actual palette colour number for that colour.  As of Console8 VDP 2.7.0 the actual palette colour number is returned.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-95-command-args-font-management-commands","title":"<code>VDU 23, 0, &amp;95, &lt;command&gt;, [&lt;args&gt;]</code>: Font management commands \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>This command is used to manage fonts on your system.  For more information please see the Font API documentation.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-98-n-turn-control-keys-on-and-off","title":"<code>VDU 23, 0, &amp;98, n</code>: Turn control keys on and off \u00a7\u00a7\u00a7","text":"<p>Turns control keys on and off, where 1=on (the default) and 0=off.</p> <p>When control keys are turned on, pressing control and various letters on the keyboard will cause the keyboard to trigger VDU commands on the VDP, where the VDU command corresponds to the number of that letter in the alphabet.  For example, pressing <code>CTRL</code>+<code>N</code> will perform the VDU command <code>VDU 14</code> on the VDP and turn on \"paged mode\", as N is the fourteenth letter.</p> <p>Up to and including Console8 VDP 2.4.0, only <code>CTRL</code>+<code>N</code> and <code>CTRL</code>+<code>O</code> were supported, and would send <code>VDU 14</code> and <code>VDU 15</code> respectively, enabling and disabling \"paged mode\".  Console8 VDP 2.5.0 added support for several more letters, specifically <code>B</code>, <code>C</code>, <code>F</code>, <code>G</code>, <code>L</code>, <code>N</code> and <code>O</code>.  <code>CTRL</code>+<code>P</code> is also supported but rather than performing a VDU 16 it will toggle the printer on and off, compatible with behaviour on BBC BASIC for Windows.  (Owing to how the VDP and the eZ80 interact, it is unlikely that any more control keys will be added in the future.)</p> <p>When control keys are turned off, the keyboard will not trigger VDU commands on the VDP.</p> <p>Irrespective of whether the VDP has done anything with a control key, or whether they are enabled or not, key information will always be sent through to MOS.</p> <p>Until Console8 VDP 2.6.0, this control key behaviour on the VDP was always enabled, and could not be turned off.</p> <p>From Console8 VDP 2.6.0 onwards, the control keys can be turned off, which may help ensure that unexpected behaviour on the VDP does not occur when using applications running on MOS that may also wish to use these control key combinations.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-9c-set-the-text-viewport-using-graphics-coordinates","title":"<code>VDU 23, 0, &amp;9C</code>: Set the text viewport using graphics coordinates \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>Sets the text viewport using the rectangle described by the last two coordinates given via PLOT commands.  This command serves a similar purpose to <code>VDU 28</code>, but uses graphics coordinates instead of text coordinates, and does not require the coordinates to be sent as part of the command.  This allows for more flexibility in defining the viewport.</p> <p>Whilst the graphics cursor positions can be anywhere in the coordinate space, the text viewport will be limited to appear within the screen, and will be clipped to the screen.  If the resultant viewport has zero width or height (as the coordinates were off-screen) then the command will have no effect.  This behaviour differs from <code>VDU 28</code> which would reject the command if any of the coordinates given were off-screen.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-9d-set-the-graphics-viewport-using-graphics-coordinates","title":"<code>VDU 23, 0, &amp;9D</code>: Set the graphics viewport using graphics coordinates \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>Sets the graphics viewport using the rectangle described by the last two coordinates given via PLOT commands.  This command serves a similar purpose to <code>VDU 24</code>, but uses coordinates from the graphics coordinate stack, which allows for more flexibility in defining the viewport.  This can, for instance, be used to define a new viewport in coordinates that are relative to the current graphics origin.</p> <p>As per <code>VDU 23, 0, &amp;9C</code>, the viewport will be clipped to the screen if it is off-screen.  This behaviour differs from <code>VDU 24</code> which would reject the command if any of the coordinates given were off-screen.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-9e-set-the-graphics-origin-using-graphics-coordinates","title":"<code>VDU 23, 0, &amp;9E</code>: Set the graphics origin using graphics coordinates \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>Sets the graphics origin to the last coordinate given via PLOT commands.  This command serves a similar purpose to <code>VDU 29</code>, but uses coordinates from the graphics coordinate stack, which allows for more flexibility in defining the origin.  This can, for instance, be used to define a new origin in coordinates that are relative to the current origin.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-9f-move-the-graphics-origin-and-viewports","title":"<code>VDU 23, 0, &amp;9F</code>: Move the graphics origin and viewports \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>Moves the graphics origin to the current graphics cursor position, and also moves the currently defined text and graphics viewports by the same relative amount that the origin has moved.</p> <p>As with <code>VDU 23, 0, &amp;9C</code> and <code>VDU 23, 0, &amp;9D</code> the resultant text and graphics viewports will be clipped to the screen area.  This means that this command is not reversible, i.e. if you move the origin to position <code>100,100</code> and then move it to <code>-100,-100</code> the viewports will not return to their original sizes, as they will have been shrunk in the process.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-a0-bufferid-command-args-buffered-command-api","title":"<code>VDU 23, 0, &amp;A0, &lt;bufferId&gt;, &lt;command&gt;, [&lt;args&gt;]</code>: Buffered command API **","text":"<p>Send a command to the VDP Buffered Commands API</p>"},{"location":"vdp/System-Commands/#vdu-23-0-a1-update-vdp-for-exclusive-use-of-the-agon-flash-tool","title":"<code>VDU 23, 0, &amp;A1</code>: Update VDP (for exclusive use of the agon-flash tool) **","text":"<p>This command is used by the agon-flash tool to update the VDP firmware.  It should not be used by any other software.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-c0-n-turn-logical-screen-scaling-on-and-off","title":"<code>VDU 23, 0, &amp;C0, n</code>: Turn logical screen scaling on and off *","text":"<p>Turns logical screen scaling on and off, where 1=on and 0=off.</p> <p>When logical scaling is turned off, the graphics system will no longer use the 1280x1024 logical coordinate system and instead use pixel coordinates.  The screen origin point at 0,0 will change to be the top left of the screen, and the Y axis will go down the screen instead of up.  </p> <p>For more information, see the Screen modes documentation.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-c1-n-switch-legacy-modes-on-or-off","title":"<code>VDU 23, 0, &amp;C1, n</code>: Switch legacy modes on or off **","text":"<p>Turns legacy screen modes on and off, where 1=on and 0=off.</p> <p>By default, the original screen modes 0-4 are not available and are instead replaced by new modes that are more compatible with modern monitors.  For compatibility with older software, written for Agon systems running earlier versions of the VDP firmware, this command can be used to switch back to those original, legacy, screen modes.</p> <p>For more information, see the Screen modes documentation.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-c3-swap-the-screen-buffer-andor-wait-for-vsync","title":"<code>VDU 23, 0, &amp;C3</code>: Swap the screen buffer and/or wait for VSYNC **","text":"<p>Swap the screen buffer (double-buffered modes only) or wait for VSYNC (all modes).</p> <p>This command will swap the screen buffer, if the current screen mode is double-buffered, doing so at the next VSYNC.  If the current screen mode is not double-buffered then this command will wait for the next VSYNC signal before returning.  This can be used to synchronise the screen with the vertical refresh rate of the monitor.</p> <p>Waiting for VSYNC can be useful for ensuring smooth graphical animation, as it will prevent tearing of the screen.</p> <p>(In BASIC performing a <code>*FX 19</code> command will perform a similar wait for VSYNC, but on the eZ80 side of the system, but will not swap the screen buffer.)</p>"},{"location":"vdp/System-Commands/#vdu-23-0-c8-command-args-context-management-api","title":"<code>VDU 23, 0, &amp;C8, &lt;command&gt;, [&lt;args&gt;]</code>: Context management API \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>Send a command to the Context Management API.  This allows management of the current graphics context, which includes the current font, text and graphics colours, and the current GCOL paint mode.</p> <p>The context management API allows for the entire current graphics state to be saved and restored, which can be useful for applications that need to temporarily change the graphics state, but then restore it to its original state.  As part of this, the current state can be saved to a stack, and then restored later.  Additionally completely separate context stacks can be selected.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-ca-flush-current-drawing-commands","title":"<code>VDU 23, 0, &amp;CA</code>: Flush current drawing commands \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>For performance reasons, all drawing commands (for both graphics and text) received by the VDP are actually placed in a queue, and are not immediately drawn to the screen.  This command will force all pending drawing commands to be processed and drawn to the screen.</p> <p>This command is useful for some advanced operations, such as on-the-fly redefining character data in a custom font, ensuring that all characters are drawn before the font is redefined.</p> <p>Most applications will not need to use this command, as the VDP will automatically flush the drawing queue when it receives a command that requires the screen to be updated, such as reading a screen pixel.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-f2-n-set-dot-dash-pattern-length","title":"<code>VDU 23, 0, &amp;F2, n</code>: Set dot-dash pattern length \u00a7\u00a7\u00a7\u00a7","text":"<p>This command sets the length of the dot-dash pattern used for drawing lines with dotted line plot codes.  The default length is 8, and the length can be set to any value between 1 and 64.  Setting a length of 0 will reset to the default length, and reset the pattern to the default pattern.</p> <p>The line pattern can be set using <code>VDU 23, 6, n1, n2, n3, n4, n5, n6, n7, n8</code>, where <code>n1</code> is the first byte of the pattern, <code>n2</code> is the second byte, and so on.  Bits are used most-significant-bit first.</p> <p>Support for this command was added in Console8 VDP 2.7.0.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-fe-n-console-mode","title":"<code>VDU 23, 0, &amp;FE, n</code>: Console mode **","text":"<p>Turns \"console mode\" on and off, where 1=on and 0=off (the default).</p> <p>This mode is primarily intended for use with debugging tooling.  It will reflect VDU command bytes through to a serial terminal attached to the VDPs USB port, and will attempt to pass keyboard input from the serial terminal back through the VDP to MOS.</p> <p>This mode is not intended for general use.  If you are looking for a way to output data to the attached serial terminal then <code>VDU 2</code> is a better option.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-ff-switch-to-or-resume-terminal-mode","title":"<code>VDU 23, 0, &amp;FF</code>: Switch to or resume \"terminal mode\"","text":"<p>This command enables \"terminal mode\", which changges the behaviour of the VDP to be more like a traditional terminal.  This is useful for running CP/M in place of MOS on the eZ80, or other software that expects to be running on a terminal.</p> <p>When terminal mode is enabled, VDU commands will no longer be recognised and processed, keyboard entry in BBC BASIC/MOS is no longer supported, and the VDP protocol is essentially suspended.  Instead the VDP acts as a dumb terminal, and will send all keyboard input to the eZ80's UART0.  The eZ80 can then process this input as it sees fit.</p> <p>By default a VT100 terminal is emulated, but this can be changed by sending the appropriate escape sequences to the VDP.  Terminal support is inherited from FabGL, and so its custom escape sequences can be used to change the terminal behaviour.</p> <p>From Console8 VDP version 2.2.0, the following additional escape sequences are supported:</p> Sequence Description <code>ESC + \"_#Q!$\"</code> Quit/end terminal mode <code>ESC + \"_#S!$\"</code> Suspend terminal mode <p>Quitting terminal mode returns the VDP back to normal operation, and will resume the VDP protocol.  The screen mode will be reset to the mode that was active before terminal mode was enabled.</p> <p>Suspending terminal mode temporarily restores VDU command processing.  (Keyboard handling is unchanged.)  This could be useful to use VDU commands to perform drawing operations.  To resume terminal mode, <code>VDU 23, 0, &amp;FF</code> must be sent again.</p>"},{"location":"vdp/System-Commands/#serial-protocol","title":"Serial Protocol","text":"<p>Data sent from the VDP to the eZ80's UART0 is sent as a packet in the following format:</p> <ul> <li>cmd: The packet command, with bit 7 set</li> <li>len: Number of data bytes</li> <li>data: The data byte(s)</li> </ul> <p>Words are 16 bit, and sent in little-endian format</p> <p>In general, as a programmer using an Agon you should not need to worry about the format and contents of any of these packets, as they are handled by MOS.  On receipt of one of these packets, MOS will set system variables accordingly.  It also sets a bit in the VDPProtocol status byte corresponding to the type of data packet received.</p> <p>If you are performing a command where you need to wait for a response from the VDP, then you will need to wait for the appropriate bit to be set in the VDP protocol byte.  Before you send a command to the VDP you should clear the bit that relates to the command you are about to send.  Once the command has been processed the VDP will set the bit again.  If the bit is not set then there may have been an error processing the command.</p> <p>Packets:</p> <ul> <li><code>0x00, value</code>: General Poll</li> <li><code>0x01, keycode, modifiers, vkey, keydown</code>: Keyboard state</li> <li><code>0x02, x, y</code>: Cursor position</li> <li><code>0x03, char</code>: Character read from screen</li> <li><code>0x04, r, g, b, index</code>: Pixel colour read from screen</li> <li><code>0x05, channel, status</code>: Audio command status (see VDP Enhanced Audio API)</li> <li><code>0x06, width; height; cols, rows, colours</code>: Screen dimensions - width and height are words</li> <li><code>0x07, year, month, day, dayOfYear, dayOfWeek, hour, minute, second</code>: RTC data *</li> <li><code>0x08, delay, rate, led</code>: Keyboard status - delay and rate are words</li> <li><code>0x09, x; y; buttons, wheelDelta, deltaX; deltaY;</code>: Mouse status - x, y, deltaX and deltaY are words</li> </ul> <p>* as of VDP 1.04 the RTC data is sent in a packed format.  This is interpreted by MOS and expanded into the appropriate system variables.  Prior to VDP 1.04 the <code>dayOfYear</code> value could be incorrect, as it cannot be guaranteed to fit into a byte.</p> <p>MOS VDP Protocol flag bits:</p> Bit Description 0 Cursor position 1 Character read from screen 2 Point data (pixel colour) read from screen 3 Audio status 4 Mode info / Screen dimensions 5 RTC data 6 Mouse status"},{"location":"vdp/System-Commands/#keyboard","title":"Keyboard","text":"<p>When a key is pressed, a packet is sent with the following data: - cmd: 0x01 - keycode: The ASCII value of the key pressed - modifiers: A byte with the following bits set (1 = pressed): <pre><code>0. CTRL\n1. SHIFT\n2. ALT LEFT\n3. ALT RIGHT\n4. CAPS LOCK\n5. NUM LOCK\n6. SCROLL LOCK\n7. GUI\n</code></pre> From VDP 1.03, the following key data is also returned - vkey: The FabGL virtual keycode - keydown: 1 if the key is down, 0 if the key is up</p>"},{"location":"vdp/VDU-Commands/","title":"An Overview of VDU Commands","text":"<p>The Agon VDP system aims to be as compatible as practical with the Acorn BBC Micro's VDU command system.  It also supports some extensions as added by later Acorn computer systems, and the various versions of BBC BASIC by R.T.Russell.  Where necessary, some extensions have been added to help facilitate the Agon's unique features and architecture.</p> <p>This documentation provides a more in-depth explanation to each top-level VDU control code, and provides links to further documentation for more detailed individual commands.</p> <p>Please note that not all versions of the VDP support the complete command set.  The first version of the VDP to support the complete top-level list of VDU commands is the Agon Console8 VDP 2.5.0.  The following list uses the following symbols to indicate which VDP versions support which commands:</p> <p>* Requires VDP 1.03 or above  ** Requires VDP 1.04 or above  \u00a7 Requires Console8 VDP 2.3.0 or above  \u00a7\u00a7 Requires Console8 VDP 2.5.0 or above  \u00a7\u00a7\u00a7 Requires Console8 VDP 2.7.0 or above  \u00a7\u00a7\u00a7\u00a7 Requires Console8 VDP 2.8.0 or above</p> <p>In general, bytes/characters in the range of 0-31 are treated as control or command codes by the VDP.  Depending on the command, the VDP will then interpret bytes that follow as parameters to the command, continuing until sufficient bytes have been read to satisfy the command.  If there are insufficient bytes to satisfy the command, then the VDP will wait until more bytes are available, and timeout after 200ms.  If too many bytes are sent for a command, then the VDP will interpret those new bytes as another command.</p> <p>Any VDU command that is the VDP does not recognise (such as <code>VDU 2</code> when running on Quark 1.04) will be ignored.  Please note that when VDP comes across a command it does not understand it will proceed to interpret the next byte it receives as the next command.  This means that code written for a later version of the VDP may not work correctly on earlier versions and produce unexpected results.  Care should be taken to ensure that code is compatible with the VDP version it is running on, and it is generally advised to try to detect features before using them.</p> <p>All other characters, i.e. those in the range of 32 to 126 and 128 to 255, are sent to the screen as ASCII, unaltered.</p>"},{"location":"vdp/VDU-Commands/#vdu-0-null-no-operation","title":"<code>VDU 0</code>: Null (no operation)","text":"<p>On encountering a <code>VDU 0</code> command, the VDP will do nothing.  This may be useful for padding out a VDU command sequence, or for inserting a placeholder for a command that will be added later.</p>"},{"location":"vdp/VDU-Commands/#vdu-1-send-next-character-to-printer-if-printer-is-enabled","title":"<code>VDU 1</code>: Send next character to \"printer\" (if \"printer\" is enabled) \u00a7\u00a7","text":"<p>Ensures that the next character received by the VDP is sent through to the \"printer\", and not to the screen.  This is useful for sending control codes to the \"printer\", or for sending data to the \"printer\" that is not intended to be displayed on the screen.  It allows characters that would not otherwise normally be sent through to the \"printer\" to be sent.</p> <p>If the \"printer\" has not been enabled then this command will just discard the next byte sent to the VDP.</p>"},{"location":"vdp/VDU-Commands/#vdu-2-enable-printer","title":"<code>VDU 2</code>: Enable \"printer\" \u00a7\u00a7","text":"<p>Enables the \"printer\".</p> <p>In the context of the Agon platform, the \"printer\" is a serial terminal that is connected to the VDP's USB port.  Typically this port is used for power, but it can also be used to send and receive data to and from the VDP.</p> <p>When the \"printer\" is enabled, the VDP will send characters it receives to the \"printer\" as well as to the screen.  It will additionally send through control codes 8-13.  To send other control codes to the \"printer\", use the <code>VDU 1</code> command.</p> <p>The VDP will not send through other control codes to the printer, and will will not send through data it receives as part of other commands.</p>"},{"location":"vdp/VDU-Commands/#vdu-3-disable-printer","title":"<code>VDU 3</code>: Disable \"printer\" \u00a7\u00a7","text":"<p>Disables the \"printer\".</p>"},{"location":"vdp/VDU-Commands/#vdu-4-write-text-at-text-cursor","title":"<code>VDU 4</code>: Write text at text cursor","text":"<p>This causes text to be written at th current text cursor position.  This is the default mode for text display.</p> <p>Text is written using the current text foreground and background colours.</p>"},{"location":"vdp/VDU-Commands/#vdu-5-write-text-at-graphics-cursor","title":"<code>VDU 5</code>: Write text at graphics cursor","text":"<p>This causes text to be written at the current graphics cursor position.</p> <p>Using this, characters may be positioned at any graphics coordinate within the graphics viewport.  This is useful for positioning text over graphics, or for positioning text at a specific location on the screen.</p> <p>Characters are plotted using the current graphics foreground colour, using the current graphics foreground plotting mode (see <code>VDU 18</code>).</p> <p>The character background is transparent, and will not overwrite any graphics that are already present at the character's location.  The exception to this is <code>VDU 27</code>, the \"delete\" character, which backspaces and deletes as per its usual behaviour, but will erase using the current graphics background colour.</p>"},{"location":"vdp/VDU-Commands/#vdu-6-enable-screen-opposite-of-vdu-21","title":"<code>VDU 6</code>: Enable screen (opposite of <code>VDU 21</code>) \u00a7\u00a7","text":"<p>This enables the screen, and re-enables VDU command processing, reversing the effect of <code>VDU 21</code>.</p>"},{"location":"vdp/VDU-Commands/#vdu-7-make-a-short-beep-bel","title":"<code>VDU 7</code>: Make a short beep (BEL)","text":"<p>Plays a short beep sound on audio channel 0.  If the audio channel is already in use, or has been disabled, then this command will have no effect.</p>"},{"location":"vdp/VDU-Commands/#vdu-8-move-cursor-back-one-character","title":"<code>VDU 8</code>: Move cursor back one character","text":"<p>Moves the text cursor one character in the negative \"X\" direction.  By default, when at the start of a line it will move to the end of the previous line (as defined by the current text viewport).  If the cursor is also at the top of the screen then the viewport will scroll down.  The cursor remains constrained to the current text viewport.</p> <p>When in <code>VDU 5</code> mode and the graphics cursor is active, the viewport will not scroll.  The cursor is just moved left by one character width.</p> <p>Further behaviour of the cursor can be controlled using the <code>VDU 23,16</code> command.</p> <p>It should be noted that as of Console8 VDP 2.5.0, the cursor system does not support adjusting the direction of the cursor's X axis, so this command will move the cursor to the left.  This is likely to change in the future.</p>"},{"location":"vdp/VDU-Commands/#vdu-9-move-cursor-forward-one-character","title":"<code>VDU 9</code>: Move cursor forward one character","text":"<p>Moves the text cursor one character in the positive \"X\" direction.  By default, when at the end of a line it will move to the start of the next line (as defined by the current text viewport).  If the cursor is also at the bottom of the screen then the viewport will scroll up.</p> <p>Essentially this is the opposite of <code>VDU 8</code>.</p> <p>When in <code>VDU 5</code> mode and the graphics cursor is active, the viewport will not scroll.</p>"},{"location":"vdp/VDU-Commands/#vdu-10-move-cursor-down-one-line","title":"<code>VDU 10</code>: Move cursor down one line","text":"<p>Moves the text cursor one line in the positive \"Y\" direction.  By default, when at the bottom of the screen the viewport will scroll upwards.</p> <p>When in <code>VDU 5</code> mode and the graphics cursor is active, the viewport will not scroll, and the cursor is just moved down by one character height.</p>"},{"location":"vdp/VDU-Commands/#vdu-11-move-cursor-up-one-line","title":"<code>VDU 11</code>: Move cursor up one line","text":"<p>Moves the text cursor one line in the negative \"Y\" direction.  By default, when at the top of the screen the viewport will scroll downwards.</p> <p>Essentially this is the opposite of <code>VDU 10</code>.</p> <p>When in <code>VDU 5</code> mode and the graphics cursor is active, the viewport will not scroll.</p>"},{"location":"vdp/VDU-Commands/#vdu-12-clear-text-area-cls","title":"<code>VDU 12</code>: Clear text area (<code>CLS</code>)","text":"<p>Clears the current text viewport to the current text background colour, and moves the text cursor to the \"home\" position of the viewport (usually the top left).</p> <p>This is identical to the BASIC <code>CLS</code> keyword.</p>"},{"location":"vdp/VDU-Commands/#vdu-13-carriage-return","title":"<code>VDU 13</code>: Carriage return","text":"<p>Moves the text cursor to the start (or column 0) of the current line.</p>"},{"location":"vdp/VDU-Commands/#vdu-14-page-mode-on","title":"<code>VDU 14</code>: Page mode On *","text":"<p>When page mode is on, scrolling will stop after each page.  Output will be paused until \"Shift\" has been pressed on the keyboard.</p>"},{"location":"vdp/VDU-Commands/#vdu-15-page-mode-off","title":"<code>VDU 15</code>: Page mode Off *","text":"<p>Disables page mode.  This is the default mode.</p>"},{"location":"vdp/VDU-Commands/#vdu-16-clear-graphics-area-clg","title":"<code>VDU 16</code>: Clear graphics area (<code>CLG</code>)","text":"<p>Clears the current graphics viewport to the current graphics background colour.</p> <p>The current graphics cursor is unaffected.</p> <p>This is identical to the BASIC <code>CLG</code> keyword.</p>"},{"location":"vdp/VDU-Commands/#vdu-17-colour-set-text-colour-colour","title":"<code>VDU 17, colour</code>: Set text colour (<code>COLOUR</code>)","text":"<p>This will set the current text colour to the given colour, as defined by the colour palette.</p> <p>Colour numbers in the range 0-127 are interpreted as foreground colours, and numbers in the range 128-255 are interpreted as background colours.</p> <p>The actual range of colours supported will depend on the screen mode you are using.  Agon systems can only actually display a maximum of 64 colours (numbered 0 to 63).  The VDP will loop around the colour palette if a colour number is given that is outside the range of colours supported by the screen mode.  This means that for instance colour 65 is always equivalent to colour 1, or when in a 16 colour screen mode selecting colour 32 would be equivalent to choosing colour 0.</p> <p>This command is identical to the BASIC <code>COLOUR</code> keyword.</p>"},{"location":"vdp/VDU-Commands/#vdu-18-mode-colour-set-graphics-colour-gcol-mode-colour","title":"<code>VDU 18, mode, colour</code>: Set graphics colour (<code>GCOL mode, colour</code>)","text":"<p>This command will set both the current graphics colour, and the current graphics painting mode.</p> <p>As with <code>VDU 17</code> the colour number will set the foreground colour if it is in the range 0-127, or the background colour if it is in the range 128-255, and will be interpreted in the same manner.</p> <p>Up to and including Console8 VDP 2.5.0 support for the <code>mode</code> parameter was highly limited.  The only fully supported mode was mode 0, which is the default mode.  This mode sets on-screen pixels with the target colour.  From VDP 1.04 onwards there was very limited support for mode 4, which would invert on-screen pixels, but was only supported for straight line plotting operations.</p> <p>As of Console8 VDP 2.6.0, all 8 of the basic modes are supported for all currently supported plot operations.  Separate plot modes are tracked for foreground and background colours.</p> <p>The full array of available modes is as follows:</p> Mode Effect 0 Set on-screen pixel to target colour value 1 OR value with the on-screen pixel 2 AND value with the on-screen pixel 3 EOR value with the on-screen pixel 4 Invert the on-screen pixel 5 No operation 6 AND the inverse of the specified colour with the on-screen pixel 7 OR the inverse of the specified colour with the on-screen pixel <p>For more information on the various plot commands, please see the VDP PLOT command documentation</p> <p>(Acorn's graphics system supported some further GCOL mode options, which could specify the use of a fill pattern, which is not currently supported by the Agon VDP.  Support for these modes may be added in a future version of the VDP firmware.)</p> <p>This command is identical to the BASIC <code>GCOL</code> keyword.</p>"},{"location":"vdp/VDU-Commands/#vdu-19-l-p-r-g-b-define-logical-colour","title":"<code>VDU 19, l, p, r, g, b</code>: Define logical colour","text":"<p>This command sets the colour palette, by mapping a logical colour (i.e. the colour as selected via <code>VDU 17, colour</code> or <code>VDU 18, mode, colour</code>) to a physical colour.  This is useful for defining custom colours, or for redefining the default colours.</p> <p>If the physical colour number is given as 255 then the colour will be defined using the red, green, and blue values given.</p> <p>If the physical colour value is less than 64, the value is interpreted as a 6-bit colour number where the number in binary form is in the format <code>RRGGBB</code>.</p> <p>Any other physical colour value (i.e. 64 to 254) is not valid and the command will be ignored.</p> <p>If the physical colour is not 255 then the red, green, and blue values must still be provided, but will be ignored.</p> <p>The values for red, green and blue must be given in the range 0-255.  You should note that the physical Agon hardware only supports 64 colours, so the actual colour displayed may not be exactly the same as the colour requested.  The nearest colour will be chosen.</p> <p>Up to and including Console8 VDP 2.5.0 this command would have no effect when in a 64 colour screen mode, and the palette in those modes was fixed.</p> <p>From Console8 VDP 2.6.0 onwards, the command will now work in all screen modes, and will allow for the definition of custom colours.  Please note that when in a 64 colour screen mode there is no \"palette\" for the screen display per-se, so the command will not have any effect to the existing screen display.  It will only affect the colours used for subsequent graphics or text operations.</p> <p>This command is equivalent to the two ways the BASIC <code>COLOUR</code> keyword can be used to redefine the colour palette: <code>COLOUR l, p</code> or <code>COLOUR l, r, g, b</code>.</p>"},{"location":"vdp/VDU-Commands/#vdu-20-reset-palette-and-textgraphics-colours-and-drawing-modes","title":"<code>VDU 20</code>: Reset palette and text/graphics colours and drawing modes \u00a7\u00a7","text":"<p>This command will reset the colour palette to the default palette, and will reset the text and graphics colours and drawing modes to their default values.</p>"},{"location":"vdp/VDU-Commands/#vdu-21-disable-screen","title":"<code>VDU 21</code>: Disable screen \u00a7\u00a7","text":"<p>This command will \"disable the screen\", stopping any further VDU commands from being processed.  This is useful for temporarily disabling the screen, for instance when using the \"printer\" to send data to a serial terminal.  The actual screen display will not be turned off, but the VDP will stop processing VDU commands so changes to the display will not be made until the screen is re-enabled.</p> <p>The exception to this is commands <code>VDU 1</code> and <code>VDU 6</code>, which will still be processed.  If the \"printer\" has been enabled, bytes sent to the VDP still be sent through to the \"printer\", with the restrictions as described against <code>VDU 2</code>.</p> <p>Please note that the behaviour of the Agon system differs from Acorn systems when <code>VDU 21</code> has been called.  On an Agon system, when the screen has been disabled the VDP will consider each and every byte received as a new command, looking out specifically for a <code>VDU 6</code> command byte to re-enable the command interpreter.  It will not attempt to interpret any bytes received as a parameter to the previous command.  An Acorn system, on the other hand, would accept parameters for VDU commands, and just not process the command.  This means that code written for an Acorn system may not work correctly on an Agon system if it uses <code>VDU 21</code>.</p>"},{"location":"vdp/VDU-Commands/#vdu-22-n-select-screen-mode-mode-n","title":"<code>VDU 22, n</code>: Select screen mode (<code>MODE n</code>)","text":"<p>Changes the screen mode to the given mode number.</p> <p>Please see the Screen Modes documentation for more information on the screen modes supported by the Agon VDP.</p> <p>This command is identical to the BASIC <code>MODE</code> keyword.</p> <p>Changing the screen mode will reset the graphics system, returning most settings to their defaults.  The current cursor behaviour (as defined using <code>VDU 23, 16, x, y</code>) will be retained.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-n-re-program-display-character-system-commands","title":"<code>VDU 23, n</code>: Re-program display character / System Commands","text":"<p>This command serves two purposes.</p> <p>Firstly when <code>n</code> is in the range of 32-255 it will re-program the character in the system font at the given character code.  This is useful for redefining the character set, or for adding custom characters to the system character set.  The format of the command in this mode is: <pre><code>VDU 23, char_no, r1, r2, r3, r4, r5, r6, r7, r8\n</code></pre> Where <code>char_no</code> is the character number to re-program, and <code>r1</code> to <code>r8</code> are the 8 bytes of data that define the character in rows from top to bottom.  Each byte defines one row of the character, with the least significant bit of each byte defining the left-most pixel of the row, and the most significant bit defining the right-most pixel of the row.</p> <p>Please note that as of Console8 VDP 2.8.0 this form of the command will only work if the system font is the currently selected font.  For more information please see the Font API documentation.</p> <p>Note: There is a related VDU 23 System Command which can program the entire character range 0-255, and a reset command is also available to reset the system font back to default.</p> <p>The second purpose of this command is to send system commands to the VDP.</p> <p>The following commands are supported:</p>"},{"location":"vdp/VDU-Commands/#vdu-23-0-command-arguments-system-commands","title":"<code>VDU 23, 0, &lt;command&gt;, [&lt;arguments&gt;]</code>: System commands","text":"<p>Commands starting with <code>VDU 23, 0</code> are system commands.  These commands are used to configure the VDP and to control its behaviour.  This includes functionality such as the audio system, the buffered commands API, font API, and context management API.  For more information see the System Commands documentation.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-1-n-cursor-control","title":"<code>VDU 23, 1, n</code>: Cursor control","text":"<p>This command controls the appearance of the text cursor.</p> Value Meaning 0 Hide the cursor 1 Show the cursor 2 Make the cursor steady \u00a7\u00a7\u00a7\u00a7 3 Make the cursor flash \u00a7\u00a7\u00a7\u00a7 <p>Please note that in VDU 5 mode the cursor will not be visible, and the cursor control commands will have no effect.</p> <p>Previous versions of this documentation indicated that values 2 and 3 were supported as of Console8 VDP version 2.7.0.  Unfortunately this was incorrect as a bug prevented these values from working correctly.  (This functionality could however be used via <code>VDU 23, 0, &amp;0A</code> on that version of the VDP.)  As of Console8 VDP 2.8.0 these values are now supported.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-6-n1-n2-n3-n4-n5-n6-n7-n8-set-dotted-line-pattern","title":"<code>VDU 23, 6, n1, n2, n3, n4, n5, n6, n7, n8</code>: Set dotted line pattern \u00a7\u00a7\u00a7","text":"<p>This command sets the dotted line pattern for the various dotted line (<code>VDU 25</code>) PLOT commands.  The pattern is defined by 8 bytes, where each bit in each byte defines a pixel in the pattern.  Bits are used from the pattern most significant bit first, from bytes <code>n1</code>-<code>n8</code>, so the top-most bits (most significant bits) of the first byte (<code>n1</code>) define the start of the pattern.</p> <p>The repeat length of the pattern is set using <code>VDU 23, 0, 242, n</code>, where <code>n</code> is the number of pixels to repeat the pattern for.  The default repeat length is 8, meaning that only the <code>n1</code> byte will be used for the pattern.  Setting the repeat length to zero will reset to the default pattern, with the default repeat length.</p> <p>The current dotted line pattern will be reset on changing screen mode.</p> <p>Support for this command was added in Agon Console8 VDP 2.7.0.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-7-extent-direction-movement-scroll","title":"<code>VDU 23, 7, extent, direction, movement</code>: Scroll","text":"<p>This command scrolls in a given direction.</p> <p>The <code>extent</code> parameter controls what part of the screen will be scrolled.  A value of <code>0</code> means the current text viewport, a <code>1</code> means the whole screen, a <code>2</code> means the current graphics viewport, and <code>3</code> is interpreted as the current \"active\" viewport (as chosen using <code>VDU 4</code> or <code>VDU 5</code>).</p> <p>The `direction`` parameter can be one of the following values:</p> Value Meaning 0 Scroll right 1 Scroll left 2 Scroll down 3 Scroll up 4 Scroll in positive X direction * 5 Scroll in negative X direction * 6 Scroll in positive Y direction * 7 Scroll in negative Y direction * <p>* Support for these values was added in Agon Console8 VDP 2.5.0 for cursor behaviour values set by <code>VDU 23, 16, x, y</code>, but only for bits 1 and 2.  As of Console8 VDP 2.7.0, bit 3 of the cursor behaviour is also supported allowing the x and y directions to be swapped, thus letting X be vertical and Y be horizontal.</p> <p>The <code>movement</code> parameter controls the movement amount.  A value of <code>0</code> means that the screen will be scrolled by one character width/height in the given direction.  Any other value is interpreted as the number of pixels to scroll in the given direction.</p> <p>Support for a <code>movement</code> value of zero was added in Agon Console8 VDP 2.5.0.  Before this version a <code>movement</code> value of zero would be interpreted as no movement.</p> <p>The Agon implementation of this command differs from Acorn systems in the interpretation of the <code>movement</code> and <code>extent</code> parameter.  On Acorn systems, the only valid <code>extent</code> values are 0 or 1.  Acorn's <code>movement</code> parameter can also only be 0 or 1, but vertical movement would always be one character height, and horizontal movement one character width for a movement value of 0, and one byte for a movement value of 1, which made the results of this command vary depending on the current screen mode.  The Agon implementation of this command allows for more flexibility, and allows for scrolling by a given number of pixels in any direction, at the cost of some compatibility.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-16-setting-mask-define-cursor-movement-behaviour","title":"<code>VDU 23, 16, setting, mask</code>: Define cursor movement behaviour","text":"<p>This command controls the behaviour of the text cursor.  It is used to adjust the cursor behaviour via a bitmask.  The new setting is calculated as: <pre><code>new_setting = (current_setting AND mask) EOR setting\n</code></pre></p> <p>This method of setting the cursor behaviour allows you to set individual bits, or to clear individual bits, without needing to know the current setting.</p> <p>The interpretation of the settings byte flags is as follows:</p> Bit Value Meaning 7 0 Normal value 7 1 Undefined 6 0 Graphics cursor (VDU 5 mode) does an implicit cr/lf when it moves off right of graphics viewport 6 1 Graphics cursor carries on off edge of graphics viewport 5 0 Cursor moves right after a character is printed 5 1 Cursor does not move right after a character is printed \u00a7 4 0 Text cursor (VDU 4 mode) will scroll when it moves off the bottom of the screen 4 1 Text cursor will wrap to top of screen when it moves off the bottom of the screen \u00a7 3, 2, 1 Defines the cursor direction, as follows * 3, 2, 1 0 0 0 X direction is right, Y direction is down * 3, 2, 1 0 0 1 X direction is left, Y direction is down * 3, 2, 1 0 1 0 X direction is right, Y direction is up * 3, 2, 1 0 1 1 X direction is left, Y direction is up * 3, 2, 1 1 0 0 X direction is down, Y direction is right * 3, 2, 1 1 0 1 X direction is down, Y direction is left * 3, 2, 1 1 1 0 X direction is up, Y direction is right * 3, 2, 1 1 1 1 X direction is up, Y direction is left * 0 0 Disable scroll protection 0 1 Enable scroll protection \u00a7 <p>The default value for each setting is zero, i.e. all bits are cleared.</p> <p>* Full support for these settings was added in Agon Console8 VDP 2.7.0.  Partial support for bits 1 and 2 was added in Console8 VDP 2.5.0 but only for direction-based scrolling (<code>VDU 23, 7</code>).</p> <p>\u00a7 Whilst the Quark documentation claims that bits 4 and 5 is supported in the Quark 1.04 release, they were not actually supported in the VDP firmware.  The cursor would always move right after a character was printed, and the text cursor could never wrap to the top of the screen.  The cursor direction bits were also not supported.  Support for scroll protection was also limited to an incorrect (buggy) implementation, which would simply prevent vertical scrolling.  Full support for all of these features was added in Agon Console8 VDP 2.7.0.</p> <p>Scroll protection, when enabled, means that when in <code>VDU 4</code> mode printing a character that results in the cursor moving off the right-hand edge of the screen will cause a \"pending newline\" to be generated, rather than immediately performing a newline.  When this occurs, the cursor position will be one position greater than the right-most accessible column.  This newline will be executed just before the next character is printed if the cursor has not otherwise been moved back within the screen.  This means that sending a backspace character (<code>VDU 127</code>) or cursor left command (<code>VDU 8</code>) would cancel the pending newline, whilst a cursor right command will execute it.</p> <p>Enabling scroll protection therefore allows you to print a character to the bottom right-most character position on the screen without causing the screen to scroll.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-23-n-set-line-thickness","title":"<code>VDU 23, 23, n</code>: Set line thickness \u00a7\u00a7\u00a7","text":"<p>This command sets the line thickness for the various line drawing commands.  The line thickness is set to <code>n</code> pixels.  The default line thickness is 1 pixel.</p> <p>This command was added to Agon Console8 VDP 2.6.0.  Prior to that version, the line thickness was always 1 pixel.  PLOT commands that draw filled shapes are not affected by the line thickness.  Line plot commands that omit the first or last point may produce unexpected results when the line thickness is greater than 1.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-27-command-arguments-bitmap-and-sprite-commands","title":"<code>VDU 23, 27, &lt;command&gt;, [&lt;arguments&gt;]</code>: Bitmap and sprite commands","text":"<p>See the Bitmap and Sprite Commands documentation for more information.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-28-hexload","title":"<code>VDU 23, 28</code>: Hexload","text":"<p>This command is used by the hexload utility, and should not be used by user applications.</p>"},{"location":"vdp/VDU-Commands/#vdu-24-left-bottom-right-top-set-graphics-viewport","title":"<code>VDU 24, left; bottom; right; top;</code>: Set graphics viewport **","text":"<p>This command sets the graphics viewport.  The graphics viewport defines the area of the screen that graphics will be drawn to.  It is also the area that will be cleared by the <code>VDU 16</code> command.</p> <p>It should be noted that the coordinates given for this command must lie within the screen area.  If the coordinates are outside of the screen area then the command will be ignored.  When using OS Coordinates (the default coordinate system) this means that the coordinates must be in the range 0-1279 for the x-axis positions, and 0-1023 for the y-axis positions.</p> <p>Coordinates given are \"inclusive\", meaning that drawing locations up to and including those given will be drawn to.  To set a graphics viewport that is a single pixel tall, therefore, the <code>bottom</code> and <code>top</code> coordinates should be the same.</p> <p>(Please note that owing to a bug in the VDP firmware, viewports of a single pixel wide or tall were not supported until Console8 VDP 2.7.0.  Prior to that version a command to set a single pixel high viewport would be ignored.)</p>"},{"location":"vdp/VDU-Commands/#vdu-25-mode-x-y-plot-command","title":"<code>VDU 25, mode, x; y;</code>: PLOT command","text":"<p>This command is used for graphics plotting, and is equivalent to the BASIC <code>PLOT</code> command.</p> <p>The aim for this command is to support all of Acorn's original <code>PLOT</code> modes, however currently only a limited number of plotting modes are supported.  Support for plot modes has expanded over time, and will continue to expand in the future.</p> <p>For more information see the PLOT Commands documentation.</p>"},{"location":"vdp/VDU-Commands/#vdu-26-reset-graphics-and-text-viewports","title":"<code>VDU 26</code>: Reset graphics and text viewports **","text":"<p>This command resets the graphics and text viewports to their default values, homes the text cursor, and resets the graphics origin.  The default graphics viewport is the whole screen, and the default text viewport is the whole screen.</p> <p>NB prior to Console8 VDP 2.8.0, this command had a bug and did not reset the graphics origin.</p>"},{"location":"vdp/VDU-Commands/#vdu-27-char-output-character-to-screen","title":"<code>VDU 27, char</code>: Output character to screen \u00a7","text":"<p>Sends the next character to the screen.  This allows for characters outside of the normal ASCII range of 32-126 and 128-255 to be drawn on the screen.</p>"},{"location":"vdp/VDU-Commands/#vdu-28-left-bottom-right-top-set-text-viewport","title":"<code>VDU 28, left, bottom, right, top</code>: Set text viewport **","text":"<p>This defines a text viewport.  The text viewport defines the area of the screen that text will be drawn to.  It is also the area that will be cleared by the <code>VDU 12</code> command.</p> <p>The coordinates given are character positions, based on the currently selected font, not pixel positions.</p>"},{"location":"vdp/VDU-Commands/#vdu-29-x-y-set-graphics-origin","title":"<code>VDU 29, x; y;</code>: Set graphics origin","text":"<p>This command sets the graphics origin.  This sets where on the screen graphics coordinates are relative to for drawing commands.</p>"},{"location":"vdp/VDU-Commands/#vdu-30-home-cursor","title":"<code>VDU 30</code>: Home cursor","text":"<p>When in <code>VDU 4</code> mode, this moves the text cursor to the home (top left) position of the current text viewport.  When in `VDU 5`` mode, this moves the graphics cursor to the home position of the current graphics viewport.</p>"},{"location":"vdp/VDU-Commands/#vdu-31-x-y-move-text-cursor-to-x-y-text-position","title":"<code>VDU 31, x, y</code>: Move text cursor to x, y text position","text":"<p>Moves the text cursor to the given text position.  The coordinates given are character positions based on the currently selected font, not pixel positions.</p> <p>This is equivalent to the BASIC <code>TAB(x, y)</code> statement.</p> <p>Please note that if you have changed the text viewport, the coordinates given will be relative to the text viewport, not the whole screen.</p> <p>The position of the text cursor is not constrained to the text viewport, so it is possible to move the cursor outside of the viewport.  A tab command attempting to move the cursor outside of the text viewport will be ignored.</p>"},{"location":"vdp/VDU-Commands/#vdu-127-backspace","title":"<code>VDU 127</code>: Backspace","text":"<p>Moves the text cursor back one character, and deletes the character at that position.</p>"}]}